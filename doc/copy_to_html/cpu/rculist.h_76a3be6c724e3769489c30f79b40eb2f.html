<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link href="cpip.css" rel="stylesheet" type="text/css" />
    <title>File: /Users/paulross/dev/linux/linux-3.13/include/linux/rculist.h</title>
  </head>
  <body>
    <h1>File: /Users/paulross/dev/linux/linux-3.13/include/linux/rculist.h</h1>
    <p>Green shading in the line number column
means the source is part of the translation unit, red means it is conditionally excluded.
Highlighted line numbers link to the translation unit page. Highlighted macros link to
the macro page.</p>
    <pre><a name="1" /><span class="Maybe">       1:</span> <span class="f">#</span><span class="n">ifndef</span> <a href="cpu.c_macros_ref.html#_X0xJTlVYX1JDVUxJU1RfSF8w"><span class="b">_LINUX_RCULIST_H</span></a>
<a name="2" /><span class="Maybe">       2:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_X0xJTlVYX1JDVUxJU1RfSF8w"><span class="b">_LINUX_RCULIST_H</span></a>
<a name="3" /><span class="Maybe">       3:</span> 
<a name="4" /><span class="Maybe">       4:</span> <span class="f">#</span><span class="n">ifdef</span> <a href="cpu.c_macros_ref.html#_X19LRVJORUxfX18w"><span class="b">__KERNEL__</span></a>
<a name="5" /><span class="Maybe">       5:</span> 
<a name="6" /><span class="Maybe">       6:</span> <span class="k">/*</span>
<a name="7" /><span class="Maybe">       7:</span> <span class="k"> * RCU-protected list version</span>
<a name="8" /><span class="Maybe">       8:</span> <span class="k"> */</span>
<a name="9" /><span class="Maybe">       9:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">list</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="10" /><span class="Maybe">      10:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">rcupdate</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="11" /><span class="Maybe">      11:</span> 
<a name="12" /><span class="Maybe">      12:</span> <span class="k">/*</span>
<a name="13" /><span class="Maybe">      13:</span> <span class="k"> * Why is there no list_empty_rcu()?  Because list_empty() serves this</span>
<a name="14" /><span class="Maybe">      14:</span> <span class="k"> * purpose.  The list_empty() function fetches the RCU-protected pointer</span>
<a name="15" /><span class="Maybe">      15:</span> <span class="k"> * and compares it to the address of the list head, but neither dereferences</span>
<a name="16" /><span class="Maybe">      16:</span> <span class="k"> * this pointer itself nor provides this pointer to the caller.  Therefore,</span>
<a name="17" /><span class="Maybe">      17:</span> <span class="k"> * it is not necessary to use rcu_dereference(), so that list_empty() can</span>
<a name="18" /><span class="Maybe">      18:</span> <span class="k"> * be used anywhere you would want to use a list_empty_rcu().</span>
<a name="19" /><span class="Maybe">      19:</span> <span class="k"> */</span>
<a name="20" /><span class="Maybe">      20:</span> 
<a name="21" /><span class="Maybe">      21:</span> <span class="k">/*</span>
<a name="22" /><span class="Maybe">      22:</span> <span class="k"> * INIT_LIST_HEAD_RCU - Initialize a list_head visible to RCU readers</span>
<a name="23" /><span class="Maybe">      23:</span> <span class="k"> * @list: list to be initialized</span>
<a name="24" /><span class="Maybe">      24:</span> <span class="k"> *</span>
<a name="25" /><span class="Maybe">      25:</span> <span class="k"> * You should instead use INIT_LIST_HEAD() for normal initialization and</span>
<a name="26" /><span class="Maybe">      26:</span> <span class="k"> * cleanup tasks, when readers have no access to the list being initialized.</span>
<a name="27" /><span class="Maybe">      27:</span> <span class="k"> * However, if the list being initialized is visible to readers, you</span>
<a name="28" /><span class="Maybe">      28:</span> <span class="k"> * need to keep the compiler from being too mischievous.</span>
<a name="29" /><span class="Maybe">      29:</span> <span class="k"> */</span>
<a name="30" /><span class="Maybe">      30:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">INIT_LIST_HEAD_RCU</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">list</span><span class="f">)</span>
<a name="31" /><span class="Maybe">      31:</span> <span class="f">{</span>
<a name="32" /><span class="Maybe">      32:</span>     <a href="cpu.c_macros_ref.html#_QUNDRVNTX09OQ0VfMA__"><span class="b">ACCESS_ONCE</span></a><span class="f">(</span><span class="b">list</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">)</span> <span class="f">=</span> <span class="b">list</span><span class="f">;</span>
<a name="33" /><span class="Maybe">      33:</span>     <a href="cpu.c_macros_ref.html#_QUNDRVNTX09OQ0VfMA__"><span class="b">ACCESS_ONCE</span></a><span class="f">(</span><span class="b">list</span><span class="f">-&gt;</span><span class="b">prev</span><span class="f">)</span> <span class="f">=</span> <span class="b">list</span><span class="f">;</span>
<a name="34" /><span class="Maybe">      34:</span> <span class="f">}</span>
<a name="35" /><span class="Maybe">      35:</span> 
<a name="36" /><span class="Maybe">      36:</span> <span class="k">/*</span>
<a name="37" /><span class="Maybe">      37:</span> <span class="k"> * return the -&gt;next pointer of a list_head in an rcu safe</span>
<a name="38" /><span class="Maybe">      38:</span> <span class="k"> * way, we must not access it directly</span>
<a name="39" /><span class="Maybe">      39:</span> <span class="k"> */</span>
<a name="40" /><span class="Maybe">      40:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_bGlzdF9uZXh0X3JjdV8w"><span class="b">list_next_rcu</span></a><span class="f">(</span><span class="b">list</span><span class="f">)</span>    <span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <span class="f">*</span><span class="f">*</span><span class="f">)</span><span class="f">(</span><span class="f">&amp;</span><span class="f">(</span><span class="b">list</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">)</span><span class="f">)</span><span class="f">)</span>
<a name="41" /><span class="Maybe">      41:</span> 
<a name="42" /><span class="Maybe">      42:</span> <span class="k">/*</span>
<a name="43" /><span class="Maybe">      43:</span> <span class="k"> * Insert a new entry between two known consecutive entries.</span>
<a name="44" /><span class="Maybe">      44:</span> <span class="k"> *</span>
<a name="45" /><span class="Maybe">      45:</span> <span class="k"> * This is only for internal list manipulation where we know</span>
<a name="46" /><span class="Maybe">      46:</span> <span class="k"> * the prev/next entries already!</span>
<a name="47" /><span class="Maybe">      47:</span> <span class="k"> */</span>
<a name="48" /><span class="Maybe">      48:</span> <span class="f">#</span><span class="n">ifndef</span> <span class="b">CONFIG_DEBUG_LIST</span>
<a name="49" /><span class="Maybe">      49:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">__list_add_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="m">new</span><span class="f">,</span>
<a name="50" /><span class="Maybe">      50:</span>         <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">prev</span><span class="f">,</span> <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">next</span><span class="f">)</span>
<a name="51" /><span class="Maybe">      51:</span> <span class="f">{</span>
<a name="52" /><span class="Maybe">      52:</span>     <span class="m">new</span><span class="f">-&gt;</span><span class="b">next</span> <span class="f">=</span> <span class="b">next</span><span class="f">;</span>
<a name="53" /><span class="Maybe">      53:</span>     <span class="m">new</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <span class="b">prev</span><span class="f">;</span>
<a name="54" /><span class="Maybe">      54:</span>     <a href="cpu.c_macros_ref.html#_cmN1X2Fzc2lnbl9wb2ludGVyXzA_"><span class="b">rcu_assign_pointer</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_bGlzdF9uZXh0X3JjdV8w"><span class="b">list_next_rcu</span></a><span class="f">(</span><span class="b">prev</span><span class="f">)</span><span class="f">,</span> <span class="m">new</span><span class="f">)</span><span class="f">;</span>
<a name="55" /><span class="Maybe">      55:</span>     <span class="b">next</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <span class="m">new</span><span class="f">;</span>
<a name="56" /><span class="Maybe">      56:</span> <span class="f">}</span>
<a name="57" /><span class="False">      57:</span> <span class="f">#</span><span class="n">else</span>
<a name="58" /><span class="False">      58:</span> <span class="m">extern</span> <span class="m">void</span> <span class="b">__list_add_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="m">new</span><span class="f">,</span>
<a name="59" /><span class="False">      59:</span>         <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">prev</span><span class="f">,</span> <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">next</span><span class="f">)</span><span class="f">;</span>
<a name="60" /><span class="Maybe">      60:</span> <span class="f">#</span><span class="n">endif</span>
<a name="61" /><span class="Maybe">      61:</span> 
<a name="62" /><span class="Maybe">      62:</span> <span class="k">/**</span>
<a name="63" /><span class="Maybe">      63:</span> <span class="k"> * list_add_rcu - add a new entry to rcu-protected list</span>
<a name="64" /><span class="Maybe">      64:</span> <span class="k"> * @new: new entry to be added</span>
<a name="65" /><span class="Maybe">      65:</span> <span class="k"> * @head: list head to add it after</span>
<a name="66" /><span class="Maybe">      66:</span> <span class="k"> *</span>
<a name="67" /><span class="Maybe">      67:</span> <span class="k"> * Insert a new entry after the specified head.</span>
<a name="68" /><span class="Maybe">      68:</span> <span class="k"> * This is good for implementing stacks.</span>
<a name="69" /><span class="Maybe">      69:</span> <span class="k"> *</span>
<a name="70" /><span class="Maybe">      70:</span> <span class="k"> * The caller must take whatever precautions are necessary</span>
<a name="71" /><span class="Maybe">      71:</span> <span class="k"> * (such as holding appropriate locks) to avoid racing</span>
<a name="72" /><span class="Maybe">      72:</span> <span class="k"> * with another list-mutation primitive, such as list_add_rcu()</span>
<a name="73" /><span class="Maybe">      73:</span> <span class="k"> * or list_del_rcu(), running on this same list.</span>
<a name="74" /><span class="Maybe">      74:</span> <span class="k"> * However, it is perfectly legal to run concurrently with</span>
<a name="75" /><span class="Maybe">      75:</span> <span class="k"> * the _rcu list-traversal primitives, such as</span>
<a name="76" /><span class="Maybe">      76:</span> <span class="k"> * list_for_each_entry_rcu().</span>
<a name="77" /><span class="Maybe">      77:</span> <span class="k"> */</span>
<a name="78" /><span class="Maybe">      78:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">list_add_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="m">new</span><span class="f">,</span> <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">head</span><span class="f">)</span>
<a name="79" /><span class="Maybe">      79:</span> <span class="f">{</span>
<a name="80" /><span class="Maybe">      80:</span>     <span class="b">__list_add_rcu</span><span class="f">(</span><span class="m">new</span><span class="f">,</span> <span class="b">head</span><span class="f">,</span> <span class="b">head</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">)</span><span class="f">;</span>
<a name="81" /><span class="Maybe">      81:</span> <span class="f">}</span>
<a name="82" /><span class="Maybe">      82:</span> 
<a name="83" /><span class="Maybe">      83:</span> <span class="k">/**</span>
<a name="84" /><span class="Maybe">      84:</span> <span class="k"> * list_add_tail_rcu - add a new entry to rcu-protected list</span>
<a name="85" /><span class="Maybe">      85:</span> <span class="k"> * @new: new entry to be added</span>
<a name="86" /><span class="Maybe">      86:</span> <span class="k"> * @head: list head to add it before</span>
<a name="87" /><span class="Maybe">      87:</span> <span class="k"> *</span>
<a name="88" /><span class="Maybe">      88:</span> <span class="k"> * Insert a new entry before the specified head.</span>
<a name="89" /><span class="Maybe">      89:</span> <span class="k"> * This is useful for implementing queues.</span>
<a name="90" /><span class="Maybe">      90:</span> <span class="k"> *</span>
<a name="91" /><span class="Maybe">      91:</span> <span class="k"> * The caller must take whatever precautions are necessary</span>
<a name="92" /><span class="Maybe">      92:</span> <span class="k"> * (such as holding appropriate locks) to avoid racing</span>
<a name="93" /><span class="Maybe">      93:</span> <span class="k"> * with another list-mutation primitive, such as list_add_tail_rcu()</span>
<a name="94" /><span class="Maybe">      94:</span> <span class="k"> * or list_del_rcu(), running on this same list.</span>
<a name="95" /><span class="Maybe">      95:</span> <span class="k"> * However, it is perfectly legal to run concurrently with</span>
<a name="96" /><span class="Maybe">      96:</span> <span class="k"> * the _rcu list-traversal primitives, such as</span>
<a name="97" /><span class="Maybe">      97:</span> <span class="k"> * list_for_each_entry_rcu().</span>
<a name="98" /><span class="Maybe">      98:</span> <span class="k"> */</span>
<a name="99" /><span class="Maybe">      99:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">list_add_tail_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="m">new</span><span class="f">,</span>
<a name="100" /><span class="Maybe">     100:</span>                     <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">head</span><span class="f">)</span>
<a name="101" /><span class="Maybe">     101:</span> <span class="f">{</span>
<a name="102" /><span class="Maybe">     102:</span>     <span class="b">__list_add_rcu</span><span class="f">(</span><span class="m">new</span><span class="f">,</span> <span class="b">head</span><span class="f">-&gt;</span><span class="b">prev</span><span class="f">,</span> <span class="b">head</span><span class="f">)</span><span class="f">;</span>
<a name="103" /><span class="Maybe">     103:</span> <span class="f">}</span>
<a name="104" /><span class="Maybe">     104:</span> 
<a name="105" /><span class="Maybe">     105:</span> <span class="k">/**</span>
<a name="106" /><span class="Maybe">     106:</span> <span class="k"> * list_del_rcu - deletes entry from list without re-initialization</span>
<a name="107" /><span class="Maybe">     107:</span> <span class="k"> * @entry: the element to delete from the list.</span>
<a name="108" /><span class="Maybe">     108:</span> <span class="k"> *</span>
<a name="109" /><span class="Maybe">     109:</span> <span class="k"> * Note: list_empty() on entry does not return true after this,</span>
<a name="110" /><span class="Maybe">     110:</span> <span class="k"> * the entry is in an undefined state. It is useful for RCU based</span>
<a name="111" /><span class="Maybe">     111:</span> <span class="k"> * lockfree traversal.</span>
<a name="112" /><span class="Maybe">     112:</span> <span class="k"> *</span>
<a name="113" /><span class="Maybe">     113:</span> <span class="k"> * In particular, it means that we can not poison the forward</span>
<a name="114" /><span class="Maybe">     114:</span> <span class="k"> * pointers that may still be used for walking the list.</span>
<a name="115" /><span class="Maybe">     115:</span> <span class="k"> *</span>
<a name="116" /><span class="Maybe">     116:</span> <span class="k"> * The caller must take whatever precautions are necessary</span>
<a name="117" /><span class="Maybe">     117:</span> <span class="k"> * (such as holding appropriate locks) to avoid racing</span>
<a name="118" /><span class="Maybe">     118:</span> <span class="k"> * with another list-mutation primitive, such as list_del_rcu()</span>
<a name="119" /><span class="Maybe">     119:</span> <span class="k"> * or list_add_rcu(), running on this same list.</span>
<a name="120" /><span class="Maybe">     120:</span> <span class="k"> * However, it is perfectly legal to run concurrently with</span>
<a name="121" /><span class="Maybe">     121:</span> <span class="k"> * the _rcu list-traversal primitives, such as</span>
<a name="122" /><span class="Maybe">     122:</span> <span class="k"> * list_for_each_entry_rcu().</span>
<a name="123" /><span class="Maybe">     123:</span> <span class="k"> *</span>
<a name="124" /><span class="Maybe">     124:</span> <span class="k"> * Note that the caller is not permitted to immediately free</span>
<a name="125" /><span class="Maybe">     125:</span> <span class="k"> * the newly deleted entry.  Instead, either synchronize_rcu()</span>
<a name="126" /><span class="Maybe">     126:</span> <span class="k"> * or call_rcu() must be used to defer freeing until an RCU</span>
<a name="127" /><span class="Maybe">     127:</span> <span class="k"> * grace period has elapsed.</span>
<a name="128" /><span class="Maybe">     128:</span> <span class="k"> */</span>
<a name="129" /><span class="Maybe">     129:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">list_del_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">entry</span><span class="f">)</span>
<a name="130" /><span class="Maybe">     130:</span> <span class="f">{</span>
<a name="131" /><span class="Maybe">     131:</span>     <span class="b">__list_del_entry</span><span class="f">(</span><span class="b">entry</span><span class="f">)</span><span class="f">;</span>
<a name="132" /><span class="Maybe">     132:</span>     <span class="b">entry</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_TElTVF9QT0lTT04yXzA_"><span class="b">LIST_POISON2</span></a><span class="f">;</span>
<a name="133" /><span class="Maybe">     133:</span> <span class="f">}</span>
<a name="134" /><span class="Maybe">     134:</span> 
<a name="135" /><span class="Maybe">     135:</span> <span class="k">/**</span>
<a name="136" /><span class="Maybe">     136:</span> <span class="k"> * hlist_del_init_rcu - deletes entry from hash list with re-initialization</span>
<a name="137" /><span class="Maybe">     137:</span> <span class="k"> * @n: the element to delete from the hash list.</span>
<a name="138" /><span class="Maybe">     138:</span> <span class="k"> *</span>
<a name="139" /><span class="Maybe">     139:</span> <span class="k"> * Note: list_unhashed() on the node return true after this. It is</span>
<a name="140" /><span class="Maybe">     140:</span> <span class="k"> * useful for RCU based read lockfree traversal if the writer side</span>
<a name="141" /><span class="Maybe">     141:</span> <span class="k"> * must know if the list entry is still hashed or already unhashed.</span>
<a name="142" /><span class="Maybe">     142:</span> <span class="k"> *</span>
<a name="143" /><span class="Maybe">     143:</span> <span class="k"> * In particular, it means that we can not poison the forward pointers</span>
<a name="144" /><span class="Maybe">     144:</span> <span class="k"> * that may still be used for walking the hash list and we can only</span>
<a name="145" /><span class="Maybe">     145:</span> <span class="k"> * zero the pprev pointer so list_unhashed() will return true after</span>
<a name="146" /><span class="Maybe">     146:</span> <span class="k"> * this.</span>
<a name="147" /><span class="Maybe">     147:</span> <span class="k"> *</span>
<a name="148" /><span class="Maybe">     148:</span> <span class="k"> * The caller must take whatever precautions are necessary (such as</span>
<a name="149" /><span class="Maybe">     149:</span> <span class="k"> * holding appropriate locks) to avoid racing with another</span>
<a name="150" /><span class="Maybe">     150:</span> <span class="k"> * list-mutation primitive, such as hlist_add_head_rcu() or</span>
<a name="151" /><span class="Maybe">     151:</span> <span class="k"> * hlist_del_rcu(), running on this same list.  However, it is</span>
<a name="152" /><span class="Maybe">     152:</span> <span class="k"> * perfectly legal to run concurrently with the _rcu list-traversal</span>
<a name="153" /><span class="Maybe">     153:</span> <span class="k"> * primitives, such as hlist_for_each_entry_rcu().</span>
<a name="154" /><span class="Maybe">     154:</span> <span class="k"> */</span>
<a name="155" /><span class="Maybe">     155:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">hlist_del_init_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">n</span><span class="f">)</span>
<a name="156" /><span class="Maybe">     156:</span> <span class="f">{</span>
<a name="157" /><span class="Maybe">     157:</span>     <span class="m">if</span> <span class="f">(</span><span class="f">!</span><span class="b">hlist_unhashed</span><span class="f">(</span><span class="b">n</span><span class="f">)</span><span class="f">)</span> <span class="f">{</span>
<a name="158" /><span class="Maybe">     158:</span>         <span class="b">__hlist_del</span><span class="f">(</span><span class="b">n</span><span class="f">)</span><span class="f">;</span>
<a name="159" /><span class="Maybe">     159:</span>         <span class="b">n</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_TlVMTF8w"><span class="b">NULL</span></a><span class="f">;</span>
<a name="160" /><span class="Maybe">     160:</span>     <span class="f">}</span>
<a name="161" /><span class="Maybe">     161:</span> <span class="f">}</span>
<a name="162" /><span class="Maybe">     162:</span> 
<a name="163" /><span class="Maybe">     163:</span> <span class="k">/**</span>
<a name="164" /><span class="Maybe">     164:</span> <span class="k"> * list_replace_rcu - replace old entry by new one</span>
<a name="165" /><span class="Maybe">     165:</span> <span class="k"> * @old : the element to be replaced</span>
<a name="166" /><span class="Maybe">     166:</span> <span class="k"> * @new : the new element to insert</span>
<a name="167" /><span class="Maybe">     167:</span> <span class="k"> *</span>
<a name="168" /><span class="Maybe">     168:</span> <span class="k"> * The @old entry will be replaced with the @new entry atomically.</span>
<a name="169" /><span class="Maybe">     169:</span> <span class="k"> * Note: @old should not be empty.</span>
<a name="170" /><span class="Maybe">     170:</span> <span class="k"> */</span>
<a name="171" /><span class="Maybe">     171:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">list_replace_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">old</span><span class="f">,</span>
<a name="172" /><span class="Maybe">     172:</span>                 <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="m">new</span><span class="f">)</span>
<a name="173" /><span class="Maybe">     173:</span> <span class="f">{</span>
<a name="174" /><span class="Maybe">     174:</span>     <span class="m">new</span><span class="f">-&gt;</span><span class="b">next</span> <span class="f">=</span> <span class="b">old</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="175" /><span class="Maybe">     175:</span>     <span class="m">new</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <span class="b">old</span><span class="f">-&gt;</span><span class="b">prev</span><span class="f">;</span>
<a name="176" /><span class="Maybe">     176:</span>     <a href="cpu.c_macros_ref.html#_cmN1X2Fzc2lnbl9wb2ludGVyXzA_"><span class="b">rcu_assign_pointer</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_bGlzdF9uZXh0X3JjdV8w"><span class="b">list_next_rcu</span></a><span class="f">(</span><span class="m">new</span><span class="f">-&gt;</span><span class="b">prev</span><span class="f">)</span><span class="f">,</span> <span class="m">new</span><span class="f">)</span><span class="f">;</span>
<a name="177" /><span class="Maybe">     177:</span>     <span class="m">new</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <span class="m">new</span><span class="f">;</span>
<a name="178" /><span class="Maybe">     178:</span>     <span class="b">old</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_TElTVF9QT0lTT04yXzA_"><span class="b">LIST_POISON2</span></a><span class="f">;</span>
<a name="179" /><span class="Maybe">     179:</span> <span class="f">}</span>
<a name="180" /><span class="Maybe">     180:</span> 
<a name="181" /><span class="Maybe">     181:</span> <span class="k">/**</span>
<a name="182" /><span class="Maybe">     182:</span> <span class="k"> * list_splice_init_rcu - splice an RCU-protected list into an existing list.</span>
<a name="183" /><span class="Maybe">     183:</span> <span class="k"> * @list:    the RCU-protected list to splice</span>
<a name="184" /><span class="Maybe">     184:</span> <span class="k"> * @head:    the place in the list to splice the first list into</span>
<a name="185" /><span class="Maybe">     185:</span> <span class="k"> * @sync:    function to sync: synchronize_rcu(), synchronize_sched(), ...</span>
<a name="186" /><span class="Maybe">     186:</span> <span class="k"> *</span>
<a name="187" /><span class="Maybe">     187:</span> <span class="k"> * @head can be RCU-read traversed concurrently with this function.</span>
<a name="188" /><span class="Maybe">     188:</span> <span class="k"> *</span>
<a name="189" /><span class="Maybe">     189:</span> <span class="k"> * Note that this function blocks.</span>
<a name="190" /><span class="Maybe">     190:</span> <span class="k"> *</span>
<a name="191" /><span class="Maybe">     191:</span> <span class="k"> * Important note: the caller must take whatever action is necessary to</span>
<a name="192" /><span class="Maybe">     192:</span> <span class="k"> *    prevent any other updates to @head.  In principle, it is possible</span>
<a name="193" /><span class="Maybe">     193:</span> <span class="k"> *    to modify the list as soon as sync() begins execution.</span>
<a name="194" /><span class="Maybe">     194:</span> <span class="k"> *    If this sort of thing becomes necessary, an alternative version</span>
<a name="195" /><span class="Maybe">     195:</span> <span class="k"> *    based on call_rcu() could be created.  But only if -really-</span>
<a name="196" /><span class="Maybe">     196:</span> <span class="k"> *    needed -- there is no shortage of RCU API members.</span>
<a name="197" /><span class="Maybe">     197:</span> <span class="k"> */</span>
<a name="198" /><span class="Maybe">     198:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">list_splice_init_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">list</span><span class="f">,</span>
<a name="199" /><span class="Maybe">     199:</span>                     <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">head</span><span class="f">,</span>
<a name="200" /><span class="Maybe">     200:</span>                     <span class="m">void</span> <span class="f">(</span><span class="f">*</span><span class="b">sync</span><span class="f">)</span><span class="f">(</span><span class="m">void</span><span class="f">)</span><span class="f">)</span>
<a name="201" /><span class="Maybe">     201:</span> <span class="f">{</span>
<a name="202" /><span class="Maybe">     202:</span>     <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">first</span> <span class="f">=</span> <span class="b">list</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="203" /><span class="Maybe">     203:</span>     <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">last</span> <span class="f">=</span> <span class="b">list</span><span class="f">-&gt;</span><span class="b">prev</span><span class="f">;</span>
<a name="204" /><span class="Maybe">     204:</span>     <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">at</span> <span class="f">=</span> <span class="b">head</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="205" /><span class="Maybe">     205:</span> 
<a name="206" /><span class="Maybe">     206:</span>     <span class="m">if</span> <span class="f">(</span><span class="b">list_empty</span><span class="f">(</span><span class="b">list</span><span class="f">)</span><span class="f">)</span>
<a name="207" /><span class="Maybe">     207:</span>         <span class="m">return</span><span class="f">;</span>
<a name="208" /><span class="Maybe">     208:</span> 
<a name="209" /><span class="Maybe">     209:</span>     <span class="k">/*</span>
<a name="210" /><span class="Maybe">     210:</span> <span class="k">     * &quot;first&quot; and &quot;last&quot; tracking list, so initialize it.  RCU readers</span>
<a name="211" /><span class="Maybe">     211:</span> <span class="k">     * have access to this list, so we must use INIT_LIST_HEAD_RCU()</span>
<a name="212" /><span class="Maybe">     212:</span> <span class="k">     * instead of INIT_LIST_HEAD().</span>
<a name="213" /><span class="Maybe">     213:</span> <span class="k">     */</span>
<a name="214" /><span class="Maybe">     214:</span> 
<a name="215" /><span class="Maybe">     215:</span>     <span class="b">INIT_LIST_HEAD_RCU</span><span class="f">(</span><span class="b">list</span><span class="f">)</span><span class="f">;</span>
<a name="216" /><span class="Maybe">     216:</span> 
<a name="217" /><span class="Maybe">     217:</span>     <span class="k">/*</span>
<a name="218" /><span class="Maybe">     218:</span> <span class="k">     * At this point, the list body still points to the source list.</span>
<a name="219" /><span class="Maybe">     219:</span> <span class="k">     * Wait for any readers to finish using the list before splicing</span>
<a name="220" /><span class="Maybe">     220:</span> <span class="k">     * the list body into the new list.  Any new readers will see</span>
<a name="221" /><span class="Maybe">     221:</span> <span class="k">     * an empty list.</span>
<a name="222" /><span class="Maybe">     222:</span> <span class="k">     */</span>
<a name="223" /><span class="Maybe">     223:</span> 
<a name="224" /><span class="Maybe">     224:</span>     <span class="b">sync</span><span class="f">(</span><span class="f">)</span><span class="f">;</span>
<a name="225" /><span class="Maybe">     225:</span> 
<a name="226" /><span class="Maybe">     226:</span>     <span class="k">/*</span>
<a name="227" /><span class="Maybe">     227:</span> <span class="k">     * Readers are finished with the source list, so perform splice.</span>
<a name="228" /><span class="Maybe">     228:</span> <span class="k">     * The order is important if the new list is global and accessible</span>
<a name="229" /><span class="Maybe">     229:</span> <span class="k">     * to concurrent RCU readers.  Note that RCU readers are not</span>
<a name="230" /><span class="Maybe">     230:</span> <span class="k">     * permitted to traverse the prev pointers without excluding</span>
<a name="231" /><span class="Maybe">     231:</span> <span class="k">     * this function.</span>
<a name="232" /><span class="Maybe">     232:</span> <span class="k">     */</span>
<a name="233" /><span class="Maybe">     233:</span> 
<a name="234" /><span class="Maybe">     234:</span>     <span class="b">last</span><span class="f">-&gt;</span><span class="b">next</span> <span class="f">=</span> <span class="b">at</span><span class="f">;</span>
<a name="235" /><span class="Maybe">     235:</span>     <a href="cpu.c_macros_ref.html#_cmN1X2Fzc2lnbl9wb2ludGVyXzA_"><span class="b">rcu_assign_pointer</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_bGlzdF9uZXh0X3JjdV8w"><span class="b">list_next_rcu</span></a><span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">,</span> <span class="b">first</span><span class="f">)</span><span class="f">;</span>
<a name="236" /><span class="Maybe">     236:</span>     <span class="b">first</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <span class="b">head</span><span class="f">;</span>
<a name="237" /><span class="Maybe">     237:</span>     <span class="b">at</span><span class="f">-&gt;</span><span class="b">prev</span> <span class="f">=</span> <span class="b">last</span><span class="f">;</span>
<a name="238" /><span class="Maybe">     238:</span> <span class="f">}</span>
<a name="239" /><span class="Maybe">     239:</span> 
<a name="240" /><span class="Maybe">     240:</span> <span class="k">/**</span>
<a name="241" /><span class="Maybe">     241:</span> <span class="k"> * list_entry_rcu - get the struct for this entry</span>
<a name="242" /><span class="Maybe">     242:</span> <span class="k"> * @ptr:        the &amp;struct list_head pointer.</span>
<a name="243" /><span class="Maybe">     243:</span> <span class="k"> * @type:       the type of the struct this is embedded in.</span>
<a name="244" /><span class="Maybe">     244:</span> <span class="k"> * @member:     the name of the list_struct within the struct.</span>
<a name="245" /><span class="Maybe">     245:</span> <span class="k"> *</span>
<a name="246" /><span class="Maybe">     246:</span> <span class="k"> * This primitive may safely run concurrently with the _rcu list-mutation</span>
<a name="247" /><span class="Maybe">     247:</span> <span class="k"> * primitives such as list_add_rcu() as long as it&apos;s guarded by rcu_read_lock().</span>
<a name="248" /><span class="Maybe">     248:</span> <span class="k"> */</span>
<a name="249" /><span class="Maybe">     249:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_bGlzdF9lbnRyeV9yY3VfMA__"><span class="b">list_entry_rcu</span></a><span class="f">(</span><span class="b">ptr</span><span class="f">,</span> <span class="b">type</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span> \
<a name="250" /><span class="Maybe">     250:</span>     <span class="f">(</span><span class="f">{</span><span class="b">typeof</span> <span class="f">(</span><span class="f">*</span><span class="b">ptr</span><span class="f">)</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <span class="f">*</span><span class="b">__ptr</span> <span class="f">=</span> <span class="f">(</span><span class="b">typeof</span> <span class="f">(</span><span class="f">*</span><span class="b">ptr</span><span class="f">)</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <a href="cpu.c_macros_ref.html#_X19mb3JjZV8w"><span class="b">__force</span></a> <span class="f">*</span><span class="f">)</span><span class="b">ptr</span><span class="f">;</span> \
<a name="251" /><span class="Maybe">     251:</span>      <a href="cpu.c_macros_ref.html#_Y29udGFpbmVyX29mXzA_"><span class="b">container_of</span></a><span class="f">(</span><span class="f">(</span><span class="b">typeof</span><span class="f">(</span><span class="b">ptr</span><span class="f">)</span><span class="f">)</span><a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlX3Jhd18w"><span class="b">rcu_dereference_raw</span></a><span class="f">(</span><span class="b">__ptr</span><span class="f">)</span><span class="f">,</span> <span class="b">type</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span> \
<a name="252" /><span class="Maybe">     252:</span>     <span class="f">}</span><span class="f">)</span>
<a name="253" /><span class="Maybe">     253:</span> 
<a name="254" /><span class="Maybe">     254:</span> <span class="k">/**</span>
<a name="255" /><span class="Maybe">     255:</span> <span class="k"> * Where are list_empty_rcu() and list_first_entry_rcu()?</span>
<a name="256" /><span class="Maybe">     256:</span> <span class="k"> *</span>
<a name="257" /><span class="Maybe">     257:</span> <span class="k"> * Implementing those functions following their counterparts list_empty() and</span>
<a name="258" /><span class="Maybe">     258:</span> <span class="k"> * list_first_entry() is not advisable because they lead to subtle race</span>
<a name="259" /><span class="Maybe">     259:</span> <span class="k"> * conditions as the following snippet shows:</span>
<a name="260" /><span class="Maybe">     260:</span> <span class="k"> *</span>
<a name="261" /><span class="Maybe">     261:</span> <span class="k"> * if (!list_empty_rcu(mylist)) {</span>
<a name="262" /><span class="Maybe">     262:</span> <span class="k"> *    struct foo *bar = list_first_entry_rcu(mylist, struct foo, list_member);</span>
<a name="263" /><span class="Maybe">     263:</span> <span class="k"> *    do_something(bar);</span>
<a name="264" /><span class="Maybe">     264:</span> <span class="k"> * }</span>
<a name="265" /><span class="Maybe">     265:</span> <span class="k"> *</span>
<a name="266" /><span class="Maybe">     266:</span> <span class="k"> * The list may not be empty when list_empty_rcu checks it, but it may be when</span>
<a name="267" /><span class="Maybe">     267:</span> <span class="k"> * list_first_entry_rcu rereads the -&gt;next pointer.</span>
<a name="268" /><span class="Maybe">     268:</span> <span class="k"> *</span>
<a name="269" /><span class="Maybe">     269:</span> <span class="k"> * Rereading the -&gt;next pointer is not a problem for list_empty() and</span>
<a name="270" /><span class="Maybe">     270:</span> <span class="k"> * list_first_entry() because they would be protected by a lock that blocks</span>
<a name="271" /><span class="Maybe">     271:</span> <span class="k"> * writers.</span>
<a name="272" /><span class="Maybe">     272:</span> <span class="k"> *</span>
<a name="273" /><span class="Maybe">     273:</span> <span class="k"> * See list_first_or_null_rcu for an alternative.</span>
<a name="274" /><span class="Maybe">     274:</span> <span class="k"> */</span>
<a name="275" /><span class="Maybe">     275:</span> 
<a name="276" /><span class="Maybe">     276:</span> <span class="k">/**</span>
<a name="277" /><span class="Maybe">     277:</span> <span class="k"> * list_first_or_null_rcu - get the first element from a list</span>
<a name="278" /><span class="Maybe">     278:</span> <span class="k"> * @ptr:        the list head to take the element from.</span>
<a name="279" /><span class="Maybe">     279:</span> <span class="k"> * @type:       the type of the struct this is embedded in.</span>
<a name="280" /><span class="Maybe">     280:</span> <span class="k"> * @member:     the name of the list_struct within the struct.</span>
<a name="281" /><span class="Maybe">     281:</span> <span class="k"> *</span>
<a name="282" /><span class="Maybe">     282:</span> <span class="k"> * Note that if the list is empty, it returns NULL.</span>
<a name="283" /><span class="Maybe">     283:</span> <span class="k"> *</span>
<a name="284" /><span class="Maybe">     284:</span> <span class="k"> * This primitive may safely run concurrently with the _rcu list-mutation</span>
<a name="285" /><span class="Maybe">     285:</span> <span class="k"> * primitives such as list_add_rcu() as long as it&apos;s guarded by rcu_read_lock().</span>
<a name="286" /><span class="Maybe">     286:</span> <span class="k"> */</span>
<a name="287" /><span class="Maybe">     287:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_bGlzdF9maXJzdF9vcl9udWxsX3JjdV8w"><span class="b">list_first_or_null_rcu</span></a><span class="f">(</span><span class="b">ptr</span><span class="f">,</span> <span class="b">type</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span> \
<a name="288" /><span class="Maybe">     288:</span>     <span class="f">(</span><span class="f">{</span><span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">__ptr</span> <span class="f">=</span> <span class="f">(</span><span class="b">ptr</span><span class="f">)</span><span class="f">;</span> \
<a name="289" /><span class="Maybe">     289:</span>       <span class="m">struct</span> <span class="b">list_head</span> <span class="f">*</span><span class="b">__next</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_QUNDRVNTX09OQ0VfMA__"><span class="b">ACCESS_ONCE</span></a><span class="f">(</span><span class="b">__ptr</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">)</span><span class="f">;</span> \
<a name="290" /><span class="Maybe">     290:</span>       <a href="cpu.c_macros_ref.html#_bGlrZWx5XzA_"><span class="b">likely</span></a><span class="f">(</span><span class="b">__ptr</span> <span class="f">!=</span> <span class="b">__next</span><span class="f">)</span> <span class="f">?</span> \
<a name="291" /><span class="Maybe">     291:</span>         <a href="cpu.c_macros_ref.html#_bGlzdF9lbnRyeV9yY3VfMA__"><span class="b">list_entry_rcu</span></a><span class="f">(</span><span class="b">__next</span><span class="f">,</span> <span class="b">type</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span> <span class="f">:</span> <a href="cpu.c_macros_ref.html#_TlVMTF8w"><span class="b">NULL</span></a><span class="f">;</span> \
<a name="292" /><span class="Maybe">     292:</span>     <span class="f">}</span><span class="f">)</span>
<a name="293" /><span class="Maybe">     293:</span> 
<a name="294" /><span class="Maybe">     294:</span> <span class="k">/**</span>
<a name="295" /><span class="Maybe">     295:</span> <span class="k"> * list_for_each_entry_rcu    -    iterate over rcu list of given type</span>
<a name="296" /><span class="Maybe">     296:</span> <span class="k"> * @pos:    the type * to use as a loop cursor.</span>
<a name="297" /><span class="Maybe">     297:</span> <span class="k"> * @head:    the head for your list.</span>
<a name="298" /><span class="Maybe">     298:</span> <span class="k"> * @member:    the name of the list_struct within the struct.</span>
<a name="299" /><span class="Maybe">     299:</span> <span class="k"> *</span>
<a name="300" /><span class="Maybe">     300:</span> <span class="k"> * This list-traversal primitive may safely run concurrently with</span>
<a name="301" /><span class="Maybe">     301:</span> <span class="k"> * the _rcu list-mutation primitives such as list_add_rcu()</span>
<a name="302" /><span class="Maybe">     302:</span> <span class="k"> * as long as the traversal is guarded by rcu_read_lock().</span>
<a name="303" /><span class="Maybe">     303:</span> <span class="k"> */</span>
<a name="304" /><span class="Maybe">     304:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_bGlzdF9mb3JfZWFjaF9lbnRyeV9yY3VfMA__"><span class="b">list_for_each_entry_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">head</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span> \
<a name="305" /><span class="Maybe">     305:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_bGlzdF9lbnRyeV9yY3VfMA__"><span class="b">list_entry_rcu</span></a><span class="f">(</span><span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">,</span> <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="b">pos</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span> \
<a name="306" /><span class="Maybe">     306:</span>         <span class="f">&amp;</span><span class="b">pos</span><span class="f">-&gt;</span><span class="b">member</span> <span class="f">!=</span> <span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">;</span> \
<a name="307" /><span class="Maybe">     307:</span>         <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_bGlzdF9lbnRyeV9yY3VfMA__"><span class="b">list_entry_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">.</span><span class="b">next</span><span class="f">,</span> <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="b">pos</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">)</span>
<a name="308" /><span class="Maybe">     308:</span> 
<a name="309" /><span class="Maybe">     309:</span> <span class="k">/**</span>
<a name="310" /><span class="Maybe">     310:</span> <span class="k"> * list_for_each_entry_continue_rcu - continue iteration over list of given type</span>
<a name="311" /><span class="Maybe">     311:</span> <span class="k"> * @pos:    the type * to use as a loop cursor.</span>
<a name="312" /><span class="Maybe">     312:</span> <span class="k"> * @head:    the head for your list.</span>
<a name="313" /><span class="Maybe">     313:</span> <span class="k"> * @member:    the name of the list_struct within the struct.</span>
<a name="314" /><span class="Maybe">     314:</span> <span class="k"> *</span>
<a name="315" /><span class="Maybe">     315:</span> <span class="k"> * Continue to iterate over list of given type, continuing after</span>
<a name="316" /><span class="Maybe">     316:</span> <span class="k"> * the current position.</span>
<a name="317" /><span class="Maybe">     317:</span> <span class="k"> */</span>
<a name="318" /><span class="Maybe">     318:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_bGlzdF9mb3JfZWFjaF9lbnRyeV9jb250aW51ZV9yY3VfMA__"><span class="b">list_for_each_entry_continue_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">head</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span>         \
<a name="319" /><span class="Maybe">     319:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_bGlzdF9lbnRyeV9yY3VfMA__"><span class="b">list_entry_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">.</span><span class="b">next</span><span class="f">,</span> <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="b">pos</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span> \
<a name="320" /><span class="Maybe">     320:</span>          <span class="f">&amp;</span><span class="b">pos</span><span class="f">-&gt;</span><span class="b">member</span> <span class="f">!=</span> <span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">;</span>    \
<a name="321" /><span class="Maybe">     321:</span>          <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_bGlzdF9lbnRyeV9yY3VfMA__"><span class="b">list_entry_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">.</span><span class="b">next</span><span class="f">,</span> <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="b">pos</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">)</span>
<a name="322" /><span class="Maybe">     322:</span> 
<a name="323" /><span class="Maybe">     323:</span> <span class="k">/**</span>
<a name="324" /><span class="Maybe">     324:</span> <span class="k"> * hlist_del_rcu - deletes entry from hash list without re-initialization</span>
<a name="325" /><span class="Maybe">     325:</span> <span class="k"> * @n: the element to delete from the hash list.</span>
<a name="326" /><span class="Maybe">     326:</span> <span class="k"> *</span>
<a name="327" /><span class="Maybe">     327:</span> <span class="k"> * Note: list_unhashed() on entry does not return true after this,</span>
<a name="328" /><span class="Maybe">     328:</span> <span class="k"> * the entry is in an undefined state. It is useful for RCU based</span>
<a name="329" /><span class="Maybe">     329:</span> <span class="k"> * lockfree traversal.</span>
<a name="330" /><span class="Maybe">     330:</span> <span class="k"> *</span>
<a name="331" /><span class="Maybe">     331:</span> <span class="k"> * In particular, it means that we can not poison the forward</span>
<a name="332" /><span class="Maybe">     332:</span> <span class="k"> * pointers that may still be used for walking the hash list.</span>
<a name="333" /><span class="Maybe">     333:</span> <span class="k"> *</span>
<a name="334" /><span class="Maybe">     334:</span> <span class="k"> * The caller must take whatever precautions are necessary</span>
<a name="335" /><span class="Maybe">     335:</span> <span class="k"> * (such as holding appropriate locks) to avoid racing</span>
<a name="336" /><span class="Maybe">     336:</span> <span class="k"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<a name="337" /><span class="Maybe">     337:</span> <span class="k"> * or hlist_del_rcu(), running on this same list.</span>
<a name="338" /><span class="Maybe">     338:</span> <span class="k"> * However, it is perfectly legal to run concurrently with</span>
<a name="339" /><span class="Maybe">     339:</span> <span class="k"> * the _rcu list-traversal primitives, such as</span>
<a name="340" /><span class="Maybe">     340:</span> <span class="k"> * hlist_for_each_entry().</span>
<a name="341" /><span class="Maybe">     341:</span> <span class="k"> */</span>
<a name="342" /><span class="Maybe">     342:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">hlist_del_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">n</span><span class="f">)</span>
<a name="343" /><span class="Maybe">     343:</span> <span class="f">{</span>
<a name="344" /><span class="Maybe">     344:</span>     <span class="b">__hlist_del</span><span class="f">(</span><span class="b">n</span><span class="f">)</span><span class="f">;</span>
<a name="345" /><span class="Maybe">     345:</span>     <span class="b">n</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_TElTVF9QT0lTT04yXzA_"><span class="b">LIST_POISON2</span></a><span class="f">;</span>
<a name="346" /><span class="Maybe">     346:</span> <span class="f">}</span>
<a name="347" /><span class="Maybe">     347:</span> 
<a name="348" /><span class="Maybe">     348:</span> <span class="k">/**</span>
<a name="349" /><span class="Maybe">     349:</span> <span class="k"> * hlist_replace_rcu - replace old entry by new one</span>
<a name="350" /><span class="Maybe">     350:</span> <span class="k"> * @old : the element to be replaced</span>
<a name="351" /><span class="Maybe">     351:</span> <span class="k"> * @new : the new element to insert</span>
<a name="352" /><span class="Maybe">     352:</span> <span class="k"> *</span>
<a name="353" /><span class="Maybe">     353:</span> <span class="k"> * The @old entry will be replaced with the @new entry atomically.</span>
<a name="354" /><span class="Maybe">     354:</span> <span class="k"> */</span>
<a name="355" /><span class="Maybe">     355:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">hlist_replace_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">old</span><span class="f">,</span>
<a name="356" /><span class="Maybe">     356:</span>                     <span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="m">new</span><span class="f">)</span>
<a name="357" /><span class="Maybe">     357:</span> <span class="f">{</span>
<a name="358" /><span class="Maybe">     358:</span>     <span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">next</span> <span class="f">=</span> <span class="b">old</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="359" /><span class="Maybe">     359:</span> 
<a name="360" /><span class="Maybe">     360:</span>     <span class="m">new</span><span class="f">-&gt;</span><span class="b">next</span> <span class="f">=</span> <span class="b">next</span><span class="f">;</span>
<a name="361" /><span class="Maybe">     361:</span>     <span class="m">new</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="b">old</span><span class="f">-&gt;</span><span class="b">pprev</span><span class="f">;</span>
<a name="362" /><span class="Maybe">     362:</span>     <a href="cpu.c_macros_ref.html#_cmN1X2Fzc2lnbl9wb2ludGVyXzA_"><span class="b">rcu_assign_pointer</span></a><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <span class="f">*</span><span class="f">*</span><span class="f">)</span><span class="m">new</span><span class="f">-&gt;</span><span class="b">pprev</span><span class="f">,</span> <span class="m">new</span><span class="f">)</span><span class="f">;</span>
<a name="363" /><span class="Maybe">     363:</span>     <span class="m">if</span> <span class="f">(</span><span class="b">next</span><span class="f">)</span>
<a name="364" /><span class="Maybe">     364:</span>         <span class="m">new</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="f">&amp;</span><span class="m">new</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="365" /><span class="Maybe">     365:</span>     <span class="b">old</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_TElTVF9QT0lTT04yXzA_"><span class="b">LIST_POISON2</span></a><span class="f">;</span>
<a name="366" /><span class="Maybe">     366:</span> <span class="f">}</span>
<a name="367" /><span class="Maybe">     367:</span> 
<a name="368" /><span class="Maybe">     368:</span> <span class="k">/*</span>
<a name="369" /><span class="Maybe">     369:</span> <span class="k"> * return the first or the next element in an RCU protected hlist</span>
<a name="370" /><span class="Maybe">     370:</span> <span class="k"> */</span>
<a name="371" /><span class="Maybe">     371:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_aGxpc3RfZmlyc3RfcmN1XzA_"><span class="b">hlist_first_rcu</span></a><span class="f">(</span><span class="b">head</span><span class="f">)</span>    <span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <span class="f">*</span><span class="f">*</span><span class="f">)</span><span class="f">(</span><span class="f">&amp;</span><span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">first</span><span class="f">)</span><span class="f">)</span><span class="f">)</span>
<a name="372" /><span class="Maybe">     372:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_aGxpc3RfbmV4dF9yY3VfMA__"><span class="b">hlist_next_rcu</span></a><span class="f">(</span><span class="b">node</span><span class="f">)</span>    <span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <span class="f">*</span><span class="f">*</span><span class="f">)</span><span class="f">(</span><span class="f">&amp;</span><span class="f">(</span><span class="b">node</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">)</span><span class="f">)</span><span class="f">)</span>
<a name="373" /><span class="Maybe">     373:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_aGxpc3RfcHByZXZfcmN1XzA_"><span class="b">hlist_pprev_rcu</span></a><span class="f">(</span><span class="b">node</span><span class="f">)</span>    <span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <span class="f">*</span><span class="f">*</span><span class="f">)</span><span class="f">(</span><span class="f">(</span><span class="b">node</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">pprev</span><span class="f">)</span><span class="f">)</span><span class="f">)</span>
<a name="374" /><span class="Maybe">     374:</span> 
<a name="375" /><span class="Maybe">     375:</span> <span class="k">/**</span>
<a name="376" /><span class="Maybe">     376:</span> <span class="k"> * hlist_add_head_rcu</span>
<a name="377" /><span class="Maybe">     377:</span> <span class="k"> * @n: the element to add to the hash list.</span>
<a name="378" /><span class="Maybe">     378:</span> <span class="k"> * @h: the list to add to.</span>
<a name="379" /><span class="Maybe">     379:</span> <span class="k"> *</span>
<a name="380" /><span class="Maybe">     380:</span> <span class="k"> * Description:</span>
<a name="381" /><span class="Maybe">     381:</span> <span class="k"> * Adds the specified element to the specified hlist,</span>
<a name="382" /><span class="Maybe">     382:</span> <span class="k"> * while permitting racing traversals.</span>
<a name="383" /><span class="Maybe">     383:</span> <span class="k"> *</span>
<a name="384" /><span class="Maybe">     384:</span> <span class="k"> * The caller must take whatever precautions are necessary</span>
<a name="385" /><span class="Maybe">     385:</span> <span class="k"> * (such as holding appropriate locks) to avoid racing</span>
<a name="386" /><span class="Maybe">     386:</span> <span class="k"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<a name="387" /><span class="Maybe">     387:</span> <span class="k"> * or hlist_del_rcu(), running on this same list.</span>
<a name="388" /><span class="Maybe">     388:</span> <span class="k"> * However, it is perfectly legal to run concurrently with</span>
<a name="389" /><span class="Maybe">     389:</span> <span class="k"> * the _rcu list-traversal primitives, such as</span>
<a name="390" /><span class="Maybe">     390:</span> <span class="k"> * hlist_for_each_entry_rcu(), used to prevent memory-consistency</span>
<a name="391" /><span class="Maybe">     391:</span> <span class="k"> * problems on Alpha CPUs.  Regardless of the type of CPU, the</span>
<a name="392" /><span class="Maybe">     392:</span> <span class="k"> * list-traversal primitive must be guarded by rcu_read_lock().</span>
<a name="393" /><span class="Maybe">     393:</span> <span class="k"> */</span>
<a name="394" /><span class="Maybe">     394:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">hlist_add_head_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">n</span><span class="f">,</span>
<a name="395" /><span class="Maybe">     395:</span>                     <span class="m">struct</span> <span class="b">hlist_head</span> <span class="f">*</span><span class="b">h</span><span class="f">)</span>
<a name="396" /><span class="Maybe">     396:</span> <span class="f">{</span>
<a name="397" /><span class="Maybe">     397:</span>     <span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">first</span> <span class="f">=</span> <span class="b">h</span><span class="f">-&gt;</span><span class="b">first</span><span class="f">;</span>
<a name="398" /><span class="Maybe">     398:</span> 
<a name="399" /><span class="Maybe">     399:</span>     <span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span> <span class="f">=</span> <span class="b">first</span><span class="f">;</span>
<a name="400" /><span class="Maybe">     400:</span>     <span class="b">n</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="f">&amp;</span><span class="b">h</span><span class="f">-&gt;</span><span class="b">first</span><span class="f">;</span>
<a name="401" /><span class="Maybe">     401:</span>     <a href="cpu.c_macros_ref.html#_cmN1X2Fzc2lnbl9wb2ludGVyXzA_"><span class="b">rcu_assign_pointer</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfZmlyc3RfcmN1XzA_"><span class="b">hlist_first_rcu</span></a><span class="f">(</span><span class="b">h</span><span class="f">)</span><span class="f">,</span> <span class="b">n</span><span class="f">)</span><span class="f">;</span>
<a name="402" /><span class="Maybe">     402:</span>     <span class="m">if</span> <span class="f">(</span><span class="b">first</span><span class="f">)</span>
<a name="403" /><span class="Maybe">     403:</span>         <span class="b">first</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="f">&amp;</span><span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="404" /><span class="Maybe">     404:</span> <span class="f">}</span>
<a name="405" /><span class="Maybe">     405:</span> 
<a name="406" /><span class="Maybe">     406:</span> <span class="k">/**</span>
<a name="407" /><span class="Maybe">     407:</span> <span class="k"> * hlist_add_before_rcu</span>
<a name="408" /><span class="Maybe">     408:</span> <span class="k"> * @n: the new element to add to the hash list.</span>
<a name="409" /><span class="Maybe">     409:</span> <span class="k"> * @next: the existing element to add the new element before.</span>
<a name="410" /><span class="Maybe">     410:</span> <span class="k"> *</span>
<a name="411" /><span class="Maybe">     411:</span> <span class="k"> * Description:</span>
<a name="412" /><span class="Maybe">     412:</span> <span class="k"> * Adds the specified element to the specified hlist</span>
<a name="413" /><span class="Maybe">     413:</span> <span class="k"> * before the specified node while permitting racing traversals.</span>
<a name="414" /><span class="Maybe">     414:</span> <span class="k"> *</span>
<a name="415" /><span class="Maybe">     415:</span> <span class="k"> * The caller must take whatever precautions are necessary</span>
<a name="416" /><span class="Maybe">     416:</span> <span class="k"> * (such as holding appropriate locks) to avoid racing</span>
<a name="417" /><span class="Maybe">     417:</span> <span class="k"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<a name="418" /><span class="Maybe">     418:</span> <span class="k"> * or hlist_del_rcu(), running on this same list.</span>
<a name="419" /><span class="Maybe">     419:</span> <span class="k"> * However, it is perfectly legal to run concurrently with</span>
<a name="420" /><span class="Maybe">     420:</span> <span class="k"> * the _rcu list-traversal primitives, such as</span>
<a name="421" /><span class="Maybe">     421:</span> <span class="k"> * hlist_for_each_entry_rcu(), used to prevent memory-consistency</span>
<a name="422" /><span class="Maybe">     422:</span> <span class="k"> * problems on Alpha CPUs.</span>
<a name="423" /><span class="Maybe">     423:</span> <span class="k"> */</span>
<a name="424" /><span class="Maybe">     424:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">hlist_add_before_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">n</span><span class="f">,</span>
<a name="425" /><span class="Maybe">     425:</span>                     <span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">next</span><span class="f">)</span>
<a name="426" /><span class="Maybe">     426:</span> <span class="f">{</span>
<a name="427" /><span class="Maybe">     427:</span>     <span class="b">n</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="b">next</span><span class="f">-&gt;</span><span class="b">pprev</span><span class="f">;</span>
<a name="428" /><span class="Maybe">     428:</span>     <span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span> <span class="f">=</span> <span class="b">next</span><span class="f">;</span>
<a name="429" /><span class="Maybe">     429:</span>     <a href="cpu.c_macros_ref.html#_cmN1X2Fzc2lnbl9wb2ludGVyXzA_"><span class="b">rcu_assign_pointer</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfcHByZXZfcmN1XzA_"><span class="b">hlist_pprev_rcu</span></a><span class="f">(</span><span class="b">n</span><span class="f">)</span><span class="f">,</span> <span class="b">n</span><span class="f">)</span><span class="f">;</span>
<a name="430" /><span class="Maybe">     430:</span>     <span class="b">next</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="f">&amp;</span><span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="431" /><span class="Maybe">     431:</span> <span class="f">}</span>
<a name="432" /><span class="Maybe">     432:</span> 
<a name="433" /><span class="Maybe">     433:</span> <span class="k">/**</span>
<a name="434" /><span class="Maybe">     434:</span> <span class="k"> * hlist_add_after_rcu</span>
<a name="435" /><span class="Maybe">     435:</span> <span class="k"> * @prev: the existing element to add the new element after.</span>
<a name="436" /><span class="Maybe">     436:</span> <span class="k"> * @n: the new element to add to the hash list.</span>
<a name="437" /><span class="Maybe">     437:</span> <span class="k"> *</span>
<a name="438" /><span class="Maybe">     438:</span> <span class="k"> * Description:</span>
<a name="439" /><span class="Maybe">     439:</span> <span class="k"> * Adds the specified element to the specified hlist</span>
<a name="440" /><span class="Maybe">     440:</span> <span class="k"> * after the specified node while permitting racing traversals.</span>
<a name="441" /><span class="Maybe">     441:</span> <span class="k"> *</span>
<a name="442" /><span class="Maybe">     442:</span> <span class="k"> * The caller must take whatever precautions are necessary</span>
<a name="443" /><span class="Maybe">     443:</span> <span class="k"> * (such as holding appropriate locks) to avoid racing</span>
<a name="444" /><span class="Maybe">     444:</span> <span class="k"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<a name="445" /><span class="Maybe">     445:</span> <span class="k"> * or hlist_del_rcu(), running on this same list.</span>
<a name="446" /><span class="Maybe">     446:</span> <span class="k"> * However, it is perfectly legal to run concurrently with</span>
<a name="447" /><span class="Maybe">     447:</span> <span class="k"> * the _rcu list-traversal primitives, such as</span>
<a name="448" /><span class="Maybe">     448:</span> <span class="k"> * hlist_for_each_entry_rcu(), used to prevent memory-consistency</span>
<a name="449" /><span class="Maybe">     449:</span> <span class="k"> * problems on Alpha CPUs.</span>
<a name="450" /><span class="Maybe">     450:</span> <span class="k"> */</span>
<a name="451" /><span class="Maybe">     451:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">hlist_add_after_rcu</span><span class="f">(</span><span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">prev</span><span class="f">,</span>
<a name="452" /><span class="Maybe">     452:</span>                        <span class="m">struct</span> <span class="b">hlist_node</span> <span class="f">*</span><span class="b">n</span><span class="f">)</span>
<a name="453" /><span class="Maybe">     453:</span> <span class="f">{</span>
<a name="454" /><span class="Maybe">     454:</span>     <span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span> <span class="f">=</span> <span class="b">prev</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="455" /><span class="Maybe">     455:</span>     <span class="b">n</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="f">&amp;</span><span class="b">prev</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="456" /><span class="Maybe">     456:</span>     <a href="cpu.c_macros_ref.html#_cmN1X2Fzc2lnbl9wb2ludGVyXzA_"><span class="b">rcu_assign_pointer</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfbmV4dF9yY3VfMA__"><span class="b">hlist_next_rcu</span></a><span class="f">(</span><span class="b">prev</span><span class="f">)</span><span class="f">,</span> <span class="b">n</span><span class="f">)</span><span class="f">;</span>
<a name="457" /><span class="Maybe">     457:</span>     <span class="m">if</span> <span class="f">(</span><span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">)</span>
<a name="458" /><span class="Maybe">     458:</span>         <span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">-&gt;</span><span class="b">pprev</span> <span class="f">=</span> <span class="f">&amp;</span><span class="b">n</span><span class="f">-&gt;</span><span class="b">next</span><span class="f">;</span>
<a name="459" /><span class="Maybe">     459:</span> <span class="f">}</span>
<a name="460" /><span class="Maybe">     460:</span> 
<a name="461" /><span class="Maybe">     461:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_X19obGlzdF9mb3JfZWFjaF9yY3VfMA__"><span class="b">__hlist_for_each_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">head</span><span class="f">)</span>                \
<a name="462" /><span class="Maybe">     462:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlXzA_"><span class="b">rcu_dereference</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfZmlyc3RfcmN1XzA_"><span class="b">hlist_first_rcu</span></a><span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">)</span><span class="f">;</span>    \
<a name="463" /><span class="Maybe">     463:</span>          <span class="b">pos</span><span class="f">;</span>                        \
<a name="464" /><span class="Maybe">     464:</span>          <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlXzA_"><span class="b">rcu_dereference</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfbmV4dF9yY3VfMA__"><span class="b">hlist_next_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">)</span>
<a name="465" /><span class="Maybe">     465:</span> 
<a name="466" /><span class="Maybe">     466:</span> <span class="k">/**</span>
<a name="467" /><span class="Maybe">     467:</span> <span class="k"> * hlist_for_each_entry_rcu - iterate over rcu list of given type</span>
<a name="468" /><span class="Maybe">     468:</span> <span class="k"> * @pos:    the type * to use as a loop cursor.</span>
<a name="469" /><span class="Maybe">     469:</span> <span class="k"> * @head:    the head for your list.</span>
<a name="470" /><span class="Maybe">     470:</span> <span class="k"> * @member:    the name of the hlist_node within the struct.</span>
<a name="471" /><span class="Maybe">     471:</span> <span class="k"> *</span>
<a name="472" /><span class="Maybe">     472:</span> <span class="k"> * This list-traversal primitive may safely run concurrently with</span>
<a name="473" /><span class="Maybe">     473:</span> <span class="k"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<a name="474" /><span class="Maybe">     474:</span> <span class="k"> * as long as the traversal is guarded by rcu_read_lock().</span>
<a name="475" /><span class="Maybe">     475:</span> <span class="k"> */</span>
<a name="476" /><span class="Maybe">     476:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZm9yX2VhY2hfZW50cnlfcmN1XzA_"><span class="b">hlist_for_each_entry_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">head</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span>            \
<a name="477" /><span class="Maybe">     477:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a> <span class="f">(</span><a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlX3Jhd18w"><span class="b">rcu_dereference_raw</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfZmlyc3RfcmN1XzA_"><span class="b">hlist_first_rcu</span></a><span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">)</span><span class="f">,\
</span>            <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span>            \
<a name="479" /><span class="Maybe">     479:</span>         <span class="b">pos</span><span class="f">;</span>                            \
<a name="480" /><span class="Maybe">     480:</span>         <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlX3Jhd18w"><span class="b">rcu_dereference_raw</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfbmV4dF9yY3VfMA__"><span class="b">hlist_next_rcu</span></a><span class="f">(\
</span>            <span class="f">&amp;</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">)</span>
<a name="482" /><span class="Maybe">     482:</span> 
<a name="483" /><span class="Maybe">     483:</span> <span class="k">/**</span>
<a name="484" /><span class="Maybe">     484:</span> <span class="k"> * hlist_for_each_entry_rcu_notrace - iterate over rcu list of given type (for tracing)</span>
<a name="485" /><span class="Maybe">     485:</span> <span class="k"> * @pos:    the type * to use as a loop cursor.</span>
<a name="486" /><span class="Maybe">     486:</span> <span class="k"> * @head:    the head for your list.</span>
<a name="487" /><span class="Maybe">     487:</span> <span class="k"> * @member:    the name of the hlist_node within the struct.</span>
<a name="488" /><span class="Maybe">     488:</span> <span class="k"> *</span>
<a name="489" /><span class="Maybe">     489:</span> <span class="k"> * This list-traversal primitive may safely run concurrently with</span>
<a name="490" /><span class="Maybe">     490:</span> <span class="k"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<a name="491" /><span class="Maybe">     491:</span> <span class="k"> * as long as the traversal is guarded by rcu_read_lock().</span>
<a name="492" /><span class="Maybe">     492:</span> <span class="k"> *</span>
<a name="493" /><span class="Maybe">     493:</span> <span class="k"> * This is the same as hlist_for_each_entry_rcu() except that it does</span>
<a name="494" /><span class="Maybe">     494:</span> <span class="k"> * not do any RCU debugging or tracing.</span>
<a name="495" /><span class="Maybe">     495:</span> <span class="k"> */</span>
<a name="496" /><span class="Maybe">     496:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZm9yX2VhY2hfZW50cnlfcmN1X25vdHJhY2VfMA__"><span class="b">hlist_for_each_entry_rcu_notrace</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">head</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span>            \
<a name="497" /><span class="Maybe">     497:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a> <span class="f">(</span><a href="cpu.c_macros_noref.html#_cmN1X2RlcmVmZXJlbmNlX3Jhd19ub3RyYWNlXzA_"><span class="b">rcu_dereference_raw_notrace</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfZmlyc3RfcmN1XzA_"><span class="b">hlist_first_rcu</span></a><span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">)</span><span class="f">,\
</span>            <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span>            \
<a name="499" /><span class="Maybe">     499:</span>         <span class="b">pos</span><span class="f">;</span>                            \
<a name="500" /><span class="Maybe">     500:</span>         <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_noref.html#_cmN1X2RlcmVmZXJlbmNlX3Jhd19ub3RyYWNlXzA_"><span class="b">rcu_dereference_raw_notrace</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfbmV4dF9yY3VfMA__"><span class="b">hlist_next_rcu</span></a><span class="f">(\
</span>            <span class="f">&amp;</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">)</span>
<a name="502" /><span class="Maybe">     502:</span> 
<a name="503" /><span class="Maybe">     503:</span> <span class="k">/**</span>
<a name="504" /><span class="Maybe">     504:</span> <span class="k"> * hlist_for_each_entry_rcu_bh - iterate over rcu list of given type</span>
<a name="505" /><span class="Maybe">     505:</span> <span class="k"> * @pos:    the type * to use as a loop cursor.</span>
<a name="506" /><span class="Maybe">     506:</span> <span class="k"> * @head:    the head for your list.</span>
<a name="507" /><span class="Maybe">     507:</span> <span class="k"> * @member:    the name of the hlist_node within the struct.</span>
<a name="508" /><span class="Maybe">     508:</span> <span class="k"> *</span>
<a name="509" /><span class="Maybe">     509:</span> <span class="k"> * This list-traversal primitive may safely run concurrently with</span>
<a name="510" /><span class="Maybe">     510:</span> <span class="k"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<a name="511" /><span class="Maybe">     511:</span> <span class="k"> * as long as the traversal is guarded by rcu_read_lock().</span>
<a name="512" /><span class="Maybe">     512:</span> <span class="k"> */</span>
<a name="513" /><span class="Maybe">     513:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZm9yX2VhY2hfZW50cnlfcmN1X2JoXzA_"><span class="b">hlist_for_each_entry_rcu_bh</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">head</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span>            \
<a name="514" /><span class="Maybe">     514:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_noref.html#_cmN1X2RlcmVmZXJlbmNlX2JoXzA_"><span class="b">rcu_dereference_bh</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfZmlyc3RfcmN1XzA_"><span class="b">hlist_first_rcu</span></a><span class="f">(</span><span class="b">head</span><span class="f">)</span><span class="f">)</span><span class="f">,\
</span>            <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span>            \
<a name="516" /><span class="Maybe">     516:</span>         <span class="b">pos</span><span class="f">;</span>                            \
<a name="517" /><span class="Maybe">     517:</span>         <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_noref.html#_cmN1X2RlcmVmZXJlbmNlX2JoXzA_"><span class="b">rcu_dereference_bh</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_aGxpc3RfbmV4dF9yY3VfMA__"><span class="b">hlist_next_rcu</span></a><span class="f">(\
</span>            <span class="f">&amp;</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">)</span>
<a name="519" /><span class="Maybe">     519:</span> 
<a name="520" /><span class="Maybe">     520:</span> <span class="k">/**</span>
<a name="521" /><span class="Maybe">     521:</span> <span class="k"> * hlist_for_each_entry_continue_rcu - iterate over a hlist continuing after current point</span>
<a name="522" /><span class="Maybe">     522:</span> <span class="k"> * @pos:    the type * to use as a loop cursor.</span>
<a name="523" /><span class="Maybe">     523:</span> <span class="k"> * @member:    the name of the hlist_node within the struct.</span>
<a name="524" /><span class="Maybe">     524:</span> <span class="k"> */</span>
<a name="525" /><span class="Maybe">     525:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZm9yX2VhY2hfZW50cnlfY29udGludWVfcmN1XzA_"><span class="b">hlist_for_each_entry_continue_rcu</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span>            \
<a name="526" /><span class="Maybe">     526:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlXzA_"><span class="b">rcu_dereference</span></a><span class="f">(</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">.</span><span class="b">next</span><span class="f">)</span><span class="f">,\
</span>            <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span>            \
<a name="528" /><span class="Maybe">     528:</span>          <span class="b">pos</span><span class="f">;</span>                            \
<a name="529" /><span class="Maybe">     529:</span>          <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlXzA_"><span class="b">rcu_dereference</span></a><span class="f">(</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">.</span><span class="b">next</span><span class="f">)</span><span class="f">,\
</span>            <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">)</span>
<a name="531" /><span class="Maybe">     531:</span> 
<a name="532" /><span class="Maybe">     532:</span> <span class="k">/**</span>
<a name="533" /><span class="Maybe">     533:</span> <span class="k"> * hlist_for_each_entry_continue_rcu_bh - iterate over a hlist continuing after current point</span>
<a name="534" /><span class="Maybe">     534:</span> <span class="k"> * @pos:    the type * to use as a loop cursor.</span>
<a name="535" /><span class="Maybe">     535:</span> <span class="k"> * @member:    the name of the hlist_node within the struct.</span>
<a name="536" /><span class="Maybe">     536:</span> <span class="k"> */</span>
<a name="537" /><span class="Maybe">     537:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZm9yX2VhY2hfZW50cnlfY29udGludWVfcmN1X2JoXzA_"><span class="b">hlist_for_each_entry_continue_rcu_bh</span></a><span class="f">(</span><span class="b">pos</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span>        \
<a name="538" /><span class="Maybe">     538:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_noref.html#_cmN1X2RlcmVmZXJlbmNlX2JoXzA_"><span class="b">rcu_dereference_bh</span></a><span class="f">(</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">.</span><span class="b">next</span><span class="f">)</span><span class="f">,\
</span>            <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">;</span>            \
<a name="540" /><span class="Maybe">     540:</span>          <span class="b">pos</span><span class="f">;</span>                            \
<a name="541" /><span class="Maybe">     541:</span>          <span class="b">pos</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_aGxpc3RfZW50cnlfc2FmZV8w"><span class="b">hlist_entry_safe</span></a><span class="f">(</span><a href="cpu.c_macros_noref.html#_cmN1X2RlcmVmZXJlbmNlX2JoXzA_"><span class="b">rcu_dereference_bh</span></a><span class="f">(</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">-&gt;</span><span class="b">member</span><span class="f">.</span><span class="b">next</span><span class="f">)</span><span class="f">,\
</span>            <span class="b">typeof</span><span class="f">(</span><span class="f">*</span><span class="f">(</span><span class="b">pos</span><span class="f">)</span><span class="f">)</span><span class="f">,</span> <span class="b">member</span><span class="f">)</span><span class="f">)</span>
<a name="543" /><span class="Maybe">     543:</span> 
<a name="544" /><span class="Maybe">     544:</span> 
<a name="545" /><span class="Maybe">     545:</span> <span class="f">#</span><span class="n">endif</span>    <span class="k">/* __KERNEL__ */</span>
<a name="546" /><span class="True">     546:</span> <span class="f">#</span><span class="n">endif</span>
<a name="547" /><span class="True">     547:</span> </pre>
  </body>
</html>
