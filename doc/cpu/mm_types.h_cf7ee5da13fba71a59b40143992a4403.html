<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link href="cpip.css" rel="stylesheet" type="text/css" />
    <title>File: /Users/paulross/dev/linux/linux-3.13/include/linux/mm_types.h</title>
  </head>
  <body>
    <h1>File: /Users/paulross/dev/linux/linux-3.13/include/linux/mm_types.h</h1>
    <p>Green shading in the line number column
means the source is part of the translation unit, red means it is conditionally excluded.
Highlighted line numbers link to the translation unit page. Highlighted macros link to
the macro page.</p>
    <pre><a name="1" /><span class="Maybe">       1:</span> <span class="f">#</span><span class="n">ifndef</span> <a href="cpu.c_macros_ref.html#_X0xJTlVYX01NX1RZUEVTX0hfMA__"><span class="b">_LINUX_MM_TYPES_H</span></a>
<a name="2" /><span class="Maybe">       2:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_X0xJTlVYX01NX1RZUEVTX0hfMA__"><span class="b">_LINUX_MM_TYPES_H</span></a>
<a name="3" /><span class="Maybe">       3:</span> 
<a name="4" /><span class="Maybe">       4:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">auxvec</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="5" /><span class="Maybe">       5:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">types</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="6" /><span class="Maybe">       6:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">threads</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="7" /><span class="Maybe">       7:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">list</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="8" /><span class="Maybe">       8:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">spinlock</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="9" /><span class="Maybe">       9:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">rbtree</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="10" /><span class="Maybe">      10:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">rwsem</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="11" /><span class="Maybe">      11:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">completion</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="12" /><span class="Maybe">      12:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">cpumask</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="13" /><span class="Maybe">      13:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">page</span><span class="f">-</span><span class="b">debug</span><span class="f">-</span><span class="b">flags</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="14" /><span class="Maybe">      14:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">uprobes</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="15" /><span class="Maybe">      15:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">page</span><span class="f">-</span><span class="b">flags</span><span class="f">-</span><span class="b">layout</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="16" /><span class="Maybe">      16:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="m">asm</span><span class="f">/</span><span class="b">page</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="17" /><span class="Maybe">      17:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="m">asm</span><span class="f">/</span><span class="b">mmu</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="18" /><span class="Maybe">      18:</span> 
<a name="19" /><span class="False">      19:</span> <span class="f">#</span><span class="n">ifndef</span> <a href="cpu.c_macros_ref.html#_QVRfVkVDVE9SX1NJWkVfQVJDSF8w"><span class="b">AT_VECTOR_SIZE_ARCH</span></a>
<a name="20" /><span class="False">      20:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_QVRfVkVDVE9SX1NJWkVfQVJDSF8w"><span class="b">AT_VECTOR_SIZE_ARCH</span></a> <span class="c">0</span>
<a name="21" /><span class="Maybe">      21:</span> <span class="f">#</span><span class="n">endif</span>
<a name="22" /><span class="Maybe">      22:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_QVRfVkVDVE9SX1NJWkVfMA__"><span class="b">AT_VECTOR_SIZE</span></a> <span class="f">(</span><span class="c">2</span><span class="f">*</span><span class="f">(</span><a href="cpu.c_macros_ref.html#_QVRfVkVDVE9SX1NJWkVfQVJDSF8w"><span class="b">AT_VECTOR_SIZE_ARCH</span></a> <span class="f">+</span> <a href="cpu.c_macros_ref.html#_QVRfVkVDVE9SX1NJWkVfQkFTRV8w"><span class="b">AT_VECTOR_SIZE_BASE</span></a> <span class="f">+</span> <span class="c">1</span><span class="f">)</span><span class="f">)</span>
<a name="23" /><span class="Maybe">      23:</span> 
<a name="24" /><span class="Maybe">      24:</span> <span class="m">struct</span> <span class="b">address_space</span><span class="f">;</span>
<a name="25" /><span class="Maybe">      25:</span> 
<a name="26" /><span class="Maybe">      26:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_VVNFX1NQTElUX1BURV9QVExPQ0tTXzA_"><span class="b">USE_SPLIT_PTE_PTLOCKS</span></a>    <span class="f">(</span><a href="cpu.c_macros_ref.html#_TlJfQ1BVU18w"><span class="b">NR_CPUS</span></a> <span class="f">&gt;=</span> <a href="cpu.c_macros_ref.html#_Q09ORklHX1NQTElUX1BUTE9DS19DUFVTXzA_"><span class="b">CONFIG_SPLIT_PTLOCK_CPUS</span></a><span class="f">)</span>
<a name="27" /><span class="Maybe">      27:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_VVNFX1NQTElUX1BNRF9QVExPQ0tTXzA_"><span class="b">USE_SPLIT_PMD_PTLOCKS</span></a>    <span class="f">(</span><a href="cpu.c_macros_ref.html#_VVNFX1NQTElUX1BURV9QVExPQ0tTXzA_"><span class="b">USE_SPLIT_PTE_PTLOCKS</span></a> <span class="f">&amp;&amp;</span> \
<a name="28" /><span class="Maybe">      28:</span>         <a href="cpu.c_macros_ref.html#_SVNfRU5BQkxFRF8w"><span class="b">IS_ENABLED</span></a><span class="f">(</span><a href="cpu.c_macros_ref.html#_Q09ORklHX0FSQ0hfRU5BQkxFX1NQTElUX1BNRF9QVExPQ0tfMA__"><span class="b">CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK</span></a><span class="f">)</span><span class="f">)</span>
<a name="29" /><span class="Maybe">      29:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_QUxMT0NfU1BMSVRfUFRMT0NLU18w"><span class="b">ALLOC_SPLIT_PTLOCKS</span></a>    <span class="f">(</span><a href="cpu.c_macros_ref.html#_U1BJTkxPQ0tfU0laRV8w"><span class="b">SPINLOCK_SIZE</span></a> <span class="f">&gt;</span> <a href="cpu.c_macros_ref.html#_QklUU19QRVJfTE9OR18w"><span class="b">BITS_PER_LONG</span></a><span class="f">/</span><span class="c">8</span><span class="f">)</span>
<a name="30" /><span class="Maybe">      30:</span> 
<a name="31" /><span class="Maybe">      31:</span> <span class="k">/*</span>
<a name="32" /><span class="Maybe">      32:</span> <span class="k"> * Each physical page in the system has a struct page associated with</span>
<a name="33" /><span class="Maybe">      33:</span> <span class="k"> * it to keep track of whatever it is we are using the page for at the</span>
<a name="34" /><span class="Maybe">      34:</span> <span class="k"> * moment. Note that we have no way to track which tasks are using</span>
<a name="35" /><span class="Maybe">      35:</span> <span class="k"> * a page, though if it is a pagecache page, rmap structures can tell us</span>
<a name="36" /><span class="Maybe">      36:</span> <span class="k"> * who is mapping it.</span>
<a name="37" /><span class="Maybe">      37:</span> <span class="k"> *</span>
<a name="38" /><span class="Maybe">      38:</span> <span class="k"> * The objects in struct page are organized in double word blocks in</span>
<a name="39" /><span class="Maybe">      39:</span> <span class="k"> * order to allows us to use atomic double word operations on portions</span>
<a name="40" /><span class="Maybe">      40:</span> <span class="k"> * of struct page. That is currently only used by slub but the arrangement</span>
<a name="41" /><span class="Maybe">      41:</span> <span class="k"> * allows the use of atomic double word operations on the flags/mapping</span>
<a name="42" /><span class="Maybe">      42:</span> <span class="k"> * and lru list pointers also.</span>
<a name="43" /><span class="Maybe">      43:</span> <span class="k"> */</span>
<a name="44" /><span class="Maybe">      44:</span> <span class="m">struct</span> <span class="b">page</span> <span class="f">{</span>
<a name="45" /><span class="Maybe">      45:</span>     <span class="k">/* First double word block */</span>
<a name="46" /><span class="Maybe">      46:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">flags</span><span class="f">;</span>        <span class="k">/* Atomic flags, some possibly</span>
<a name="47" /><span class="Maybe">      47:</span> <span class="k">                     * updated asynchronously */</span>
<a name="48" /><span class="Maybe">      48:</span>     <span class="m">union</span> <span class="f">{</span>
<a name="49" /><span class="Maybe">      49:</span>         <span class="m">struct</span> <span class="b">address_space</span> <span class="f">*</span><span class="b">mapping</span><span class="f">;</span>    <span class="k">/* If low bit clear, points to</span>
<a name="50" /><span class="Maybe">      50:</span> <span class="k">                         * inode address_space, or NULL.</span>
<a name="51" /><span class="Maybe">      51:</span> <span class="k">                         * If page mapped as anonymous</span>
<a name="52" /><span class="Maybe">      52:</span> <span class="k">                         * memory, low bit is set, and</span>
<a name="53" /><span class="Maybe">      53:</span> <span class="k">                         * it points to anon_vma object:</span>
<a name="54" /><span class="Maybe">      54:</span> <span class="k">                         * see PAGE_MAPPING_ANON below.</span>
<a name="55" /><span class="Maybe">      55:</span> <span class="k">                         */</span>
<a name="56" /><span class="Maybe">      56:</span>         <span class="m">void</span> <span class="f">*</span><span class="b">s_mem</span><span class="f">;</span>            <span class="k">/* slab first object */</span>
<a name="57" /><span class="Maybe">      57:</span>     <span class="f">}</span><span class="f">;</span>
<a name="58" /><span class="Maybe">      58:</span> 
<a name="59" /><span class="Maybe">      59:</span>     <span class="k">/* Second double word */</span>
<a name="60" /><span class="Maybe">      60:</span>     <span class="m">struct</span> <span class="f">{</span>
<a name="61" /><span class="Maybe">      61:</span>         <span class="m">union</span> <span class="f">{</span>
<a name="62" /><span class="Maybe">      62:</span>             <a href="cpu.c_macros_ref.html#_cGdvZmZfdF8w"><span class="b">pgoff_t</span></a> <span class="b">index</span><span class="f">;</span>        <span class="k">/* Our offset within mapping. */</span>
<a name="63" /><span class="Maybe">      63:</span>             <span class="m">void</span> <span class="f">*</span><span class="b">freelist</span><span class="f">;</span>        <span class="k">/* sl[aou]b first free object */</span>
<a name="64" /><span class="Maybe">      64:</span>             <span class="m">bool</span> <span class="b">pfmemalloc</span><span class="f">;</span>    <span class="k">/* If set by the page allocator,</span>
<a name="65" /><span class="Maybe">      65:</span> <span class="k">                         * ALLOC_NO_WATERMARKS was set</span>
<a name="66" /><span class="Maybe">      66:</span> <span class="k">                         * and the low watermark was not</span>
<a name="67" /><span class="Maybe">      67:</span> <span class="k">                         * met implying that the system</span>
<a name="68" /><span class="Maybe">      68:</span> <span class="k">                         * is under some pressure. The</span>
<a name="69" /><span class="Maybe">      69:</span> <span class="k">                         * caller should try ensure</span>
<a name="70" /><span class="Maybe">      70:</span> <span class="k">                         * this page is only used to</span>
<a name="71" /><span class="Maybe">      71:</span> <span class="k">                         * free other pages.</span>
<a name="72" /><span class="Maybe">      72:</span> <span class="k">                         */</span>
<a name="73" /><span class="Maybe">      73:</span>         <span class="f">}</span><span class="f">;</span>
<a name="74" /><span class="Maybe">      74:</span> 
<a name="75" /><span class="Maybe">      75:</span>         <span class="m">union</span> <span class="f">{</span>
<a name="76" /><span class="Maybe">      76:</span> <span class="f">#</span><span class="n">if</span> <span class="b">defined</span><span class="f">(</span><a href="cpu.c_macros_ref.html#_Q09ORklHX0hBVkVfQ01QWENIR19ET1VCTEVfMA__"><span class="b">CONFIG_HAVE_CMPXCHG_DOUBLE</span></a><span class="f">)</span> <span class="f">&amp;&amp;</span> \
<a name="77" /><span class="Maybe">      77:</span>     <span class="b">defined</span><span class="f">(</span><a href="cpu.c_macros_ref.html#_Q09ORklHX0hBVkVfQUxJR05FRF9TVFJVQ1RfUEFHRV8w"><span class="b">CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></a><span class="f">)</span>
<a name="78" /><span class="Maybe">      78:</span>             <span class="k">/* Used for cmpxchg_double in slub */</span>
<a name="79" /><span class="Maybe">      79:</span>             <span class="m">unsigned</span> <span class="m">long</span> <span class="b">counters</span><span class="f">;</span>
<a name="80" /><span class="False">      80:</span> <span class="f">#</span><span class="n">else</span>
<a name="81" /><span class="False">      81:</span>             <span class="k">/*</span>
<a name="82" /><span class="False">      82:</span> <span class="k">             * Keep _count separate from slub cmpxchg_double data.</span>
<a name="83" /><span class="False">      83:</span> <span class="k">             * As the rest of the double word is protected by</span>
<a name="84" /><span class="False">      84:</span> <span class="k">             * slab_lock but _count is not.</span>
<a name="85" /><span class="False">      85:</span> <span class="k">             */</span>
<a name="86" /><span class="False">      86:</span>             <span class="m">unsigned</span> <span class="b">counters</span><span class="f">;</span>
<a name="87" /><span class="Maybe">      87:</span> <span class="f">#</span><span class="n">endif</span>
<a name="88" /><span class="Maybe">      88:</span> 
<a name="89" /><span class="Maybe">      89:</span>             <span class="m">struct</span> <span class="f">{</span>
<a name="90" /><span class="Maybe">      90:</span> 
<a name="91" /><span class="Maybe">      91:</span>                 <span class="m">union</span> <span class="f">{</span>
<a name="92" /><span class="Maybe">      92:</span>                     <span class="k">/*</span>
<a name="93" /><span class="Maybe">      93:</span> <span class="k">                     * Count of ptes mapped in</span>
<a name="94" /><span class="Maybe">      94:</span> <span class="k">                     * mms, to show when page is</span>
<a name="95" /><span class="Maybe">      95:</span> <span class="k">                     * mapped &amp; limit reverse map</span>
<a name="96" /><span class="Maybe">      96:</span> <span class="k">                     * searches.</span>
<a name="97" /><span class="Maybe">      97:</span> <span class="k">                     *</span>
<a name="98" /><span class="Maybe">      98:</span> <span class="k">                     * Used also for tail pages</span>
<a name="99" /><span class="Maybe">      99:</span> <span class="k">                     * refcounting instead of</span>
<a name="100" /><span class="Maybe">     100:</span> <span class="k">                     * _count. Tail pages cannot</span>
<a name="101" /><span class="Maybe">     101:</span> <span class="k">                     * be mapped and keeping the</span>
<a name="102" /><span class="Maybe">     102:</span> <span class="k">                     * tail page _count zero at</span>
<a name="103" /><span class="Maybe">     103:</span> <span class="k">                     * all times guarantees</span>
<a name="104" /><span class="Maybe">     104:</span> <span class="k">                     * get_page_unless_zero() will</span>
<a name="105" /><span class="Maybe">     105:</span> <span class="k">                     * never succeed on tail</span>
<a name="106" /><span class="Maybe">     106:</span> <span class="k">                     * pages.</span>
<a name="107" /><span class="Maybe">     107:</span> <span class="k">                     */</span>
<a name="108" /><span class="Maybe">     108:</span>                     <span class="b">atomic_t</span> <span class="b">_mapcount</span><span class="f">;</span>
<a name="109" /><span class="Maybe">     109:</span> 
<a name="110" /><span class="Maybe">     110:</span>                     <span class="m">struct</span> <span class="f">{</span> <span class="k">/* SLUB */</span>
<a name="111" /><span class="Maybe">     111:</span>                         <span class="m">unsigned</span> <span class="b">inuse</span><span class="f">:</span><span class="c">16</span><span class="f">;</span>
<a name="112" /><span class="Maybe">     112:</span>                         <span class="m">unsigned</span> <span class="b">objects</span><span class="f">:</span><span class="c">15</span><span class="f">;</span>
<a name="113" /><span class="Maybe">     113:</span>                         <span class="m">unsigned</span> <span class="b">frozen</span><span class="f">:</span><span class="c">1</span><span class="f">;</span>
<a name="114" /><span class="Maybe">     114:</span>                     <span class="f">}</span><span class="f">;</span>
<a name="115" /><span class="Maybe">     115:</span>                     <span class="m">int</span> <span class="b">units</span><span class="f">;</span>    <span class="k">/* SLOB */</span>
<a name="116" /><span class="Maybe">     116:</span>                 <span class="f">}</span><span class="f">;</span>
<a name="117" /><span class="Maybe">     117:</span>                 <span class="b">atomic_t</span> <span class="b">_count</span><span class="f">;</span>        <span class="k">/* Usage count, see below. */</span>
<a name="118" /><span class="Maybe">     118:</span>             <span class="f">}</span><span class="f">;</span>
<a name="119" /><span class="Maybe">     119:</span>             <span class="m">unsigned</span> <span class="m">int</span> <span class="b">active</span><span class="f">;</span>    <span class="k">/* SLAB */</span>
<a name="120" /><span class="Maybe">     120:</span>         <span class="f">}</span><span class="f">;</span>
<a name="121" /><span class="Maybe">     121:</span>     <span class="f">}</span><span class="f">;</span>
<a name="122" /><span class="Maybe">     122:</span> 
<a name="123" /><span class="Maybe">     123:</span>     <span class="k">/* Third double word block */</span>
<a name="124" /><span class="Maybe">     124:</span>     <span class="m">union</span> <span class="f">{</span>
<a name="125" /><span class="Maybe">     125:</span>         <span class="m">struct</span> <span class="b">list_head</span> <span class="b">lru</span><span class="f">;</span>    <span class="k">/* Pageout list, eg. active_list</span>
<a name="126" /><span class="Maybe">     126:</span> <span class="k">                     * protected by zone-&gt;lru_lock !</span>
<a name="127" /><span class="Maybe">     127:</span> <span class="k">                     */</span>
<a name="128" /><span class="Maybe">     128:</span>         <span class="m">struct</span> <span class="f">{</span>        <span class="k">/* slub per cpu partial pages */</span>
<a name="129" /><span class="Maybe">     129:</span>             <span class="m">struct</span> <span class="b">page</span> <span class="f">*</span><span class="b">next</span><span class="f">;</span>    <span class="k">/* Next partial slab */</span>
<a name="130" /><span class="Maybe">     130:</span> <span class="f">#</span><span class="n">ifdef</span> <a href="cpu.c_macros_ref.html#_Q09ORklHXzY0QklUXzA_"><span class="b">CONFIG_64BIT</span></a>
<a name="131" /><span class="Maybe">     131:</span>             <span class="m">int</span> <span class="b">pages</span><span class="f">;</span>    <span class="k">/* Nr of partial slabs left */</span>
<a name="132" /><span class="Maybe">     132:</span>             <span class="m">int</span> <span class="b">pobjects</span><span class="f">;</span>    <span class="k">/* Approximate # of objects */</span>
<a name="133" /><span class="False">     133:</span> <span class="f">#</span><span class="n">else</span>
<a name="134" /><span class="False">     134:</span>             <span class="m">short</span> <span class="m">int</span> <span class="b">pages</span><span class="f">;</span>
<a name="135" /><span class="False">     135:</span>             <span class="m">short</span> <span class="m">int</span> <span class="b">pobjects</span><span class="f">;</span>
<a name="136" /><span class="Maybe">     136:</span> <span class="f">#</span><span class="n">endif</span>
<a name="137" /><span class="Maybe">     137:</span>         <span class="f">}</span><span class="f">;</span>
<a name="138" /><span class="Maybe">     138:</span> 
<a name="139" /><span class="Maybe">     139:</span>         <span class="m">struct</span> <span class="b">list_head</span> <span class="b">list</span><span class="f">;</span>    <span class="k">/* slobs list of pages */</span>
<a name="140" /><span class="Maybe">     140:</span>         <span class="m">struct</span> <span class="b">slab</span> <span class="f">*</span><span class="b">slab_page</span><span class="f">;</span> <span class="k">/* slab fields */</span>
<a name="141" /><span class="Maybe">     141:</span>         <span class="m">struct</span> <a href="cpu.c_macros_ref.html#_cmN1X2hlYWRfMA__"><span class="b">rcu_head</span></a> <a href="cpu.c_macros_ref.html#_cmN1X2hlYWRfMA__"><span class="b">rcu_head</span></a><span class="f">;</span>    <span class="k">/* Used by SLAB</span>
<a name="142" /><span class="Maybe">     142:</span> <span class="k">                         * when destroying via RCU</span>
<a name="143" /><span class="Maybe">     143:</span> <span class="k">                         */</span>
<a name="144" /><span class="False">     144:</span> <span class="f">#</span><span class="n">if</span> <span class="b">defined</span><span class="f">(</span><span class="b">CONFIG_TRANSPARENT_HUGEPAGE</span><span class="f">)</span> <span class="f">&amp;&amp;</span> <a href="cpu.c_macros_ref.html#_VVNFX1NQTElUX1BNRF9QVExPQ0tTXzA_"><span class="b">USE_SPLIT_PMD_PTLOCKS</span></a>
<a name="145" /><span class="False">     145:</span>         <span class="b">pgtable_t</span> <a href="cpu.c_macros_noref.html#_cG1kX2h1Z2VfcHRlXzA_"><span class="b">pmd_huge_pte</span></a><span class="f">;</span> <span class="k">/* protected by page-&gt;ptl */</span>
<a name="146" /><span class="Maybe">     146:</span> <span class="f">#</span><span class="n">endif</span>
<a name="147" /><span class="Maybe">     147:</span>     <span class="f">}</span><span class="f">;</span>
<a name="148" /><span class="Maybe">     148:</span> 
<a name="149" /><span class="Maybe">     149:</span>     <span class="k">/* Remainder is not double word aligned */</span>
<a name="150" /><span class="Maybe">     150:</span>     <span class="m">union</span> <span class="f">{</span>
<a name="151" /><span class="Maybe">     151:</span>         <span class="m">unsigned</span> <span class="m">long</span> <span class="m">private</span><span class="f">;</span>        <span class="k">/* Mapping-private opaque data:</span>
<a name="152" /><span class="Maybe">     152:</span> <span class="k">                          * usually used for buffer_heads</span>
<a name="153" /><span class="Maybe">     153:</span> <span class="k">                         * if PagePrivate set; used for</span>
<a name="154" /><span class="Maybe">     154:</span> <span class="k">                         * swp_entry_t if PageSwapCache;</span>
<a name="155" /><span class="Maybe">     155:</span> <span class="k">                         * indicates order in the buddy</span>
<a name="156" /><span class="Maybe">     156:</span> <span class="k">                         * system if PG_buddy is set.</span>
<a name="157" /><span class="Maybe">     157:</span> <span class="k">                         */</span>
<a name="158" /><span class="Maybe">     158:</span> <span class="f">#</span><span class="n">if</span> <a href="cpu.c_macros_ref.html#_VVNFX1NQTElUX1BURV9QVExPQ0tTXzA_"><span class="b">USE_SPLIT_PTE_PTLOCKS</span></a>
<a name="159" /><span class="False">     159:</span> <span class="f">#</span><span class="n">if</span> <a href="cpu.c_macros_ref.html#_QUxMT0NfU1BMSVRfUFRMT0NLU18w"><span class="b">ALLOC_SPLIT_PTLOCKS</span></a>
<a name="160" /><span class="False">     160:</span>         <span class="b">spinlock_t</span> <span class="f">*</span><span class="b">ptl</span><span class="f">;</span>
<a name="161" /><span class="Maybe">     161:</span> <span class="f">#</span><span class="n">else</span>
<a name="162" /><span class="Maybe">     162:</span>         <span class="b">spinlock_t</span> <span class="b">ptl</span><span class="f">;</span>
<a name="163" /><span class="Maybe">     163:</span> <span class="f">#</span><span class="n">endif</span>
<a name="164" /><span class="Maybe">     164:</span> <span class="f">#</span><span class="n">endif</span>
<a name="165" /><span class="Maybe">     165:</span>         <span class="m">struct</span> <span class="b">kmem_cache</span> <span class="f">*</span><span class="b">slab_cache</span><span class="f">;</span>    <span class="k">/* SL[AU]B: Pointer to slab */</span>
<a name="166" /><span class="Maybe">     166:</span>         <span class="m">struct</span> <span class="b">page</span> <span class="f">*</span><span class="b">first_page</span><span class="f">;</span>    <span class="k">/* Compound tail pages */</span>
<a name="167" /><span class="Maybe">     167:</span>     <span class="f">}</span><span class="f">;</span>
<a name="168" /><span class="Maybe">     168:</span> 
<a name="169" /><span class="Maybe">     169:</span>     <span class="k">/*</span>
<a name="170" /><span class="Maybe">     170:</span> <span class="k">     * On machines where all RAM is mapped into kernel address space,</span>
<a name="171" /><span class="Maybe">     171:</span> <span class="k">     * we can simply calculate the virtual address. On machines with</span>
<a name="172" /><span class="Maybe">     172:</span> <span class="k">     * highmem some memory is mapped into kernel virtual memory</span>
<a name="173" /><span class="Maybe">     173:</span> <span class="k">     * dynamically, so we need a place to store that address.</span>
<a name="174" /><span class="Maybe">     174:</span> <span class="k">     * Note that this field could be 16 bits on x86 ... ;)</span>
<a name="175" /><span class="Maybe">     175:</span> <span class="k">     *</span>
<a name="176" /><span class="Maybe">     176:</span> <span class="k">     * Architectures with slow multiplication can define</span>
<a name="177" /><span class="Maybe">     177:</span> <span class="k">     * WANT_PAGE_VIRTUAL in asm/page.h</span>
<a name="178" /><span class="Maybe">     178:</span> <span class="k">     */</span>
<a name="179" /><span class="False">     179:</span> <span class="f">#</span><span class="n">if</span> <span class="b">defined</span><span class="f">(</span><span class="b">WANT_PAGE_VIRTUAL</span><span class="f">)</span>
<a name="180" /><span class="False">     180:</span>     <span class="m">void</span> <span class="f">*</span><span class="m">virtual</span><span class="f">;</span>            <span class="k">/* Kernel virtual address (NULL if</span>
<a name="181" /><span class="False">     181:</span> <span class="k">                       not kmapped, ie. highmem) */</span>
<a name="182" /><span class="Maybe">     182:</span> <span class="f">#</span><span class="n">endif</span> <span class="k">/* WANT_PAGE_VIRTUAL */</span>
<a name="183" /><span class="False">     183:</span> <span class="f">#</span><span class="n">ifdef</span> <span class="b">CONFIG_WANT_PAGE_DEBUG_FLAGS</span>
<a name="184" /><span class="False">     184:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">debug_flags</span><span class="f">;</span>    <span class="k">/* Use atomic bitops on this */</span>
<a name="185" /><span class="Maybe">     185:</span> <span class="f">#</span><span class="n">endif</span>
<a name="186" /><span class="Maybe">     186:</span> 
<a name="187" /><span class="False">     187:</span> <span class="f">#</span><span class="n">ifdef</span> <span class="b">CONFIG_KMEMCHECK</span>
<a name="188" /><span class="False">     188:</span>     <span class="k">/*</span>
<a name="189" /><span class="False">     189:</span> <span class="k">     * kmemcheck wants to track the status of each byte in a page; this</span>
<a name="190" /><span class="False">     190:</span> <span class="k">     * is a pointer to such a status block. NULL if not tracked.</span>
<a name="191" /><span class="False">     191:</span> <span class="k">     */</span>
<a name="192" /><span class="False">     192:</span>     <span class="m">void</span> <span class="f">*</span><span class="b">shadow</span><span class="f">;</span>
<a name="193" /><span class="Maybe">     193:</span> <span class="f">#</span><span class="n">endif</span>
<a name="194" /><span class="Maybe">     194:</span> 
<a name="195" /><span class="False">     195:</span> <span class="f">#</span><span class="n">ifdef</span> <span class="b">LAST_CPUPID_NOT_IN_PAGE_FLAGS</span>
<a name="196" /><span class="False">     196:</span>     <span class="m">int</span> <span class="b">_last_cpupid</span><span class="f">;</span>
<a name="197" /><span class="Maybe">     197:</span> <span class="f">#</span><span class="n">endif</span>
<a name="198" /><span class="Maybe">     198:</span> <span class="f">}</span>
<a name="199" /><span class="Maybe">     199:</span> <span class="k">/*</span>
<a name="200" /><span class="Maybe">     200:</span> <span class="k"> * The struct page can be forced to be double word aligned so that atomic ops</span>
<a name="201" /><span class="Maybe">     201:</span> <span class="k"> * on double words work. The SLUB allocator can make use of such a feature.</span>
<a name="202" /><span class="Maybe">     202:</span> <span class="k"> */</span>
<a name="203" /><span class="Maybe">     203:</span> <span class="f">#</span><span class="n">ifdef</span> <a href="cpu.c_macros_ref.html#_Q09ORklHX0hBVkVfQUxJR05FRF9TVFJVQ1RfUEFHRV8w"><span class="b">CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></a>
<a name="204" /><span class="Maybe">     204:</span>     <a href="cpu.c_macros_ref.html#_X19hbGlnbmVkXzA_"><span class="b">__aligned</span></a><span class="f">(</span><span class="c">2</span> <span class="f">*</span> <span class="m">sizeof</span><span class="f">(</span><span class="m">unsigned</span> <span class="m">long</span><span class="f">)</span><span class="f">)</span>
<a name="205" /><span class="Maybe">     205:</span> <span class="f">#</span><span class="n">endif</span>
<a name="206" /><span class="Maybe">     206:</span> <span class="f">;</span>
<a name="207" /><span class="Maybe">     207:</span> 
<a name="208" /><span class="Maybe">     208:</span> <span class="m">struct</span> <span class="b">page_frag</span> <span class="f">{</span>
<a name="209" /><span class="Maybe">     209:</span>     <span class="m">struct</span> <span class="b">page</span> <span class="f">*</span><span class="b">page</span><span class="f">;</span>
<a name="210" /><span class="Maybe">     210:</span> <span class="f">#</span><span class="n">if</span> <span class="f">(</span><a href="cpu.c_macros_ref.html#_QklUU19QRVJfTE9OR18w"><span class="b">BITS_PER_LONG</span></a> <span class="f">&gt;</span> <span class="c">32</span><span class="f">)</span> <span class="f">||</span> <span class="f">(</span><a href="cpu.c_macros_ref.html#_UEFHRV9TSVpFXzA_"><span class="b">PAGE_SIZE</span></a> <span class="f">&gt;=</span> <span class="c">65536</span><span class="f">)</span>
<a name="211" /><span class="Maybe">     211:</span>     <span class="b">__u32</span> <span class="b">offset</span><span class="f">;</span>
<a name="212" /><span class="Maybe">     212:</span>     <span class="b">__u32</span> <span class="b">size</span><span class="f">;</span>
<a name="213" /><span class="False">     213:</span> <span class="f">#</span><span class="n">else</span>
<a name="214" /><span class="False">     214:</span>     <span class="b">__u16</span> <span class="b">offset</span><span class="f">;</span>
<a name="215" /><span class="False">     215:</span>     <span class="b">__u16</span> <span class="b">size</span><span class="f">;</span>
<a name="216" /><span class="Maybe">     216:</span> <span class="f">#</span><span class="n">endif</span>
<a name="217" /><span class="Maybe">     217:</span> <span class="f">}</span><span class="f">;</span>
<a name="218" /><span class="Maybe">     218:</span> 
<a name="219" /><span class="Maybe">     219:</span> <span class="m">typedef</span> <span class="m">unsigned</span> <span class="m">long</span> <a href="cpu.c_macros_ref.html#_X19ub2Nhc3RfMA__"><span class="b">__nocast</span></a> <span class="b">vm_flags_t</span><span class="f">;</span>
<a name="220" /><span class="Maybe">     220:</span> 
<a name="221" /><span class="Maybe">     221:</span> <span class="k">/*</span>
<a name="222" /><span class="Maybe">     222:</span> <span class="k"> * A region containing a mapping of a non-memory backed file under NOMMU</span>
<a name="223" /><span class="Maybe">     223:</span> <span class="k"> * conditions.  These are held in a global tree and are pinned by the VMAs that</span>
<a name="224" /><span class="Maybe">     224:</span> <span class="k"> * map parts of them.</span>
<a name="225" /><span class="Maybe">     225:</span> <span class="k"> */</span>
<a name="226" /><span class="Maybe">     226:</span> <span class="m">struct</span> <span class="b">vm_region</span> <span class="f">{</span>
<a name="227" /><span class="Maybe">     227:</span>     <span class="m">struct</span> <span class="b">rb_node</span>    <span class="b">vm_rb</span><span class="f">;</span>        <span class="k">/* link in global region tree */</span>
<a name="228" /><span class="Maybe">     228:</span>     <span class="b">vm_flags_t</span>    <span class="b">vm_flags</span><span class="f">;</span>    <span class="k">/* VMA vm_flags */</span>
<a name="229" /><span class="Maybe">     229:</span>     <span class="m">unsigned</span> <span class="m">long</span>    <span class="b">vm_start</span><span class="f">;</span>    <span class="k">/* start address of region */</span>
<a name="230" /><span class="Maybe">     230:</span>     <span class="m">unsigned</span> <span class="m">long</span>    <span class="b">vm_end</span><span class="f">;</span>        <span class="k">/* region initialised to here */</span>
<a name="231" /><span class="Maybe">     231:</span>     <span class="m">unsigned</span> <span class="m">long</span>    <span class="b">vm_top</span><span class="f">;</span>        <span class="k">/* region allocated to here */</span>
<a name="232" /><span class="Maybe">     232:</span>     <span class="m">unsigned</span> <span class="m">long</span>    <span class="b">vm_pgoff</span><span class="f">;</span>    <span class="k">/* the offset in vm_file corresponding to vm_start */</span>
<a name="233" /><span class="Maybe">     233:</span>     <span class="m">struct</span> <span class="b">file</span>    <span class="f">*</span><span class="b">vm_file</span><span class="f">;</span>    <span class="k">/* the backing file or NULL */</span>
<a name="234" /><span class="Maybe">     234:</span> 
<a name="235" /><span class="Maybe">     235:</span>     <span class="m">int</span>        <span class="b">vm_usage</span><span class="f">;</span>    <span class="k">/* region usage count (access under nommu_region_sem) */</span>
<a name="236" /><span class="Maybe">     236:</span>     <span class="m">bool</span>        <span class="b">vm_icache_flushed</span> <span class="f">:</span> <span class="c">1</span><span class="f">;</span> <span class="k">/* true if the icache has been flushed for</span>
<a name="237" /><span class="Maybe">     237:</span> <span class="k">                        * this region */</span>
<a name="238" /><span class="Maybe">     238:</span> <span class="f">}</span><span class="f">;</span>
<a name="239" /><span class="Maybe">     239:</span> 
<a name="240" /><span class="Maybe">     240:</span> <span class="k">/*</span>
<a name="241" /><span class="Maybe">     241:</span> <span class="k"> * This struct defines a memory VMM memory area. There is one of these</span>
<a name="242" /><span class="Maybe">     242:</span> <span class="k"> * per VM-area/task.  A VM area is any part of the process virtual memory</span>
<a name="243" /><span class="Maybe">     243:</span> <span class="k"> * space that has a special rule for the page-fault handlers (ie a shared</span>
<a name="244" /><span class="Maybe">     244:</span> <span class="k"> * library, the executable area etc).</span>
<a name="245" /><span class="Maybe">     245:</span> <span class="k"> */</span>
<a name="246" /><span class="Maybe">     246:</span> <span class="m">struct</span> <span class="b">vm_area_struct</span> <span class="f">{</span>
<a name="247" /><span class="Maybe">     247:</span>     <span class="k">/* The first cache line has the info for VMA tree walking. */</span>
<a name="248" /><span class="Maybe">     248:</span> 
<a name="249" /><span class="Maybe">     249:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">vm_start</span><span class="f">;</span>        <span class="k">/* Our start address within vm_mm. */</span>
<a name="250" /><span class="Maybe">     250:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">vm_end</span><span class="f">;</span>        <span class="k">/* The first byte after our end address</span>
<a name="251" /><span class="Maybe">     251:</span> <span class="k">                       within vm_mm. */</span>
<a name="252" /><span class="Maybe">     252:</span> 
<a name="253" /><span class="Maybe">     253:</span>     <span class="k">/* linked list of VM areas per task, sorted by address */</span>
<a name="254" /><span class="Maybe">     254:</span>     <span class="m">struct</span> <span class="b">vm_area_struct</span> <span class="f">*</span><span class="b">vm_next</span><span class="f">,</span> <span class="f">*</span><span class="b">vm_prev</span><span class="f">;</span>
<a name="255" /><span class="Maybe">     255:</span> 
<a name="256" /><span class="Maybe">     256:</span>     <span class="m">struct</span> <span class="b">rb_node</span> <span class="b">vm_rb</span><span class="f">;</span>
<a name="257" /><span class="Maybe">     257:</span> 
<a name="258" /><span class="Maybe">     258:</span>     <span class="k">/*</span>
<a name="259" /><span class="Maybe">     259:</span> <span class="k">     * Largest free memory gap in bytes to the left of this VMA.</span>
<a name="260" /><span class="Maybe">     260:</span> <span class="k">     * Either between this VMA and vma-&gt;vm_prev, or between one of the</span>
<a name="261" /><span class="Maybe">     261:</span> <span class="k">     * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span>
<a name="262" /><span class="Maybe">     262:</span> <span class="k">     * get_unmapped_area find a free area of the right size.</span>
<a name="263" /><span class="Maybe">     263:</span> <span class="k">     */</span>
<a name="264" /><span class="Maybe">     264:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">rb_subtree_gap</span><span class="f">;</span>
<a name="265" /><span class="Maybe">     265:</span> 
<a name="266" /><span class="Maybe">     266:</span>     <span class="k">/* Second cache line starts here. */</span>
<a name="267" /><span class="Maybe">     267:</span> 
<a name="268" /><span class="Maybe">     268:</span>     <span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">vm_mm</span><span class="f">;</span>    <span class="k">/* The address space we belong to. */</span>
<a name="269" /><span class="Maybe">     269:</span>     <span class="b">pgprot_t</span> <span class="b">vm_page_prot</span><span class="f">;</span>        <span class="k">/* Access permissions of this VMA. */</span>
<a name="270" /><span class="Maybe">     270:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">vm_flags</span><span class="f">;</span>        <span class="k">/* Flags, see mm.h. */</span>
<a name="271" /><span class="Maybe">     271:</span> 
<a name="272" /><span class="Maybe">     272:</span>     <span class="k">/*</span>
<a name="273" /><span class="Maybe">     273:</span> <span class="k">     * For areas with an address space and backing store,</span>
<a name="274" /><span class="Maybe">     274:</span> <span class="k">     * linkage into the address_space-&gt;i_mmap interval tree, or</span>
<a name="275" /><span class="Maybe">     275:</span> <span class="k">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span>
<a name="276" /><span class="Maybe">     276:</span> <span class="k">     */</span>
<a name="277" /><span class="Maybe">     277:</span>     <span class="m">union</span> <span class="f">{</span>
<a name="278" /><span class="Maybe">     278:</span>         <span class="m">struct</span> <span class="f">{</span>
<a name="279" /><span class="Maybe">     279:</span>             <span class="m">struct</span> <span class="b">rb_node</span> <span class="b">rb</span><span class="f">;</span>
<a name="280" /><span class="Maybe">     280:</span>             <span class="m">unsigned</span> <span class="m">long</span> <span class="b">rb_subtree_last</span><span class="f">;</span>
<a name="281" /><span class="Maybe">     281:</span>         <span class="f">}</span> <span class="b">linear</span><span class="f">;</span>
<a name="282" /><span class="Maybe">     282:</span>         <span class="m">struct</span> <span class="b">list_head</span> <span class="b">nonlinear</span><span class="f">;</span>
<a name="283" /><span class="Maybe">     283:</span>     <span class="f">}</span> <span class="b">shared</span><span class="f">;</span>
<a name="284" /><span class="Maybe">     284:</span> 
<a name="285" /><span class="Maybe">     285:</span>     <span class="k">/*</span>
<a name="286" /><span class="Maybe">     286:</span> <span class="k">     * A file&apos;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span>
<a name="287" /><span class="Maybe">     287:</span> <span class="k">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span>
<a name="288" /><span class="Maybe">     288:</span> <span class="k">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span>
<a name="289" /><span class="Maybe">     289:</span> <span class="k">     * or brk vma (with NULL file) can only be in an anon_vma list.</span>
<a name="290" /><span class="Maybe">     290:</span> <span class="k">     */</span>
<a name="291" /><span class="Maybe">     291:</span>     <span class="m">struct</span> <span class="b">list_head</span> <span class="b">anon_vma_chain</span><span class="f">;</span> <span class="k">/* Serialized by mmap_sem &amp;</span>
<a name="292" /><span class="Maybe">     292:</span> <span class="k">                      * page_table_lock */</span>
<a name="293" /><span class="Maybe">     293:</span>     <span class="m">struct</span> <span class="b">anon_vma</span> <span class="f">*</span><span class="b">anon_vma</span><span class="f">;</span>    <span class="k">/* Serialized by page_table_lock */</span>
<a name="294" /><span class="Maybe">     294:</span> 
<a name="295" /><span class="Maybe">     295:</span>     <span class="k">/* Function pointers to deal with this struct. */</span>
<a name="296" /><span class="Maybe">     296:</span>     <span class="m">const</span> <span class="m">struct</span> <span class="b">vm_operations_struct</span> <span class="f">*</span><span class="b">vm_ops</span><span class="f">;</span>
<a name="297" /><span class="Maybe">     297:</span> 
<a name="298" /><span class="Maybe">     298:</span>     <span class="k">/* Information about our backing store: */</span>
<a name="299" /><span class="Maybe">     299:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">vm_pgoff</span><span class="f">;</span>        <span class="k">/* Offset (within vm_file) in PAGE_SIZE</span>
<a name="300" /><span class="Maybe">     300:</span> <span class="k">                       units, *not* PAGE_CACHE_SIZE */</span>
<a name="301" /><span class="Maybe">     301:</span>     <span class="m">struct</span> <span class="b">file</span> <span class="f">*</span> <span class="b">vm_file</span><span class="f">;</span>        <span class="k">/* File we map to (can be NULL). */</span>
<a name="302" /><span class="Maybe">     302:</span>     <span class="m">void</span> <span class="f">*</span> <span class="b">vm_private_data</span><span class="f">;</span>        <span class="k">/* was vm_pte (shared mem) */</span>
<a name="303" /><span class="Maybe">     303:</span> 
<a name="304" /><span class="False">     304:</span> <span class="f">#</span><span class="n">ifndef</span> <a href="cpu.c_macros_ref.html#_Q09ORklHX01NVV8w"><span class="b">CONFIG_MMU</span></a>
<a name="305" /><span class="False">     305:</span>     <span class="m">struct</span> <span class="b">vm_region</span> <span class="f">*</span><span class="b">vm_region</span><span class="f">;</span>    <span class="k">/* NOMMU mapping region */</span>
<a name="306" /><span class="Maybe">     306:</span> <span class="f">#</span><span class="n">endif</span>
<a name="307" /><span class="Maybe">     307:</span> <span class="f">#</span><span class="n">ifdef</span> <a href="cpu.c_macros_ref.html#_Q09ORklHX05VTUFfMA__"><span class="b">CONFIG_NUMA</span></a>
<a name="308" /><span class="Maybe">     308:</span>     <span class="m">struct</span> <span class="b">mempolicy</span> <span class="f">*</span><span class="b">vm_policy</span><span class="f">;</span>    <span class="k">/* NUMA policy for the VMA */</span>
<a name="309" /><span class="Maybe">     309:</span> <span class="f">#</span><span class="n">endif</span>
<a name="310" /><span class="Maybe">     310:</span> <span class="f">}</span><span class="f">;</span>
<a name="311" /><span class="Maybe">     311:</span> 
<a name="312" /><span class="Maybe">     312:</span> <span class="m">struct</span> <span class="b">core_thread</span> <span class="f">{</span>
<a name="313" /><span class="Maybe">     313:</span>     <span class="m">struct</span> <span class="b">task_struct</span> <span class="f">*</span><span class="b">task</span><span class="f">;</span>
<a name="314" /><span class="Maybe">     314:</span>     <span class="m">struct</span> <span class="b">core_thread</span> <span class="f">*</span><span class="b">next</span><span class="f">;</span>
<a name="315" /><span class="Maybe">     315:</span> <span class="f">}</span><span class="f">;</span>
<a name="316" /><span class="Maybe">     316:</span> 
<a name="317" /><span class="Maybe">     317:</span> <span class="m">struct</span> <span class="b">core_state</span> <span class="f">{</span>
<a name="318" /><span class="Maybe">     318:</span>     <span class="b">atomic_t</span> <span class="b">nr_threads</span><span class="f">;</span>
<a name="319" /><span class="Maybe">     319:</span>     <span class="m">struct</span> <span class="b">core_thread</span> <span class="b">dumper</span><span class="f">;</span>
<a name="320" /><span class="Maybe">     320:</span>     <span class="m">struct</span> <span class="b">completion</span> <span class="b">startup</span><span class="f">;</span>
<a name="321" /><span class="Maybe">     321:</span> <span class="f">}</span><span class="f">;</span>
<a name="322" /><span class="Maybe">     322:</span> 
<a name="323" /><span class="Maybe">     323:</span> <span class="m">enum</span> <span class="f">{</span>
<a name="324" /><span class="Maybe">     324:</span>     <span class="b">MM_FILEPAGES</span><span class="f">,</span>
<a name="325" /><span class="Maybe">     325:</span>     <span class="b">MM_ANONPAGES</span><span class="f">,</span>
<a name="326" /><span class="Maybe">     326:</span>     <span class="b">MM_SWAPENTS</span><span class="f">,</span>
<a name="327" /><span class="Maybe">     327:</span>     <span class="b">NR_MM_COUNTERS</span>
<a name="328" /><span class="Maybe">     328:</span> <span class="f">}</span><span class="f">;</span>
<a name="329" /><span class="Maybe">     329:</span> 
<a name="330" /><span class="Maybe">     330:</span> <span class="f">#</span><span class="n">if</span> <a href="cpu.c_macros_ref.html#_VVNFX1NQTElUX1BURV9QVExPQ0tTXzA_"><span class="b">USE_SPLIT_PTE_PTLOCKS</span></a> <span class="f">&amp;&amp;</span> <span class="b">defined</span><span class="f">(</span><a href="cpu.c_macros_ref.html#_Q09ORklHX01NVV8w"><span class="b">CONFIG_MMU</span></a><span class="f">)</span>
<a name="331" /><span class="Maybe">     331:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_U1BMSVRfUlNTX0NPVU5USU5HXzA_"><span class="b">SPLIT_RSS_COUNTING</span></a>
<a name="332" /><span class="Maybe">     332:</span> <span class="k">/* per-thread cached information, */</span>
<a name="333" /><span class="Maybe">     333:</span> <span class="m">struct</span> <span class="b">task_rss_stat</span> <span class="f">{</span>
<a name="334" /><span class="Maybe">     334:</span>     <span class="m">int</span> <span class="b">events</span><span class="f">;</span>    <span class="k">/* for synchronization threshold */</span>
<a name="335" /><span class="Maybe">     335:</span>     <span class="m">int</span> <span class="b">count</span><span class="f">[</span><span class="b">NR_MM_COUNTERS</span><span class="f">]</span><span class="f">;</span>
<a name="336" /><span class="Maybe">     336:</span> <span class="f">}</span><span class="f">;</span>
<a name="337" /><span class="Maybe">     337:</span> <span class="f">#</span><span class="n">endif</span> <span class="k">/* USE_SPLIT_PTE_PTLOCKS */</span>
<a name="338" /><span class="Maybe">     338:</span> 
<a name="339" /><span class="Maybe">     339:</span> <span class="m">struct</span> <span class="b">mm_rss_stat</span> <span class="f">{</span>
<a name="340" /><span class="Maybe">     340:</span>     <span class="b">atomic_long_t</span> <span class="b">count</span><span class="f">[</span><span class="b">NR_MM_COUNTERS</span><span class="f">]</span><span class="f">;</span>
<a name="341" /><span class="Maybe">     341:</span> <span class="f">}</span><span class="f">;</span>
<a name="342" /><span class="Maybe">     342:</span> 
<a name="343" /><span class="Maybe">     343:</span> <span class="m">struct</span> <span class="b">kioctx_table</span><span class="f">;</span>
<a name="344" /><span class="Maybe">     344:</span> <span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">{</span>
<a name="345" /><span class="Maybe">     345:</span>     <span class="m">struct</span> <span class="b">vm_area_struct</span> <span class="f">*</span> <span class="b">mmap</span><span class="f">;</span>        <span class="k">/* list of VMAs */</span>
<a name="346" /><span class="Maybe">     346:</span>     <span class="m">struct</span> <span class="b">rb_root</span> <span class="b">mm_rb</span><span class="f">;</span>
<a name="347" /><span class="Maybe">     347:</span>     <span class="m">struct</span> <span class="b">vm_area_struct</span> <span class="f">*</span> <span class="b">mmap_cache</span><span class="f">;</span>    <span class="k">/* last find_vma result */</span>
<a name="348" /><span class="Maybe">     348:</span> <span class="f">#</span><span class="n">ifdef</span> <a href="cpu.c_macros_ref.html#_Q09ORklHX01NVV8w"><span class="b">CONFIG_MMU</span></a>
<a name="349" /><span class="Maybe">     349:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="f">(</span><span class="f">*</span><span class="b">get_unmapped_area</span><span class="f">)</span> <span class="f">(</span><span class="m">struct</span> <span class="b">file</span> <span class="f">*</span><span class="b">filp</span><span class="f">,</span>
<a name="350" /><span class="Maybe">     350:</span>                 <span class="m">unsigned</span> <span class="m">long</span> <span class="b">addr</span><span class="f">,</span> <span class="m">unsigned</span> <span class="m">long</span> <span class="b">len</span><span class="f">,</span>
<a name="351" /><span class="Maybe">     351:</span>                 <span class="m">unsigned</span> <span class="m">long</span> <span class="b">pgoff</span><span class="f">,</span> <span class="m">unsigned</span> <span class="m">long</span> <span class="b">flags</span><span class="f">)</span><span class="f">;</span>
<a name="352" /><span class="Maybe">     352:</span> <span class="f">#</span><span class="n">endif</span>
<a name="353" /><span class="Maybe">     353:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">mmap_base</span><span class="f">;</span>        <span class="k">/* base of mmap area */</span>
<a name="354" /><span class="Maybe">     354:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">mmap_legacy_base</span><span class="f">;</span>         <span class="k">/* base of mmap area in bottom-up allocations */</span>
<a name="355" /><span class="Maybe">     355:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">task_size</span><span class="f">;</span>        <span class="k">/* size of task vm space */</span>
<a name="356" /><span class="Maybe">     356:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">highest_vm_end</span><span class="f">;</span>        <span class="k">/* highest vma end address */</span>
<a name="357" /><span class="Maybe">     357:</span>     <span class="b">pgd_t</span> <span class="f">*</span> <span class="b">pgd</span><span class="f">;</span>
<a name="358" /><span class="Maybe">     358:</span>     <span class="b">atomic_t</span> <span class="b">mm_users</span><span class="f">;</span>            <span class="k">/* How many users with user space? */</span>
<a name="359" /><span class="Maybe">     359:</span>     <span class="b">atomic_t</span> <span class="b">mm_count</span><span class="f">;</span>            <span class="k">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span>
<a name="360" /><span class="Maybe">     360:</span>     <span class="b">atomic_long_t</span> <span class="b">nr_ptes</span><span class="f">;</span>            <span class="k">/* Page table pages */</span>
<a name="361" /><span class="Maybe">     361:</span>     <span class="m">int</span> <span class="b">map_count</span><span class="f">;</span>                <span class="k">/* number of VMAs */</span>
<a name="362" /><span class="Maybe">     362:</span> 
<a name="363" /><span class="Maybe">     363:</span>     <span class="b">spinlock_t</span> <span class="b">page_table_lock</span><span class="f">;</span>        <span class="k">/* Protects page tables and some counters */</span>
<a name="364" /><span class="Maybe">     364:</span>     <span class="m">struct</span> <span class="b">rw_semaphore</span> <span class="b">mmap_sem</span><span class="f">;</span>
<a name="365" /><span class="Maybe">     365:</span> 
<a name="366" /><span class="Maybe">     366:</span>     <span class="m">struct</span> <span class="b">list_head</span> <span class="b">mmlist</span><span class="f">;</span>        <span class="k">/* List of maybe swapped mm&apos;s.    These are globally strung</span>
<a name="367" /><span class="Maybe">     367:</span> <span class="k">                         * together off init_mm.mmlist, and are protected</span>
<a name="368" /><span class="Maybe">     368:</span> <span class="k">                         * by mmlist_lock</span>
<a name="369" /><span class="Maybe">     369:</span> <span class="k">                         */</span>
<a name="370" /><span class="Maybe">     370:</span> 
<a name="371" /><span class="Maybe">     371:</span> 
<a name="372" /><span class="Maybe">     372:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">hiwater_rss</span><span class="f">;</span>    <span class="k">/* High-watermark of RSS usage */</span>
<a name="373" /><span class="Maybe">     373:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">hiwater_vm</span><span class="f">;</span>    <span class="k">/* High-water virtual memory usage */</span>
<a name="374" /><span class="Maybe">     374:</span> 
<a name="375" /><span class="Maybe">     375:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">total_vm</span><span class="f">;</span>        <span class="k">/* Total pages mapped */</span>
<a name="376" /><span class="Maybe">     376:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">locked_vm</span><span class="f">;</span>    <span class="k">/* Pages that have PG_mlocked set */</span>
<a name="377" /><span class="Maybe">     377:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">pinned_vm</span><span class="f">;</span>    <span class="k">/* Refcount permanently increased */</span>
<a name="378" /><span class="Maybe">     378:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">shared_vm</span><span class="f">;</span>    <span class="k">/* Shared pages (files) */</span>
<a name="379" /><span class="Maybe">     379:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">exec_vm</span><span class="f">;</span>        <span class="k">/* VM_EXEC &amp; ~VM_WRITE */</span>
<a name="380" /><span class="Maybe">     380:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">stack_vm</span><span class="f">;</span>        <span class="k">/* VM_GROWSUP/DOWN */</span>
<a name="381" /><span class="Maybe">     381:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">def_flags</span><span class="f">;</span>
<a name="382" /><span class="Maybe">     382:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">start_code</span><span class="f">,</span> <span class="b">end_code</span><span class="f">,</span> <span class="b">start_data</span><span class="f">,</span> <span class="b">end_data</span><span class="f">;</span>
<a name="383" /><span class="Maybe">     383:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">start_brk</span><span class="f">,</span> <span class="b">brk</span><span class="f">,</span> <span class="b">start_stack</span><span class="f">;</span>
<a name="384" /><span class="Maybe">     384:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">arg_start</span><span class="f">,</span> <span class="b">arg_end</span><span class="f">,</span> <span class="b">env_start</span><span class="f">,</span> <span class="b">env_end</span><span class="f">;</span>
<a name="385" /><span class="Maybe">     385:</span> 
<a name="386" /><span class="Maybe">     386:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">saved_auxv</span><span class="f">[</span><a href="cpu.c_macros_ref.html#_QVRfVkVDVE9SX1NJWkVfMA__"><span class="b">AT_VECTOR_SIZE</span></a><span class="f">]</span><span class="f">;</span> <span class="k">/* for /proc/PID/auxv */</span>
<a name="387" /><span class="Maybe">     387:</span> 
<a name="388" /><span class="Maybe">     388:</span>     <span class="k">/*</span>
<a name="389" /><span class="Maybe">     389:</span> <span class="k">     * Special counters, in some configurations protected by the</span>
<a name="390" /><span class="Maybe">     390:</span> <span class="k">     * page_table_lock, in other configurations by being atomic.</span>
<a name="391" /><span class="Maybe">     391:</span> <span class="k">     */</span>
<a name="392" /><span class="Maybe">     392:</span>     <span class="m">struct</span> <span class="b">mm_rss_stat</span> <span class="b">rss_stat</span><span class="f">;</span>
<a name="393" /><span class="Maybe">     393:</span> 
<a name="394" /><span class="Maybe">     394:</span>     <span class="m">struct</span> <span class="b">linux_binfmt</span> <span class="f">*</span><span class="b">binfmt</span><span class="f">;</span>
<a name="395" /><span class="Maybe">     395:</span> 
<a name="396" /><span class="Maybe">     396:</span>     <span class="b">cpumask_var_t</span> <span class="b">cpu_vm_mask_var</span><span class="f">;</span>
<a name="397" /><span class="Maybe">     397:</span> 
<a name="398" /><span class="Maybe">     398:</span>     <span class="k">/* Architecture-specific MM context */</span>
<a name="399" /><span class="Maybe">     399:</span>     <span class="b">mm_context_t</span> <span class="b">context</span><span class="f">;</span>
<a name="400" /><span class="Maybe">     400:</span> 
<a name="401" /><span class="Maybe">     401:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">flags</span><span class="f">;</span> <span class="k">/* Must use atomic bitops to access the bits */</span>
<a name="402" /><span class="Maybe">     402:</span> 
<a name="403" /><span class="Maybe">     403:</span>     <span class="m">struct</span> <span class="b">core_state</span> <span class="f">*</span><span class="b">core_state</span><span class="f">;</span> <span class="k">/* coredumping support */</span>
<a name="404" /><span class="Maybe">     404:</span> <span class="f">#</span><span class="n">ifdef</span> <a href="cpu.c_macros_ref.html#_Q09ORklHX0FJT18w"><span class="b">CONFIG_AIO</span></a>
<a name="405" /><span class="Maybe">     405:</span>     <span class="b">spinlock_t</span>            <span class="b">ioctx_lock</span><span class="f">;</span>
<a name="406" /><span class="Maybe">     406:</span>     <span class="m">struct</span> <span class="b">kioctx_table</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a>    <span class="f">*</span><span class="b">ioctx_table</span><span class="f">;</span>
<a name="407" /><span class="Maybe">     407:</span> <span class="f">#</span><span class="n">endif</span>
<a name="408" /><span class="False">     408:</span> <span class="f">#</span><span class="n">ifdef</span> <span class="b">CONFIG_MM_OWNER</span>
<a name="409" /><span class="False">     409:</span>     <span class="k">/*</span>
<a name="410" /><span class="False">     410:</span> <span class="k">     * &quot;owner&quot; points to a task that is regarded as the canonical</span>
<a name="411" /><span class="False">     411:</span> <span class="k">     * user/owner of this mm. All of the following must be true in</span>
<a name="412" /><span class="False">     412:</span> <span class="k">     * order for it to be changed:</span>
<a name="413" /><span class="False">     413:</span> <span class="k">     *</span>
<a name="414" /><span class="False">     414:</span> <span class="k">     * current == mm-&gt;owner</span>
<a name="415" /><span class="False">     415:</span> <span class="k">     * current-&gt;mm != mm</span>
<a name="416" /><span class="False">     416:</span> <span class="k">     * new_owner-&gt;mm == mm</span>
<a name="417" /><span class="False">     417:</span> <span class="k">     * new_owner-&gt;alloc_lock is held</span>
<a name="418" /><span class="False">     418:</span> <span class="k">     */</span>
<a name="419" /><span class="False">     419:</span>     <span class="m">struct</span> <span class="b">task_struct</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a> <span class="f">*</span><span class="b">owner</span><span class="f">;</span>
<a name="420" /><span class="Maybe">     420:</span> <span class="f">#</span><span class="n">endif</span>
<a name="421" /><span class="Maybe">     421:</span> 
<a name="422" /><span class="Maybe">     422:</span>     <span class="k">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span>
<a name="423" /><span class="Maybe">     423:</span>     <span class="m">struct</span> <span class="b">file</span> <span class="f">*</span><span class="b">exe_file</span><span class="f">;</span>
<a name="424" /><span class="Maybe">     424:</span> <span class="f">#</span><span class="n">ifdef</span> <a href="cpu.c_macros_ref.html#_Q09ORklHX01NVV9OT1RJRklFUl8w"><span class="b">CONFIG_MMU_NOTIFIER</span></a>
<a name="425" /><span class="Maybe">     425:</span>     <span class="m">struct</span> <span class="b">mmu_notifier_mm</span> <span class="f">*</span><span class="b">mmu_notifier_mm</span><span class="f">;</span>
<a name="426" /><span class="Maybe">     426:</span> <span class="f">#</span><span class="n">endif</span>
<a name="427" /><span class="False">     427:</span> <span class="f">#</span><span class="n">if</span> <span class="b">defined</span><span class="f">(</span><span class="b">CONFIG_TRANSPARENT_HUGEPAGE</span><span class="f">)</span> <span class="f">&amp;&amp;</span> <span class="f">!</span><a href="cpu.c_macros_ref.html#_VVNFX1NQTElUX1BNRF9QVExPQ0tTXzA_"><span class="b">USE_SPLIT_PMD_PTLOCKS</span></a>
<a name="428" /><span class="False">     428:</span>     <span class="b">pgtable_t</span> <a href="cpu.c_macros_noref.html#_cG1kX2h1Z2VfcHRlXzA_"><span class="b">pmd_huge_pte</span></a><span class="f">;</span> <span class="k">/* protected by page_table_lock */</span>
<a name="429" /><span class="Maybe">     429:</span> <span class="f">#</span><span class="n">endif</span>
<a name="430" /><span class="False">     430:</span> <span class="f">#</span><span class="n">ifdef</span> <span class="b">CONFIG_CPUMASK_OFFSTACK</span>
<a name="431" /><span class="False">     431:</span>     <span class="m">struct</span> <span class="b">cpumask</span> <span class="b">cpumask_allocation</span><span class="f">;</span>
<a name="432" /><span class="Maybe">     432:</span> <span class="f">#</span><span class="n">endif</span>
<a name="433" /><span class="False">     433:</span> <span class="f">#</span><span class="n">ifdef</span> <span class="b">CONFIG_NUMA_BALANCING</span>
<a name="434" /><span class="False">     434:</span>     <span class="k">/*</span>
<a name="435" /><span class="False">     435:</span> <span class="k">     * numa_next_scan is the next time that the PTEs will be marked</span>
<a name="436" /><span class="False">     436:</span> <span class="k">     * pte_numa. NUMA hinting faults will gather statistics and migrate</span>
<a name="437" /><span class="False">     437:</span> <span class="k">     * pages to new nodes if necessary.</span>
<a name="438" /><span class="False">     438:</span> <span class="k">     */</span>
<a name="439" /><span class="False">     439:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">numa_next_scan</span><span class="f">;</span>
<a name="440" /><span class="False">     440:</span> 
<a name="441" /><span class="False">     441:</span>     <span class="k">/* Restart point for scanning and setting pte_numa */</span>
<a name="442" /><span class="False">     442:</span>     <span class="m">unsigned</span> <span class="m">long</span> <span class="b">numa_scan_offset</span><span class="f">;</span>
<a name="443" /><span class="False">     443:</span> 
<a name="444" /><span class="False">     444:</span>     <span class="k">/* numa_scan_seq prevents two threads setting pte_numa */</span>
<a name="445" /><span class="False">     445:</span>     <span class="m">int</span> <span class="b">numa_scan_seq</span><span class="f">;</span>
<a name="446" /><span class="Maybe">     446:</span> <span class="f">#</span><span class="n">endif</span>
<a name="447" /><span class="False">     447:</span> <span class="f">#</span><span class="n">if</span> <span class="b">defined</span><span class="f">(</span><span class="b">CONFIG_NUMA_BALANCING</span><span class="f">)</span> <span class="f">||</span> <span class="b">defined</span><span class="f">(</span><span class="b">CONFIG_COMPACTION</span><span class="f">)</span>
<a name="448" /><span class="False">     448:</span>     <span class="k">/*</span>
<a name="449" /><span class="False">     449:</span> <span class="k">     * An operation with batched TLB flushing is going on. Anything that</span>
<a name="450" /><span class="False">     450:</span> <span class="k">     * can move process memory needs to flush the TLB when moving a</span>
<a name="451" /><span class="False">     451:</span> <span class="k">     * PROT_NONE or PROT_NUMA mapped page.</span>
<a name="452" /><span class="False">     452:</span> <span class="k">     */</span>
<a name="453" /><span class="False">     453:</span>     <span class="m">bool</span> <span class="b">tlb_flush_pending</span><span class="f">;</span>
<a name="454" /><span class="Maybe">     454:</span> <span class="f">#</span><span class="n">endif</span>
<a name="455" /><span class="Maybe">     455:</span>     <span class="m">struct</span> <span class="b">uprobes_state</span> <span class="b">uprobes_state</span><span class="f">;</span>
<a name="456" /><span class="Maybe">     456:</span> <span class="f">}</span><span class="f">;</span>
<a name="457" /><span class="Maybe">     457:</span> 
<a name="458" /><span class="Maybe">     458:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">mm_init_cpumask</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="459" /><span class="Maybe">     459:</span> <span class="f">{</span>
<a name="460" /><span class="False">     460:</span> <span class="f">#</span><span class="n">ifdef</span> <span class="b">CONFIG_CPUMASK_OFFSTACK</span>
<a name="461" /><span class="False">     461:</span>     <span class="b">mm</span><span class="f">-&gt;</span><span class="b">cpu_vm_mask_var</span> <span class="f">=</span> <span class="f">&amp;</span><span class="b">mm</span><span class="f">-&gt;</span><span class="b">cpumask_allocation</span><span class="f">;</span>
<a name="462" /><span class="Maybe">     462:</span> <span class="f">#</span><span class="n">endif</span>
<a name="463" /><span class="Maybe">     463:</span> <span class="f">}</span>
<a name="464" /><span class="Maybe">     464:</span> 
<a name="465" /><span class="Maybe">     465:</span> <span class="k">/* Future-safe accessor for struct mm_struct&apos;s cpu_vm_mask. */</span>
<a name="466" /><span class="Maybe">     466:</span> <span class="m">static</span> <span class="m">inline</span> <span class="b">cpumask_t</span> <span class="f">*</span><span class="b">mm_cpumask</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="467" /><span class="Maybe">     467:</span> <span class="f">{</span>
<a name="468" /><span class="Maybe">     468:</span>     <span class="m">return</span> <span class="b">mm</span><span class="f">-&gt;</span><span class="b">cpu_vm_mask_var</span><span class="f">;</span>
<a name="469" /><span class="Maybe">     469:</span> <span class="f">}</span>
<a name="470" /><span class="Maybe">     470:</span> 
<a name="471" /><span class="False">     471:</span> <span class="f">#</span><span class="n">if</span> <span class="b">defined</span><span class="f">(</span><span class="b">CONFIG_NUMA_BALANCING</span><span class="f">)</span> <span class="f">||</span> <span class="b">defined</span><span class="f">(</span><span class="b">CONFIG_COMPACTION</span><span class="f">)</span>
<a name="472" /><span class="False">     472:</span> <span class="k">/*</span>
<a name="473" /><span class="False">     473:</span> <span class="k"> * Memory barriers to keep this state in sync are graciously provided by</span>
<a name="474" /><span class="False">     474:</span> <span class="k"> * the page table locks, outside of which no page table modifications happen.</span>
<a name="475" /><span class="False">     475:</span> <span class="k"> * The barriers below prevent the compiler from re-ordering the instructions</span>
<a name="476" /><span class="False">     476:</span> <span class="k"> * around the memory barriers that are already present in the code.</span>
<a name="477" /><span class="False">     477:</span> <span class="k"> */</span>
<a name="478" /><span class="False">     478:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">bool</span> <span class="b">mm_tlb_flush_pending</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="479" /><span class="False">     479:</span> <span class="f">{</span>
<a name="480" /><span class="False">     480:</span>     <a href="cpu.c_macros_ref.html#_YmFycmllcl8w"><span class="b">barrier</span></a><span class="f">(</span><span class="f">)</span><span class="f">;</span>
<a name="481" /><span class="False">     481:</span>     <span class="m">return</span> <span class="b">mm</span><span class="f">-&gt;</span><span class="b">tlb_flush_pending</span><span class="f">;</span>
<a name="482" /><span class="False">     482:</span> <span class="f">}</span>
<a name="483" /><span class="False">     483:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">set_tlb_flush_pending</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="484" /><span class="False">     484:</span> <span class="f">{</span>
<a name="485" /><span class="False">     485:</span>     <span class="b">mm</span><span class="f">-&gt;</span><span class="b">tlb_flush_pending</span> <span class="f">=</span> <span class="m">true</span><span class="f">;</span>
<a name="486" /><span class="False">     486:</span> 
<a name="487" /><span class="False">     487:</span>     <span class="k">/*</span>
<a name="488" /><span class="False">     488:</span> <span class="k">     * Guarantee that the tlb_flush_pending store does not leak into the</span>
<a name="489" /><span class="False">     489:</span> <span class="k">     * critical section updating the page tables</span>
<a name="490" /><span class="False">     490:</span> <span class="k">     */</span>
<a name="491" /><span class="False">     491:</span>     <a href="cpu.c_macros_ref.html#_c21wX21iX19iZWZvcmVfc3BpbmxvY2tfMA__"><span class="b">smp_mb__before_spinlock</span></a><span class="f">(</span><span class="f">)</span><span class="f">;</span>
<a name="492" /><span class="False">     492:</span> <span class="f">}</span>
<a name="493" /><span class="False">     493:</span> <span class="k">/* Clearing is done after a TLB flush, which also provides a barrier. */</span>
<a name="494" /><span class="False">     494:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">clear_tlb_flush_pending</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="495" /><span class="False">     495:</span> <span class="f">{</span>
<a name="496" /><span class="False">     496:</span>     <a href="cpu.c_macros_ref.html#_YmFycmllcl8w"><span class="b">barrier</span></a><span class="f">(</span><span class="f">)</span><span class="f">;</span>
<a name="497" /><span class="False">     497:</span>     <span class="b">mm</span><span class="f">-&gt;</span><span class="b">tlb_flush_pending</span> <span class="f">=</span> <span class="m">false</span><span class="f">;</span>
<a name="498" /><span class="False">     498:</span> <span class="f">}</span>
<a name="499" /><span class="Maybe">     499:</span> <span class="f">#</span><span class="n">else</span>
<a name="500" /><span class="Maybe">     500:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">bool</span> <span class="b">mm_tlb_flush_pending</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="501" /><span class="Maybe">     501:</span> <span class="f">{</span>
<a name="502" /><span class="Maybe">     502:</span>     <span class="m">return</span> <span class="m">false</span><span class="f">;</span>
<a name="503" /><span class="Maybe">     503:</span> <span class="f">}</span>
<a name="504" /><span class="Maybe">     504:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">set_tlb_flush_pending</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="505" /><span class="Maybe">     505:</span> <span class="f">{</span>
<a name="506" /><span class="Maybe">     506:</span> <span class="f">}</span>
<a name="507" /><span class="Maybe">     507:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">clear_tlb_flush_pending</span><span class="f">(</span><span class="m">struct</span> <span class="b">mm_struct</span> <span class="f">*</span><span class="b">mm</span><span class="f">)</span>
<a name="508" /><span class="Maybe">     508:</span> <span class="f">{</span>
<a name="509" /><span class="Maybe">     509:</span> <span class="f">}</span>
<a name="510" /><span class="Maybe">     510:</span> <span class="f">#</span><span class="n">endif</span>
<a name="511" /><span class="Maybe">     511:</span> 
<a name="512" /><span class="True">     512:</span> <span class="f">#</span><span class="n">endif</span> <span class="k">/* _LINUX_MM_TYPES_H */</span>
<a name="513" /><span class="True">     513:</span> </pre>
  </body>
</html>
