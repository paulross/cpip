<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link href="cpip.css" rel="stylesheet" type="text/css" />
    <title>File: /Users/paulross/dev/linux/linux-3.13/include/linux/idr.h</title>
  </head>
  <body>
    <h1>File: /Users/paulross/dev/linux/linux-3.13/include/linux/idr.h</h1>
    <p>Green shading in the line number column
means the source is part of the translation unit, red means it is conditionally excluded.
Highlighted line numbers link to the translation unit page. Highlighted macros link to
the macro page.</p>
    <pre><a name="1" /><span class="True">       1:</span> <span class="k">/*</span>
<a name="2" /><span class="True">       2:</span> <span class="k"> * include/linux/idr.h</span>
<a name="3" /><span class="True">       3:</span> <span class="k"> * </span>
<a name="4" /><span class="True">       4:</span> <span class="k"> * 2002-10-18  written by Jim Houston jim.houston@ccur.com</span>
<a name="5" /><span class="True">       5:</span> <span class="k"> *    Copyright (C) 2002 by Concurrent Computer Corporation</span>
<a name="6" /><span class="True">       6:</span> <span class="k"> *    Distributed under the GNU GPL license version 2.</span>
<a name="7" /><span class="True">       7:</span> <span class="k"> *</span>
<a name="8" /><span class="True">       8:</span> <span class="k"> * Small id to pointer translation service avoiding fixed sized</span>
<a name="9" /><span class="True">       9:</span> <span class="k"> * tables.</span>
<a name="10" /><span class="True">      10:</span> <span class="k"> */</span>
<a name="11" /><span class="True">      11:</span> 
<a name="12" /><span class="True">      12:</span> <span class="f">#</span><span class="n">ifndef</span> <a href="cpu.c_macros_noref.html#_X19JRFJfSF9fXzA_"><span class="b">__IDR_H__</span></a>
<a name="13" /><span class="True">      13:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_X19JRFJfSF9fXzA_"><span class="b">__IDR_H__</span></a>
<a name="14" /><span class="True">      14:</span> 
<a name="15" /><span class="True">      15:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">types</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="16" /><span class="True">      16:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">bitops</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="17" /><span class="True">      17:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">init</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="18" /><span class="True">      18:</span> <span class="f">#</span><span class="n">include</span> <span class="f">&lt;</span><span class="b">linux</span><span class="f">/</span><span class="b">rcupdate</span><span class="f">.</span><span class="b">h</span><span class="f">&gt;</span>
<a name="19" /><span class="True">      19:</span> 
<a name="20" /><span class="True">      20:</span> <span class="k">/*</span>
<a name="21" /><span class="True">      21:</span> <span class="k"> * We want shallower trees and thus more bits covered at each layer.  8</span>
<a name="22" /><span class="True">      22:</span> <span class="k"> * bits gives us large enough first layer for most use cases and maximum</span>
<a name="23" /><span class="True">      23:</span> <span class="k"> * tree depth of 4.  Each idr_layer is slightly larger than 2k on 64bit and</span>
<a name="24" /><span class="True">      24:</span> <span class="k"> * 1k on 32bit.</span>
<a name="25" /><span class="True">      25:</span> <span class="k"> */</span>
<a name="26" /><span class="True">      26:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_SURSX0JJVFNfMA__"><span class="b">IDR_BITS</span></a> <span class="c">8</span>
<a name="27" /><span class="True">      27:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_SURSX1NJWkVfMA__"><span class="b">IDR_SIZE</span></a> <span class="f">(</span><span class="c">1</span> <span class="f">&lt;&lt;</span> <a href="cpu.c_macros_ref.html#_SURSX0JJVFNfMA__"><span class="b">IDR_BITS</span></a><span class="f">)</span>
<a name="28" /><span class="True">      28:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_SURSX01BU0tfMA__"><span class="b">IDR_MASK</span></a> <span class="f">(</span><span class="f">(</span><span class="c">1</span> <span class="f">&lt;&lt;</span> <a href="cpu.c_macros_ref.html#_SURSX0JJVFNfMA__"><span class="b">IDR_BITS</span></a><span class="f">)</span><span class="f">-</span><span class="c">1</span><span class="f">)</span>
<a name="29" /><span class="True">      29:</span> 
<a name="30" /><span class="True">      30:</span> <span class="m">struct</span> <span class="b">idr_layer</span> <span class="f">{</span>
<a name="31" /><span class="True">      31:</span>     <span class="m">int</span>            <span class="b">prefix</span><span class="f">;</span>    <span class="k">/* the ID prefix of this idr_layer */</span>
<a name="32" /><span class="True">      32:</span>     <a href="cpu.c_macros_ref.html#_REVDTEFSRV9CSVRNQVBfMA__"><span class="b">DECLARE_BITMAP</span></a><span class="f">(</span><span class="b">bitmap</span><span class="f">,</span> <a href="cpu.c_macros_ref.html#_SURSX1NJWkVfMA__"><span class="b">IDR_SIZE</span></a><span class="f">)</span><span class="f">;</span> <span class="k">/* A zero bit means &quot;space here&quot; */</span>
<a name="33" /><span class="True">      33:</span>     <span class="m">struct</span> <span class="b">idr_layer</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a>    <span class="f">*</span><span class="b">ary</span><span class="f">[</span><span class="c">1</span><span class="f">&lt;&lt;</span><a href="cpu.c_macros_ref.html#_SURSX0JJVFNfMA__"><span class="b">IDR_BITS</span></a><span class="f">]</span><span class="f">;</span>
<a name="34" /><span class="True">      34:</span>     <span class="m">int</span>            <span class="b">count</span><span class="f">;</span>    <span class="k">/* When zero, we can release it */</span>
<a name="35" /><span class="True">      35:</span>     <span class="m">int</span>            <span class="b">layer</span><span class="f">;</span>    <span class="k">/* distance from leaf */</span>
<a name="36" /><span class="True">      36:</span>     <span class="m">struct</span> <a href="cpu.c_macros_ref.html#_cmN1X2hlYWRfMA__"><span class="b">rcu_head</span></a>        <a href="cpu.c_macros_ref.html#_cmN1X2hlYWRfMA__"><span class="b">rcu_head</span></a><span class="f">;</span>
<a name="37" /><span class="True">      37:</span> <span class="f">}</span><span class="f">;</span>
<a name="38" /><span class="True">      38:</span> 
<a name="39" /><span class="True">      39:</span> <span class="m">struct</span> <span class="b">idr</span> <span class="f">{</span>
<a name="40" /><span class="True">      40:</span>     <span class="m">struct</span> <span class="b">idr_layer</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a>    <span class="f">*</span><span class="b">hint</span><span class="f">;</span>    <span class="k">/* the last layer allocated from */</span>
<a name="41" /><span class="True">      41:</span>     <span class="m">struct</span> <span class="b">idr_layer</span> <a href="cpu.c_macros_ref.html#_X19yY3VfMA__"><span class="b">__rcu</span></a>    <span class="f">*</span><span class="b">top</span><span class="f">;</span>
<a name="42" /><span class="True">      42:</span>     <span class="m">struct</span> <span class="b">idr_layer</span>    <span class="f">*</span><span class="b">id_free</span><span class="f">;</span>
<a name="43" /><span class="True">      43:</span>     <span class="m">int</span>            <span class="b">layers</span><span class="f">;</span>    <span class="k">/* only valid w/o concurrent changes */</span>
<a name="44" /><span class="True">      44:</span>     <span class="m">int</span>            <span class="b">id_free_cnt</span><span class="f">;</span>
<a name="45" /><span class="True">      45:</span>     <span class="m">int</span>            <span class="b">cur</span><span class="f">;</span>    <span class="k">/* current pos for cyclic allocation */</span>
<a name="46" /><span class="True">      46:</span>     <span class="b">spinlock_t</span>        <span class="b">lock</span><span class="f">;</span>
<a name="47" /><span class="True">      47:</span> <span class="f">}</span><span class="f">;</span>
<a name="48" /><span class="True">      48:</span> 
<a name="49" /><span class="True">      49:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_SURSX0lOSVRfMA__"><span class="b">IDR_INIT</span></a><span class="f">(</span><span class="b">name</span><span class="f">)</span>                            \
<a name="50" /><span class="True">      50:</span> <span class="f">{</span>                                    \
<a name="51" /><span class="True">      51:</span>     <span class="f">.</span><span class="b">lock</span>            <span class="f">=</span> <a href="cpu.c_macros_ref.html#_X19TUElOX0xPQ0tfVU5MT0NLRURfMA__"><span class="b">__SPIN_LOCK_UNLOCKED</span></a><span class="f">(</span><span class="b">name</span><span class="f">.</span><span class="b">lock</span><span class="f">)</span><span class="f">,</span>    \
<a name="52" /><span class="True">      52:</span> <span class="f">}</span>
<a name="53" /><span class="True">      53:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_REVGSU5FX0lEUl8w"><span class="b">DEFINE_IDR</span></a><span class="f">(</span><span class="b">name</span><span class="f">)</span>    <span class="m">struct</span> <span class="b">idr</span> <span class="b">name</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_SURSX0lOSVRfMA__"><span class="b">IDR_INIT</span></a><span class="f">(</span><span class="b">name</span><span class="f">)</span>
<a name="54" /><span class="True">      54:</span> 
<a name="55" /><span class="True">      55:</span> <span class="k">/**</span>
<a name="56" /><span class="True">      56:</span> <span class="k"> * DOC: idr sync</span>
<a name="57" /><span class="True">      57:</span> <span class="k"> * idr synchronization (stolen from radix-tree.h)</span>
<a name="58" /><span class="True">      58:</span> <span class="k"> *</span>
<a name="59" /><span class="True">      59:</span> <span class="k"> * idr_find() is able to be called locklessly, using RCU. The caller must</span>
<a name="60" /><span class="True">      60:</span> <span class="k"> * ensure calls to this function are made within rcu_read_lock() regions.</span>
<a name="61" /><span class="True">      61:</span> <span class="k"> * Other readers (lock-free or otherwise) and modifications may be running</span>
<a name="62" /><span class="True">      62:</span> <span class="k"> * concurrently.</span>
<a name="63" /><span class="True">      63:</span> <span class="k"> *</span>
<a name="64" /><span class="True">      64:</span> <span class="k"> * It is still required that the caller manage the synchronization and</span>
<a name="65" /><span class="True">      65:</span> <span class="k"> * lifetimes of the items. So if RCU lock-free lookups are used, typically</span>
<a name="66" /><span class="True">      66:</span> <span class="k"> * this would mean that the items have their own locks, or are amenable to</span>
<a name="67" /><span class="True">      67:</span> <span class="k"> * lock-free access; and that the items are freed by RCU (or only freed after</span>
<a name="68" /><span class="True">      68:</span> <span class="k"> * having been deleted from the idr tree *and* a synchronize_rcu() grace</span>
<a name="69" /><span class="True">      69:</span> <span class="k"> * period).</span>
<a name="70" /><span class="True">      70:</span> <span class="k"> */</span>
<a name="71" /><span class="True">      71:</span> 
<a name="72" /><span class="True">      72:</span> <span class="k">/*</span>
<a name="73" /><span class="True">      73:</span> <span class="k"> * This is what we export.</span>
<a name="74" /><span class="True">      74:</span> <span class="k"> */</span>
<a name="75" /><span class="True">      75:</span> 
<a name="76" /><span class="True">      76:</span> <span class="m">void</span> <span class="f">*</span><span class="b">idr_find_slowpath</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">int</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="77" /><span class="True">      77:</span> <span class="m">void</span> <span class="b">idr_preload</span><span class="f">(</span><span class="b">gfp_t</span> <span class="b">gfp_mask</span><span class="f">)</span><span class="f">;</span>
<a name="78" /><span class="True">      78:</span> <span class="m">int</span> <span class="b">idr_alloc</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">ptr</span><span class="f">,</span> <span class="m">int</span> <span class="b">start</span><span class="f">,</span> <span class="m">int</span> <span class="b">end</span><span class="f">,</span> <span class="b">gfp_t</span> <span class="b">gfp_mask</span><span class="f">)</span><span class="f">;</span>
<a name="79" /><span class="True">      79:</span> <span class="m">int</span> <span class="b">idr_alloc_cyclic</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idr</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">ptr</span><span class="f">,</span> <span class="m">int</span> <span class="b">start</span><span class="f">,</span> <span class="m">int</span> <span class="b">end</span><span class="f">,</span> <span class="b">gfp_t</span> <span class="b">gfp_mask</span><span class="f">)</span><span class="f">;</span>
<a name="80" /><span class="True">      80:</span> <span class="m">int</span> <span class="b">idr_for_each</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span>
<a name="81" /><span class="True">      81:</span>          <span class="m">int</span> <span class="f">(</span><span class="f">*</span><span class="b">fn</span><span class="f">)</span><span class="f">(</span><span class="m">int</span> <span class="b">id</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">p</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">data</span><span class="f">)</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">data</span><span class="f">)</span><span class="f">;</span>
<a name="82" /><span class="True">      82:</span> <span class="m">void</span> <span class="f">*</span><span class="b">idr_get_next</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">int</span> <span class="f">*</span><span class="b">nextid</span><span class="f">)</span><span class="f">;</span>
<a name="83" /><span class="True">      83:</span> <span class="m">void</span> <span class="f">*</span><span class="b">idr_replace</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">ptr</span><span class="f">,</span> <span class="m">int</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="84" /><span class="True">      84:</span> <span class="m">void</span> <span class="b">idr_remove</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">int</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="85" /><span class="True">      85:</span> <span class="m">void</span> <span class="b">idr_free</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">int</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="86" /><span class="True">      86:</span> <span class="m">void</span> <span class="b">idr_destroy</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">)</span><span class="f">;</span>
<a name="87" /><span class="True">      87:</span> <span class="m">void</span> <span class="b">idr_init</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">)</span><span class="f">;</span>
<a name="88" /><span class="True">      88:</span> 
<a name="89" /><span class="True">      89:</span> <span class="k">/**</span>
<a name="90" /><span class="True">      90:</span> <span class="k"> * idr_preload_end - end preload section started with idr_preload()</span>
<a name="91" /><span class="True">      91:</span> <span class="k"> *</span>
<a name="92" /><span class="True">      92:</span> <span class="k"> * Each idr_preload() should be matched with an invocation of this</span>
<a name="93" /><span class="True">      93:</span> <span class="k"> * function.  See idr_preload() for details.</span>
<a name="94" /><span class="True">      94:</span> <span class="k"> */</span>
<a name="95" /><span class="True">      95:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="b">idr_preload_end</span><span class="f">(</span><span class="m">void</span><span class="f">)</span>
<a name="96" /><span class="True">      96:</span> <span class="f">{</span>
<a name="97" /><span class="True">      97:</span>     <a href="cpu.c_macros_ref.html#_cHJlZW1wdF9lbmFibGVfMA__"><span class="b">preempt_enable</span></a><span class="f">(</span><span class="f">)</span><span class="f">;</span>
<a name="98" /><span class="True">      98:</span> <span class="f">}</span>
<a name="99" /><span class="True">      99:</span> 
<a name="100" /><span class="True">     100:</span> <span class="k">/**</span>
<a name="101" /><span class="True">     101:</span> <span class="k"> * idr_find - return pointer for given id</span>
<a name="102" /><span class="True">     102:</span> <span class="k"> * @idr: idr handle</span>
<a name="103" /><span class="True">     103:</span> <span class="k"> * @id: lookup key</span>
<a name="104" /><span class="True">     104:</span> <span class="k"> *</span>
<a name="105" /><span class="True">     105:</span> <span class="k"> * Return the pointer given the id it has been registered with.  A %NULL</span>
<a name="106" /><span class="True">     106:</span> <span class="k"> * return indicates that @id is not valid or you passed %NULL in</span>
<a name="107" /><span class="True">     107:</span> <span class="k"> * idr_get_new().</span>
<a name="108" /><span class="True">     108:</span> <span class="k"> *</span>
<a name="109" /><span class="True">     109:</span> <span class="k"> * This function can be called under rcu_read_lock(), given that the leaf</span>
<a name="110" /><span class="True">     110:</span> <span class="k"> * pointers lifetimes are correctly managed.</span>
<a name="111" /><span class="True">     111:</span> <span class="k"> */</span>
<a name="112" /><span class="True">     112:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <span class="f">*</span><span class="b">idr_find</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idr</span><span class="f">,</span> <span class="m">int</span> <span class="b">id</span><span class="f">)</span>
<a name="113" /><span class="True">     113:</span> <span class="f">{</span>
<a name="114" /><span class="True">     114:</span>     <span class="m">struct</span> <span class="b">idr_layer</span> <span class="f">*</span><span class="b">hint</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlX3Jhd18w"><span class="b">rcu_dereference_raw</span></a><span class="f">(</span><span class="b">idr</span><span class="f">-&gt;</span><span class="b">hint</span><span class="f">)</span><span class="f">;</span>
<a name="115" /><span class="True">     115:</span> 
<a name="116" /><span class="True">     116:</span>     <span class="m">if</span> <span class="f">(</span><span class="b">hint</span> <span class="f">&amp;&amp;</span> <span class="f">(</span><span class="b">id</span> <span class="f">&amp;</span> <span class="f">~</span><a href="cpu.c_macros_ref.html#_SURSX01BU0tfMA__"><span class="b">IDR_MASK</span></a><span class="f">)</span> <span class="f">==</span> <span class="b">hint</span><span class="f">-&gt;</span><span class="b">prefix</span><span class="f">)</span>
<a name="117" /><span class="True">     117:</span>         <span class="m">return</span> <a href="cpu.c_macros_ref.html#_cmN1X2RlcmVmZXJlbmNlX3Jhd18w"><span class="b">rcu_dereference_raw</span></a><span class="f">(</span><span class="b">hint</span><span class="f">-&gt;</span><span class="b">ary</span><span class="f">[</span><span class="b">id</span> <span class="f">&amp;</span> <a href="cpu.c_macros_ref.html#_SURSX01BU0tfMA__"><span class="b">IDR_MASK</span></a><span class="f">]</span><span class="f">)</span><span class="f">;</span>
<a name="118" /><span class="True">     118:</span> 
<a name="119" /><span class="True">     119:</span>     <span class="m">return</span> <span class="b">idr_find_slowpath</span><span class="f">(</span><span class="b">idr</span><span class="f">,</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="120" /><span class="True">     120:</span> <span class="f">}</span>
<a name="121" /><span class="True">     121:</span> 
<a name="122" /><span class="True">     122:</span> <span class="k">/**</span>
<a name="123" /><span class="True">     123:</span> <span class="k"> * idr_for_each_entry - iterate over an idr&apos;s elements of a given type</span>
<a name="124" /><span class="True">     124:</span> <span class="k"> * @idp:     idr handle</span>
<a name="125" /><span class="True">     125:</span> <span class="k"> * @entry:   the type * to use as cursor</span>
<a name="126" /><span class="True">     126:</span> <span class="k"> * @id:      id entry&apos;s key</span>
<a name="127" /><span class="True">     127:</span> <span class="k"> *</span>
<a name="128" /><span class="True">     128:</span> <span class="k"> * @entry and @id do not need to be initialized before the loop, and</span>
<a name="129" /><span class="True">     129:</span> <span class="k"> * after normal terminatinon @entry is left with the value NULL.  This</span>
<a name="130" /><span class="True">     130:</span> <span class="k"> * is convenient for a &quot;not found&quot; value.</span>
<a name="131" /><span class="True">     131:</span> <span class="k"> */</span>
<a name="132" /><span class="True">     132:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_aWRyX2Zvcl9lYWNoX2VudHJ5XzA_"><span class="b">idr_for_each_entry</span></a><span class="f">(</span><span class="b">idp</span><span class="f">,</span> <span class="b">entry</span><span class="f">,</span> <span class="b">id</span><span class="f">)</span>            \
<a name="133" /><span class="True">     133:</span>     <span class="m">for</span> <span class="f">(</span><span class="b">id</span> <span class="f">=</span> <span class="c">0</span><span class="f">;</span> <span class="f">(</span><span class="f">(</span><span class="b">entry</span><span class="f">)</span> <span class="f">=</span> <span class="b">idr_get_next</span><span class="f">(</span><span class="b">idp</span><span class="f">,</span> <span class="f">&amp;</span><span class="f">(</span><span class="b">id</span><span class="f">)</span><span class="f">)</span><span class="f">)</span> <span class="f">!=</span> <a href="cpu.c_macros_ref.html#_TlVMTF8w"><span class="b">NULL</span></a><span class="f">;</span> <span class="f">++</span><span class="b">id</span><span class="f">)</span>
<a name="134" /><span class="True">     134:</span> 
<a name="135" /><span class="True">     135:</span> <span class="k">/*</span>
<a name="136" /><span class="True">     136:</span> <span class="k"> * Don&apos;t use the following functions.  These exist only to suppress</span>
<a name="137" /><span class="True">     137:</span> <span class="k"> * deprecated warnings on EXPORT_SYMBOL()s.</span>
<a name="138" /><span class="True">     138:</span> <span class="k"> */</span>
<a name="139" /><span class="True">     139:</span> <span class="m">int</span> <span class="b">__idr_pre_get</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="b">gfp_t</span> <span class="b">gfp_mask</span><span class="f">)</span><span class="f">;</span>
<a name="140" /><span class="True">     140:</span> <span class="m">int</span> <span class="b">__idr_get_new_above</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">ptr</span><span class="f">,</span> <span class="m">int</span> <span class="b">starting_id</span><span class="f">,</span> <span class="m">int</span> <span class="f">*</span><span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="141" /><span class="True">     141:</span> <span class="m">void</span> <span class="b">__idr_remove_all</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">)</span><span class="f">;</span>
<a name="142" /><span class="True">     142:</span> 
<a name="143" /><span class="True">     143:</span> <span class="k">/**</span>
<a name="144" /><span class="True">     144:</span> <span class="k"> * idr_pre_get - reserve resources for idr allocation</span>
<a name="145" /><span class="True">     145:</span> <span class="k"> * @idp:    idr handle</span>
<a name="146" /><span class="True">     146:</span> <span class="k"> * @gfp_mask:    memory allocation flags</span>
<a name="147" /><span class="True">     147:</span> <span class="k"> *</span>
<a name="148" /><span class="True">     148:</span> <span class="k"> * Part of old alloc interface.  This is going away.  Use</span>
<a name="149" /><span class="True">     149:</span> <span class="k"> * idr_preload[_end]() and idr_alloc() instead.</span>
<a name="150" /><span class="True">     150:</span> <span class="k"> */</span>
<a name="151" /><span class="True">     151:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">int</span> <a href="cpu.c_macros_ref.html#_X19kZXByZWNhdGVkXzE_"><span class="b">__deprecated</span></a> <span class="b">idr_pre_get</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="b">gfp_t</span> <span class="b">gfp_mask</span><span class="f">)</span>
<a name="152" /><span class="True">     152:</span> <span class="f">{</span>
<a name="153" /><span class="True">     153:</span>     <span class="m">return</span> <span class="b">__idr_pre_get</span><span class="f">(</span><span class="b">idp</span><span class="f">,</span> <span class="b">gfp_mask</span><span class="f">)</span><span class="f">;</span>
<a name="154" /><span class="True">     154:</span> <span class="f">}</span>
<a name="155" /><span class="True">     155:</span> 
<a name="156" /><span class="True">     156:</span> <span class="k">/**</span>
<a name="157" /><span class="True">     157:</span> <span class="k"> * idr_get_new_above - allocate new idr entry above or equal to a start id</span>
<a name="158" /><span class="True">     158:</span> <span class="k"> * @idp: idr handle</span>
<a name="159" /><span class="True">     159:</span> <span class="k"> * @ptr: pointer you want associated with the id</span>
<a name="160" /><span class="True">     160:</span> <span class="k"> * @starting_id: id to start search at</span>
<a name="161" /><span class="True">     161:</span> <span class="k"> * @id: pointer to the allocated handle</span>
<a name="162" /><span class="True">     162:</span> <span class="k"> *</span>
<a name="163" /><span class="True">     163:</span> <span class="k"> * Part of old alloc interface.  This is going away.  Use</span>
<a name="164" /><span class="True">     164:</span> <span class="k"> * idr_preload[_end]() and idr_alloc() instead.</span>
<a name="165" /><span class="True">     165:</span> <span class="k"> */</span>
<a name="166" /><span class="True">     166:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">int</span> <a href="cpu.c_macros_ref.html#_X19kZXByZWNhdGVkXzE_"><span class="b">__deprecated</span></a> <span class="b">idr_get_new_above</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">ptr</span><span class="f">,</span>
<a name="167" /><span class="True">     167:</span>                          <span class="m">int</span> <span class="b">starting_id</span><span class="f">,</span> <span class="m">int</span> <span class="f">*</span><span class="b">id</span><span class="f">)</span>
<a name="168" /><span class="True">     168:</span> <span class="f">{</span>
<a name="169" /><span class="True">     169:</span>     <span class="m">return</span> <span class="b">__idr_get_new_above</span><span class="f">(</span><span class="b">idp</span><span class="f">,</span> <span class="b">ptr</span><span class="f">,</span> <span class="b">starting_id</span><span class="f">,</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="170" /><span class="True">     170:</span> <span class="f">}</span>
<a name="171" /><span class="True">     171:</span> 
<a name="172" /><span class="True">     172:</span> <span class="k">/**</span>
<a name="173" /><span class="True">     173:</span> <span class="k"> * idr_get_new - allocate new idr entry</span>
<a name="174" /><span class="True">     174:</span> <span class="k"> * @idp: idr handle</span>
<a name="175" /><span class="True">     175:</span> <span class="k"> * @ptr: pointer you want associated with the id</span>
<a name="176" /><span class="True">     176:</span> <span class="k"> * @id: pointer to the allocated handle</span>
<a name="177" /><span class="True">     177:</span> <span class="k"> *</span>
<a name="178" /><span class="True">     178:</span> <span class="k"> * Part of old alloc interface.  This is going away.  Use</span>
<a name="179" /><span class="True">     179:</span> <span class="k"> * idr_preload[_end]() and idr_alloc() instead.</span>
<a name="180" /><span class="True">     180:</span> <span class="k"> */</span>
<a name="181" /><span class="True">     181:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">int</span> <a href="cpu.c_macros_ref.html#_X19kZXByZWNhdGVkXzE_"><span class="b">__deprecated</span></a> <span class="b">idr_get_new</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">,</span> <span class="m">void</span> <span class="f">*</span><span class="b">ptr</span><span class="f">,</span> <span class="m">int</span> <span class="f">*</span><span class="b">id</span><span class="f">)</span>
<a name="182" /><span class="True">     182:</span> <span class="f">{</span>
<a name="183" /><span class="True">     183:</span>     <span class="m">return</span> <span class="b">__idr_get_new_above</span><span class="f">(</span><span class="b">idp</span><span class="f">,</span> <span class="b">ptr</span><span class="f">,</span> <span class="c">0</span><span class="f">,</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="184" /><span class="True">     184:</span> <span class="f">}</span>
<a name="185" /><span class="True">     185:</span> 
<a name="186" /><span class="True">     186:</span> <span class="k">/**</span>
<a name="187" /><span class="True">     187:</span> <span class="k"> * idr_remove_all - remove all ids from the given idr tree</span>
<a name="188" /><span class="True">     188:</span> <span class="k"> * @idp: idr handle</span>
<a name="189" /><span class="True">     189:</span> <span class="k"> *</span>
<a name="190" /><span class="True">     190:</span> <span class="k"> * If you&apos;re trying to destroy @idp, calling idr_destroy() is enough.</span>
<a name="191" /><span class="True">     191:</span> <span class="k"> * This is going away.  Don&apos;t use.</span>
<a name="192" /><span class="True">     192:</span> <span class="k"> */</span>
<a name="193" /><span class="True">     193:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">void</span> <a href="cpu.c_macros_ref.html#_X19kZXByZWNhdGVkXzE_"><span class="b">__deprecated</span></a> <span class="b">idr_remove_all</span><span class="f">(</span><span class="m">struct</span> <span class="b">idr</span> <span class="f">*</span><span class="b">idp</span><span class="f">)</span>
<a name="194" /><span class="True">     194:</span> <span class="f">{</span>
<a name="195" /><span class="True">     195:</span>     <span class="b">__idr_remove_all</span><span class="f">(</span><span class="b">idp</span><span class="f">)</span><span class="f">;</span>
<a name="196" /><span class="True">     196:</span> <span class="f">}</span>
<a name="197" /><span class="True">     197:</span> 
<a name="198" /><span class="True">     198:</span> <span class="k">/*</span>
<a name="199" /><span class="True">     199:</span> <span class="k"> * IDA - IDR based id allocator, use when translation from id to</span>
<a name="200" /><span class="True">     200:</span> <span class="k"> * pointer isn&apos;t necessary.</span>
<a name="201" /><span class="True">     201:</span> <span class="k"> *</span>
<a name="202" /><span class="True">     202:</span> <span class="k"> * IDA_BITMAP_LONGS is calculated to be one less to accommodate</span>
<a name="203" /><span class="True">     203:</span> <span class="k"> * ida_bitmap-&gt;nr_busy so that the whole struct fits in 128 bytes.</span>
<a name="204" /><span class="True">     204:</span> <span class="k"> */</span>
<a name="205" /><span class="True">     205:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_SURBX0NIVU5LX1NJWkVfMA__"><span class="b">IDA_CHUNK_SIZE</span></a>        <span class="c">128</span>    <span class="k">/* 128 bytes per chunk */</span>
<a name="206" /><span class="True">     206:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_ref.html#_SURBX0JJVE1BUF9MT05HU18w"><span class="b">IDA_BITMAP_LONGS</span></a>    <span class="f">(</span><a href="cpu.c_macros_ref.html#_SURBX0NIVU5LX1NJWkVfMA__"><span class="b">IDA_CHUNK_SIZE</span></a> <span class="f">/</span> <span class="m">sizeof</span><span class="f">(</span><span class="m">long</span><span class="f">)</span> <span class="f">-</span> <span class="c">1</span><span class="f">)</span>
<a name="207" /><span class="True">     207:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_SURBX0JJVE1BUF9CSVRTXzA_"><span class="b">IDA_BITMAP_BITS</span></a>     <span class="f">(</span><a href="cpu.c_macros_ref.html#_SURBX0JJVE1BUF9MT05HU18w"><span class="b">IDA_BITMAP_LONGS</span></a> <span class="f">*</span> <span class="m">sizeof</span><span class="f">(</span><span class="m">long</span><span class="f">)</span> <span class="f">*</span> <span class="c">8</span><span class="f">)</span>
<a name="208" /><span class="True">     208:</span> 
<a name="209" /><span class="True">     209:</span> <span class="m">struct</span> <span class="b">ida_bitmap</span> <span class="f">{</span>
<a name="210" /><span class="True">     210:</span>     <span class="m">long</span>            <span class="b">nr_busy</span><span class="f">;</span>
<a name="211" /><span class="True">     211:</span>     <span class="m">unsigned</span> <span class="m">long</span>        <span class="b">bitmap</span><span class="f">[</span><a href="cpu.c_macros_ref.html#_SURBX0JJVE1BUF9MT05HU18w"><span class="b">IDA_BITMAP_LONGS</span></a><span class="f">]</span><span class="f">;</span>
<a name="212" /><span class="True">     212:</span> <span class="f">}</span><span class="f">;</span>
<a name="213" /><span class="True">     213:</span> 
<a name="214" /><span class="True">     214:</span> <span class="m">struct</span> <span class="b">ida</span> <span class="f">{</span>
<a name="215" /><span class="True">     215:</span>     <span class="m">struct</span> <span class="b">idr</span>        <span class="b">idr</span><span class="f">;</span>
<a name="216" /><span class="True">     216:</span>     <span class="m">struct</span> <span class="b">ida_bitmap</span>    <span class="f">*</span><span class="b">free_bitmap</span><span class="f">;</span>
<a name="217" /><span class="True">     217:</span> <span class="f">}</span><span class="f">;</span>
<a name="218" /><span class="True">     218:</span> 
<a name="219" /><span class="True">     219:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_SURBX0lOSVRfMA__"><span class="b">IDA_INIT</span></a><span class="f">(</span><span class="b">name</span><span class="f">)</span>        <span class="f">{</span> <span class="f">.</span><span class="b">idr</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_SURSX0lOSVRfMA__"><span class="b">IDR_INIT</span></a><span class="f">(</span><span class="f">(</span><span class="b">name</span><span class="f">)</span><span class="f">.</span><span class="b">idr</span><span class="f">)</span><span class="f">,</span> <span class="f">.</span><span class="b">free_bitmap</span> <span class="f">=</span> <a href="cpu.c_macros_ref.html#_TlVMTF8w"><span class="b">NULL</span></a><span class="f">,</span> <span class="f">}</span>
<a name="220" /><span class="True">     220:</span> <span class="f">#</span><span class="n">define</span> <a href="cpu.c_macros_noref.html#_REVGSU5FX0lEQV8w"><span class="b">DEFINE_IDA</span></a><span class="f">(</span><span class="b">name</span><span class="f">)</span>    <span class="m">struct</span> <span class="b">ida</span> <span class="b">name</span> <span class="f">=</span> <a href="cpu.c_macros_noref.html#_SURBX0lOSVRfMA__"><span class="b">IDA_INIT</span></a><span class="f">(</span><span class="b">name</span><span class="f">)</span>
<a name="221" /><span class="True">     221:</span> 
<a name="222" /><span class="True">     222:</span> <span class="m">int</span> <span class="b">ida_pre_get</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">,</span> <span class="b">gfp_t</span> <span class="b">gfp_mask</span><span class="f">)</span><span class="f">;</span>
<a name="223" /><span class="True">     223:</span> <span class="m">int</span> <span class="b">ida_get_new_above</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">,</span> <span class="m">int</span> <span class="b">starting_id</span><span class="f">,</span> <span class="m">int</span> <span class="f">*</span><span class="b">p_id</span><span class="f">)</span><span class="f">;</span>
<a name="224" /><span class="True">     224:</span> <span class="m">void</span> <span class="b">ida_remove</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">,</span> <span class="m">int</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="225" /><span class="True">     225:</span> <span class="m">void</span> <span class="b">ida_destroy</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">)</span><span class="f">;</span>
<a name="226" /><span class="True">     226:</span> <span class="m">void</span> <span class="b">ida_init</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">)</span><span class="f">;</span>
<a name="227" /><span class="True">     227:</span> 
<a name="228" /><span class="True">     228:</span> <span class="m">int</span> <span class="b">ida_simple_get</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">,</span> <span class="m">unsigned</span> <span class="m">int</span> <span class="b">start</span><span class="f">,</span> <span class="m">unsigned</span> <span class="m">int</span> <span class="b">end</span><span class="f">,</span>
<a name="229" /><span class="True">     229:</span>            <span class="b">gfp_t</span> <span class="b">gfp_mask</span><span class="f">)</span><span class="f">;</span>
<a name="230" /><span class="True">     230:</span> <span class="m">void</span> <span class="b">ida_simple_remove</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">,</span> <span class="m">unsigned</span> <span class="m">int</span> <span class="b">id</span><span class="f">)</span><span class="f">;</span>
<a name="231" /><span class="True">     231:</span> 
<a name="232" /><span class="True">     232:</span> <span class="k">/**</span>
<a name="233" /><span class="True">     233:</span> <span class="k"> * ida_get_new - allocate new ID</span>
<a name="234" /><span class="True">     234:</span> <span class="k"> * @ida:    idr handle</span>
<a name="235" /><span class="True">     235:</span> <span class="k"> * @p_id:    pointer to the allocated handle</span>
<a name="236" /><span class="True">     236:</span> <span class="k"> *</span>
<a name="237" /><span class="True">     237:</span> <span class="k"> * Simple wrapper around ida_get_new_above() w/ @starting_id of zero.</span>
<a name="238" /><span class="True">     238:</span> <span class="k"> */</span>
<a name="239" /><span class="True">     239:</span> <span class="m">static</span> <span class="m">inline</span> <span class="m">int</span> <span class="b">ida_get_new</span><span class="f">(</span><span class="m">struct</span> <span class="b">ida</span> <span class="f">*</span><span class="b">ida</span><span class="f">,</span> <span class="m">int</span> <span class="f">*</span><span class="b">p_id</span><span class="f">)</span>
<a name="240" /><span class="True">     240:</span> <span class="f">{</span>
<a name="241" /><span class="True">     241:</span>     <span class="m">return</span> <span class="b">ida_get_new_above</span><span class="f">(</span><span class="b">ida</span><span class="f">,</span> <span class="c">0</span><span class="f">,</span> <span class="b">p_id</span><span class="f">)</span><span class="f">;</span>
<a name="242" /><span class="True">     242:</span> <span class="f">}</span>
<a name="243" /><span class="True">     243:</span> 
<a name="244" /><span class="True">     244:</span> <span class="m">void</span> <a href="cpu.c_macros_ref.html#_X19pbml0XzA_"><span class="b">__init</span></a> <span class="b">idr_init_cache</span><span class="f">(</span><span class="m">void</span><span class="f">)</span><span class="f">;</span>
<a name="245" /><span class="True">     245:</span> 
<a name="246" /><span class="True">     246:</span> <span class="f">#</span><span class="n">endif</span> <span class="k">/* __IDR_H__ */</span>
<a name="247" /><span class="True">     247:</span> </pre>
  </body>
</html>
