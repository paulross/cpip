

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CPIP Reference &mdash; CPIP v0.8.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="CPIP v0.8.0 documentation" href="index.html" />
    <link rel="prev" title="FileIncludeGraph Tutorial" href="tutorial/FileIncGraph.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial/FileIncGraph.html" title="FileIncludeGraph Tutorial"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">CPIP v0.8.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cpip-reference">
<h1>CPIP Reference<a class="headerlink" href="#cpip-reference" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<p><strong>BEWARE: Sadly Sphinx is not smart enought to scan all existing modules for itself so this list of reference documentation has to be maintained by hand. That is a tedious, error prone and distracting. There may be important modules in CPIP that do not appear here and modules documented here that no longer exist. Rather than relying on structured documentation you might prefer to use Sphinx&#8217;s fine search facility: see &#8220;Quick search&#8221; to your left.</strong></p>
<p><strong>Oh, for a decent Python documentation system that reflected code structure and was, well, automatic.</strong></p>
<p>cpip.core:</p>
<span class="target" id="module-cpip.core.ConstantExpression"></span><p>Handles the Python interpretation of a constant-expression.
See ISO/IEC 14882:1998(E)</p>
<dl class="class">
<dt id="cpip.core.ConstantExpression.ConstantExpression">
<em class="property">class </em><tt class="descclassname">cpip.core.ConstantExpression.</tt><tt class="descname">ConstantExpression</tt><big>(</big><em>theTokTypeS</em><big>)</big><a class="headerlink" href="#cpip.core.ConstantExpression.ConstantExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that interpret a stream of preprocessing tokens (class PpToken)
and evaluate it as a constant expression.</p>
<dl class="method">
<dt id="cpip.core.ConstantExpression.ConstantExpression.evaluate">
<tt class="descname">evaluate</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.ConstantExpression.ConstantExpression.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the constant expression and returns 0 or 1.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.ConstantExpression.ConstantExpression.translateTokensToString">
<tt class="descname">translateTokensToString</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.ConstantExpression.ConstantExpression.translateTokensToString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string to be evaluated as a constant-expression.
ISO/IEC ISO/IEC 14882:1998(E) 16.1 Conditional inclusion sub-section 4
i.e. 16.1-4</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="cpip.core.ConstantExpression.ExceptionConditionalExpression">
<em class="property">exception </em><tt class="descclassname">cpip.core.ConstantExpression.</tt><tt class="descname">ExceptionConditionalExpression</tt><a class="headerlink" href="#cpip.core.ConstantExpression.ExceptionConditionalExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when conditional expression e.g. ... ? ... : ... fails to evaluate.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.ConstantExpression.ExceptionConditionalExpressionInit">
<em class="property">exception </em><tt class="descclassname">cpip.core.ConstantExpression.</tt><tt class="descname">ExceptionConditionalExpressionInit</tt><a class="headerlink" href="#cpip.core.ConstantExpression.ExceptionConditionalExpressionInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when initialising a ConstantExpression class.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.ConstantExpression.ExceptionConstantExpression">
<em class="property">exception </em><tt class="descclassname">cpip.core.ConstantExpression.</tt><tt class="descname">ExceptionConstantExpression</tt><a class="headerlink" href="#cpip.core.ConstantExpression.ExceptionConstantExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for the ConstantExpression classes.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.ConstantExpression.ExceptionEvaluateExpression">
<em class="property">exception </em><tt class="descclassname">cpip.core.ConstantExpression.</tt><tt class="descname">ExceptionEvaluateExpression</tt><a class="headerlink" href="#cpip.core.ConstantExpression.ExceptionEvaluateExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when conditional expression e.g. 1 &lt; 2 fails to evaluate.</p>
</dd></dl>

<span class="target" id="module-cpip.core.CppCond"></span><p>Provides a state stack of booleans to facilitate conditional compilation as:
ISO/IEC 9899:1999(E) section 6.10.1 (&#8216;C&#8217;) and  ISO/IEC 14882:1998(E) section 16.1 (&#8216;C++&#8217;) [cpp.cond]</p>
<p>This does not interpret any semantics of either standard but instead provides
a state class that callers that do interpret the language semantics can use.</p>
<p>In particular this provides state change operations that might be triggered by
the following six pre-processing directives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#if constant-expression new-line group opt</span>
<span class="c">#ifdef identifier new-line group opt</span>
<span class="c">#ifndef identifier new-line group opt</span>
<span class="c">#elif constant-expression new-line group opt</span>
<span class="c">#else new-line group opt</span>
<span class="c">#endif new-line</span>
</pre></div>
</div>
<p>In this module a single CppCond object has a stack of ConditionalState objects.
The latter has both a boolean state and an &#8216;explanation&#8217; of that state at any
point in the translation.
The latter is represented by a list of string representations of either
constant-expression or identifier tokens.</p>
<p>The stack i.e. CppCond can also be queried for its net boolean state and its
net &#8216;explanation&#8217;.</p>
<dl class="docutils">
<dt>Basic boolean stack operations ::</dt>
<dd>Directive   Argument                Stack, s, boolean operation
&#8212;&#8212;&#8212;   &#8212;&#8212;&#8211;                &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
#if         constant-expression     s.push(bool)
#ifdef      identifier              s.push(bool)
#ifndef     identifier              s.push(!bool)
#elif       constant-expression     s.pop(), s.push(bool)
#else       N/A                     Either s.push(!s.pop()) or s.flip()
#endif      N/A                     s.pop()</dd>
</dl>
<p>Basic boolean &#8216;explanation&#8217; string operations:
NOTE: The &#8216;!&#8217; prefix is parameterised as TOKEN_NEGATION so that any subsequent
processing can recognise &#8216;!!&#8217; as &#8216;&#8217; and &#8216;!!!&#8217; as &#8216;!&#8217;.</p>
<div class="highlight-python"><pre>Directive   Argument                Matrix, m, strings
---------   --------                ------------------
#if         constant-expression     m.push(['%s' % tokens,])
#ifdef      identifier              m.push(['(defined %s)' % identifier)])
#ifndef     identifier              m.push(['!(defined %s)' % identifier)])
#elif       constant-expression     m[-1].push('!%s' % m[-1].pop()),
                                    m[-1].push(['%s' % tokens,])
                                    Note: Here we flip the existing state via
                                    a push(!pop())) then push the additional
                                    condition so that we have multiple
                                    contitions that are and'd together.
#else       N/A                     m[-1].push('!%s' % m[-1].pop())
                                    Note: This is the negation of the sum of
                                    the previous #if, #elif statements.
#endif      N/A                     m.pop()</pre>
</div>
<p>Note: The above does not include error checking such as pop() from
an empty stack.</p>
<p>Stringifying the matrix m:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flatList</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">aList</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># Add parenthesis so that when flatList is flattened then booleans are</span>
        <span class="c"># correctly protected.</span>
        <span class="n">flatList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="s">&#39; &amp;&amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aList</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flatList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">return</span> <span class="s">&#39; &amp;&amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">flatList</span><span class="p">)</span>
</pre></div>
</div>
<p>This returns for something like m is: <tt class="docutils literal"><span class="pre">[['a</span> <span class="pre">&lt;</span> <span class="pre">0',],</span> <span class="pre">['!b',</span> <span class="pre">'c</span> <span class="pre">&gt;</span> <span class="pre">45'],</span> <span class="pre">['d</span> <span class="pre">&lt;</span> <span class="pre">27',],]</span></tt></p>
<p>Then this gives: <tt class="docutils literal"><span class="pre">&quot;a</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">(!b</span> <span class="pre">&amp;&amp;</span> <span class="pre">c</span> <span class="pre">&gt;</span> <span class="pre">45)</span> <span class="pre">&amp;&amp;</span> <span class="pre">d</span> <span class="pre">&lt;</span> <span class="pre">27&quot;</span></tt></p>
<p>CppCondGraph adds file/line tracing so that we know where the conditional
state was set.
This would mean the PpLexer adding a FileLineCol as a argument to
oIf() etc. Then this gets passed to ConditionalState.__init__().
Also instead of a PpLexer passing str(CppCond) it passes deepcopy of CppCond.
There will be a performance hit here, might it be significant?</p>
<dl class="class">
<dt id="cpip.core.CppCond.ConditionalState">
<em class="property">class </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">ConditionalState</tt><big>(</big><em>theState</em>, <em>theIdOrCondExpr</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.ConditionalState" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds a single conditional state.</p>
<dl class="method">
<dt id="cpip.core.CppCond.ConditionalState.constExprStr">
<tt class="descname">constExprStr</tt><big>(</big><em>invert=False</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.ConditionalState.constExprStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self as a string which is the concatenation of constant-expressions.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.ConditionalState.flip">
<tt class="descname">flip</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.CppCond.ConditionalState.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts the boolean such as for #else directive.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.ConditionalState.flipAndAdd">
<tt class="descname">flipAndAdd</tt><big>(</big><em>theBool</em>, <em>theConstExpr</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.ConditionalState.flipAndAdd" title="Permalink to this definition">¶</a></dt>
<dd><p>This handles an #elif command on this item in the stack.
This flips the state (if theBool is True) and negates the last
expression on the condition list then appends theConstExpr
onto the condition list.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.ConditionalState.negateLastState">
<tt class="descname">negateLastState</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.CppCond.ConditionalState.negateLastState" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts the state of the last item on the stack.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.CppCond.ConditionalState.state">
<tt class="descname">state</tt><a class="headerlink" href="#cpip.core.CppCond.ConditionalState.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean state of self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.CppCond.CppCond">
<em class="property">class </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">CppCond</tt><a class="headerlink" href="#cpip.core.CppCond.CppCond" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a state stack to handle conditional compilation.
This could be used by an implementation of conditional inclusion e.g.
ISO/IEC 14882:1998(E) section 16.1 Conditional inclusion [cpp.cond]
Essentially this class provides a state machine that can be created altered
and queried.
The APIs available to the caller correspond to the if-section part of the
the applicable standard (i.e. #if #elif etc). Most APIs take two arguments;</p>
<dl class="docutils">
<dt>theBool</dt>
<dd>Is a boolean that is the result of the callers evaluation of a
constant-expression.</dd>
<dt>theIce</dt>
<dd>A string that represents the identifier or constant-expression
in a way that the caller sees fit (i.e. this is not evaluated
locally in any way).
Combinations of such strings _are_ merged by use of boolean
logic (&#8216;!&#8217;) and <tt class="docutils literal"><span class="pre">LPAREN</span></tt> and <tt class="docutils literal"><span class="pre">RPAREN</span></tt>.</dd>
</dl>
<dl class="method">
<dt id="cpip.core.CppCond.CppCond.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalisation, may raise ExceptionCppCond is stack non-empty.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCond.isTrue">
<tt class="descname">isTrue</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.isTrue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if all of the states in the stack are True, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCond.oElif">
<tt class="descname">oElif</tt><big>(</big><em>theBool</em>, <em>theConstExpr</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.oElif" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#elif</span></tt>.</p>
<p><em>theBool</em> Is a boolean that is the result of the callers evaluation of a
constant-expression.</p>
<p><em>theConstExpr</em> A string that represents the identifier or
constant-expression in a way that the caller sees fit (i.e. this is not
evaluated locally in any way).
Combinations of such strings _are_ merged by use of boolean
logic (&#8216;!&#8217;) and <tt class="docutils literal"><span class="pre">LPAREN</span></tt> and <tt class="docutils literal"><span class="pre">RPAREN</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCond.oElse">
<tt class="descname">oElse</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.oElse" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#else</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCond.oEndif">
<tt class="descname">oEndif</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.oEndif" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#endif</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCond.oIf">
<tt class="descname">oIf</tt><big>(</big><em>theBool</em>, <em>theConstExpr</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.oIf" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#if</span></tt>.</p>
<p><em>theBool</em> Is a boolean that is the result of the callers evaluation of a
constant-expression.</p>
<p><em>theConstExpr</em> A string that represents the identifier or
constant-expression in a way that the caller sees fit (i.e. this is not
evaluated locally in any way).
Combinations of such strings _are_ merged by use of boolean
logic (&#8216;!&#8217;) and <tt class="docutils literal"><span class="pre">LPAREN</span></tt> and <tt class="docutils literal"><span class="pre">RPAREN</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCond.oIfdef">
<tt class="descname">oIfdef</tt><big>(</big><em>theBool</em>, <em>theConstExpr</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.oIfdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#ifdef</span></tt>.</p>
<p><em>theBool</em> Is a boolean that is the result of the callers evaluation of a
constant-expression.</p>
<p><em>theConstExpr</em> A string that represents the identifier or
constant-expression in a way that the caller sees fit (i.e. this is not
evaluated locally in any way).
Combinations of such strings _are_ merged by use of boolean
logic (&#8216;!&#8217;) and <tt class="docutils literal"><span class="pre">LPAREN</span></tt> and <tt class="docutils literal"><span class="pre">RPAREN</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCond.oIfndef">
<tt class="descname">oIfndef</tt><big>(</big><em>theBool</em>, <em>theConstExpr</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCond.oIfndef" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#ifndef</span></tt>.</p>
<p><em>theBool</em> Is a boolean that is the result of the callers evaluation of a
constant-expression.</p>
<p><em>theConstExpr</em> A string that represents the identifier or
constant-expression in a way that the caller sees fit (i.e. this is not
evaluated locally in any way).
Combinations of such strings _are_ merged by use of boolean
logic (&#8216;!&#8217;) and <tt class="docutils literal"><span class="pre">LPAREN</span></tt> and <tt class="docutils literal"><span class="pre">RPAREN</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.CppCond.CppCond.stackDepth">
<tt class="descname">stackDepth</tt><a class="headerlink" href="#cpip.core.CppCond.CppCond.stackDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the depth of the conditional stack as an integer.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.CppCond.CppCondGraph">
<em class="property">class </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">CppCondGraph</tt><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a graph of conditional preprocessing directives.</p>
<dl class="attribute">
<dt id="cpip.core.CppCond.CppCondGraph.isComplete">
<tt class="descname">isComplete</tt><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.isComplete" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the last if-section, if present is completed with an #endif.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraph.oElif">
<tt class="descname">oElif</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.oElif" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#elif</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraph.oElse">
<tt class="descname">oElse</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.oElse" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#else</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraph.oEndif">
<tt class="descname">oEndif</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.oEndif" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#endif</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraph.oIf">
<tt class="descname">oIf</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.oIf" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#if</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraph.oIfdef">
<tt class="descname">oIfdef</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.oIfdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#ifdef</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraph.oIfndef">
<tt class="descname">oIfndef</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.oIfndef" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#ifndef</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraph.visit">
<tt class="descname">visit</tt><big>(</big><em>theVisitor</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraph.visit" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a visitor object and pass it around giving it each
CppCondGraphNode object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.CppCond.CppCondGraphNode">
<em class="property">class </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">CppCondGraphNode</tt><big>(</big><em>theCppDirective</em>, <em>theFileLineCol</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theConstExpr=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all nodes in the CppCondGraph.</p>
<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.canAccept">
<tt class="descname">canAccept</tt><big>(</big><em>theCppD</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.canAccept" title="Permalink to this definition">¶</a></dt>
<dd><p>True if I can accept a Preprocessing Directive; theCppD.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.oElif">
<tt class="descname">oElif</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.oElif" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#elif</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.oElse">
<tt class="descname">oElse</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.oElse" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#else</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.oEndif">
<tt class="descname">oEndif</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.oEndif" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#endif</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.oIf">
<tt class="descname">oIf</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.oIf" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#if</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.oIfdef">
<tt class="descname">oIfdef</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.oIfdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#ifdef</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.oIfndef">
<tt class="descname">oIfndef</tt><big>(</big><em>theFlc</em>, <em>theTuIdx</em>, <em>theBool</em>, <em>theCe</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.oIfndef" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with the result of a <tt class="docutils literal"><span class="pre">#ifndef</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.retStrList">
<tt class="descname">retStrList</tt><big>(</big><em>theDepth</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.retStrList" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of string representation.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphNode.visit">
<tt class="descname">visit</tt><big>(</big><em>theVisitor</em>, <em>theDepth</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphNode.visit" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a visitor object make the pre/post calls.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.CppCond.CppCondGraphVisitorBase">
<em class="property">class </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">CppCondGraphVisitorBase</tt><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphVisitorBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for a CppCondGraph visitor object.</p>
<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphVisitorBase.visitPost">
<tt class="descname">visitPost</tt><big>(</big><em>theCcgNode</em>, <em>theDepth</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphVisitorBase.visitPost" title="Permalink to this definition">¶</a></dt>
<dd><p>Post-traversal call with a CppCondGraphNode and the integer depth in
the tree.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppCond.CppCondGraphVisitorBase.visitPre">
<tt class="descname">visitPre</tt><big>(</big><em>theCcgNode</em>, <em>theDepth</em><big>)</big><a class="headerlink" href="#cpip.core.CppCond.CppCondGraphVisitorBase.visitPre" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-traversal call with a CppCondGraphNode and the integer depth in
the tree.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppCond.ExceptionCppCond">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">ExceptionCppCond</tt><a class="headerlink" href="#cpip.core.CppCond.ExceptionCppCond" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for the CppCond.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppCond.ExceptionCppCondGraph">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">ExceptionCppCondGraph</tt><a class="headerlink" href="#cpip.core.CppCond.ExceptionCppCondGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for the CppCondGraph.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppCond.ExceptionCppCondGraphElif">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">ExceptionCppCondGraphElif</tt><a class="headerlink" href="#cpip.core.CppCond.ExceptionCppCondGraphElif" title="Permalink to this definition">¶</a></dt>
<dd><p>When the CppCondGraph sees an #elif preprocessing directive in the wrong sequence.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppCond.ExceptionCppCondGraphElse">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">ExceptionCppCondGraphElse</tt><a class="headerlink" href="#cpip.core.CppCond.ExceptionCppCondGraphElse" title="Permalink to this definition">¶</a></dt>
<dd><p>When the CppCondGraph sees an #endif preprocessing directive in the wrong sequence.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppCond.ExceptionCppCondGraphIfSection">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">ExceptionCppCondGraphIfSection</tt><a class="headerlink" href="#cpip.core.CppCond.ExceptionCppCondGraphIfSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for a CppCondGraphIfSection.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppCond.ExceptionCppCondGraphNode">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">ExceptionCppCondGraphNode</tt><a class="headerlink" href="#cpip.core.CppCond.ExceptionCppCondGraphNode" title="Permalink to this definition">¶</a></dt>
<dd><p>When the CppCondGraphNode sees an preprocessing directive in the wrong sequence.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.CppCond.StateConstExprFileLine">
<tt class="descclassname">cpip.core.CppCond.</tt><tt class="descname">StateConstExprFileLine</tt><a class="headerlink" href="#cpip.core.CppCond.StateConstExprFileLine" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">StateConstExprLoc</span></tt></p>
</dd></dl>

<span class="target" id="module-cpip.core.CppDiagnostic"></span><p>Describes how a preprocessor class behaves under abnormal conditions.</p>
<dl class="exception">
<dt id="cpip.core.CppDiagnostic.ExceptionCppDiagnostic">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppDiagnostic.</tt><tt class="descname">ExceptionCppDiagnostic</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.ExceptionCppDiagnostic" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for representing CppDiagnostic.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppDiagnostic.ExceptionCppDiagnosticPartialTokenStream">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppDiagnostic.</tt><tt class="descname">ExceptionCppDiagnosticPartialTokenStream</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.ExceptionCppDiagnosticPartialTokenStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for representing partial remaining tokens.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.CppDiagnostic.ExceptionCppDiagnosticUndefined">
<em class="property">exception </em><tt class="descclassname">cpip.core.CppDiagnostic.</tt><tt class="descname">ExceptionCppDiagnosticUndefined</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.ExceptionCppDiagnosticUndefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for representing undefined behaviour.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticKeepGoing">
<em class="property">class </em><tt class="descclassname">cpip.core.CppDiagnostic.</tt><tt class="descname">PreprocessDiagnosticKeepGoing</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticKeepGoing" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-class that does not raise exceptions.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticRaiseOnError">
<em class="property">class </em><tt class="descclassname">cpip.core.CppDiagnostic.</tt><tt class="descname">PreprocessDiagnosticRaiseOnError</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticRaiseOnError" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-class that raises an exception on a #&#8217;error directive.
TODO: We really should return a value here so that the caller can
decide if they need to raise an Exception after reporting the error.</p>
<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticRaiseOnError.error">
<tt class="descname">error</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticRaiseOnError.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when an error event happens.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd">
<em class="property">class </em><tt class="descclassname">cpip.core.CppDiagnostic.</tt><tt class="descname">PreprocessDiagnosticStd</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes how a preprocessor class behaves under abnormal conditions.</p>
<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.debug">
<tt class="descname">debug</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports a debug message.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.error">
<tt class="descname">error</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when an error event happens.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.eventList">
<tt class="descname">eventList</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.eventList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of events in the order that they appear.
An event is a pair of strings: (type, message)</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.handleUnclosedComment">
<tt class="descname">handleUnclosedComment</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.handleUnclosedComment" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when an unclosed comment is seen at EOF.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.implementationDefined">
<tt class="descname">implementationDefined</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.implementationDefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when an &#8216;implementation defined&#8217; event happens.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.isDebug">
<tt class="descname">isDebug</tt><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.isDebug" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether a call to debug() will result in any log output.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.partialTokenStream">
<tt class="descname">partialTokenStream</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.partialTokenStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when an partial token stream exists (e.g. an unclosed comment).
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.undefined">
<tt class="descname">undefined</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.undefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when an &#8216;undefined&#8217; event happens.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.unspecified">
<tt class="descname">unspecified</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.unspecified" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when unspecified behaviour is happening.
For example order of evaluation of &#8216;#&#8217; and &#8216;##&#8217;.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.CppDiagnostic.PreprocessDiagnosticStd.warning">
<tt class="descname">warning</tt><big>(</big><em>msg</em>, <em>theLoc=None</em><big>)</big><a class="headerlink" href="#cpip.core.CppDiagnostic.PreprocessDiagnosticStd.warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports when an warning event happens.
msg - The main message.
theLoc - the file locator e.g. FileLocation.FileLineCol.
If present it must have: (fileId, lineNum colNum) attributes.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.FileIncludeGraph"></span><p>Captures the #include graph of a preprocessed file.</p>
<dl class="exception">
<dt id="cpip.core.FileIncludeGraph.ExceptionFileIncludeGraph">
<em class="property">exception </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">ExceptionFileIncludeGraph</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.ExceptionFileIncludeGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for the
FileincludeGraph classes.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.FileIncludeGraph.ExceptionFileIncludeGraphRoot">
<em class="property">exception </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">ExceptionFileIncludeGraphRoot</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.ExceptionFileIncludeGraphRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for issues for dummy file ID&#8217;s.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.FileIncludeGraph.ExceptionFileIncludeGraphTokenCounter">
<em class="property">exception </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">ExceptionFileIncludeGraphTokenCounter</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.ExceptionFileIncludeGraphTokenCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for issues for token counters.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.FileIncludeGraph.FigVisitorBase">
<em class="property">class </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">FigVisitorBase</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for visitors, see FigVisitorTreeNodeBase for base class for
tree visitors.</p>
<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FigVisitorBase.visitGraph">
<tt class="descname">visitGraph</tt><big>(</big><em>theFigNode</em>, <em>theDepth</em>, <em>theLine</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorBase.visitGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Hierarchical visitor pattern. This is given a FileIncludeGraph as a
graph node. theDepth is the current depth in the graph as an integer,
theLine the line that is a non-monotonic sibling node ordinal.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.FileIncludeGraph.FigVisitorFileSet">
<em class="property">class </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">FigVisitorFileSet</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorFileSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple visitor that just collects the set of file IDs in the
include graph and a count of how often they are seen.</p>
<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FigVisitorFileSet.visitGraph">
<tt class="descname">visitGraph</tt><big>(</big><em>theFigNode</em>, <em>theDepth</em>, <em>theLine</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorFileSet.visitGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Hierarchical visitor pattern. This is given a FileIncludeGraph as a
graph node. theDepth is the current depth in the graph as an integer,
theLine the line that is a non-monotonic sibling node ordinal.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.FileIncludeGraph.FigVisitorTree">
<em class="property">class </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">FigVisitorTree</tt><big>(</big><em>theNodeClass</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorTree" title="Permalink to this definition">¶</a></dt>
<dd><p>This visitor can visit a graph of FileIncludeGraphRoot and
FileIncludeGraph that recreates a tree of Node(s) the type of which are
supplied by the user. Each node instance will be constructed with either an
instance of a FileIncludeGraphRoot or FileIncludeGraph or, in the case of a
pseudo root node then None.</p>
<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FigVisitorTree.depth">
<tt class="descname">depth</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorTree.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current depth in this graph representation. Changes to
this determine if the node is a child, sibling or ancestor.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FigVisitorTree.tree">
<tt class="descname">tree</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorTree.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top level node object as the only copy.
This also finalises the tree.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase">
<em class="property">class </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">FigVisitorTreeNodeBase</tt><big>(</big><em>theLineNum</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for nodes created by a tree visitor. See FigVisitorBase for
the base class for non-tree visitors.</p>
<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase.addChild">
<tt class="descname">addChild</tt><big>(</big><em>theObj</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase.addChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the object as a child.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase.finalise">
<tt class="descname">finalise</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase.finalise" title="Permalink to this definition">¶</a></dt>
<dd><p>This will be called on finalisation. This is an opportunity
for the root (None) not to accumulate properties from its immediate
children for example.
For depth first finalisation the child class should call finalise
on each child first as this function does.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase.lineNum">
<tt class="descname">lineNum</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FigVisitorTreeNodeBase.lineNum" title="Permalink to this definition">¶</a></dt>
<dd><p>The line number of the parent file that included me.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph">
<em class="property">class </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">FileIncludeGraph</tt><big>(</big><em>theFile</em>, <em>theState</em>, <em>theCondition</em>, <em>theLogic</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive class that holds a graph of include files and and line numbers
of the file that included them.
This class builds up a graph (actually a tree) of file includes. The
insertion order is significant in that it is expected to be the order
experienced by a translation unit processor.
addBaranch() is the way to add to the data structure.</p>
<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.acceptVisitor">
<tt class="descname">acceptVisitor</tt><big>(</big><em>visitor</em>, <em>depth</em>, <em>line</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.acceptVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Hierarchical visitor pattern. This accepts a visitor object and calls
visitor.visitGraph(self, depth, line) on that object where depth is the
current depth in the graph as an integer and line the line that is a
non-monotonic sibling node ordinal.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.addBranch">
<tt class="descname">addBranch</tt><big>(</big><em>theFileS</em>, <em>theLine</em>, <em>theIncFile</em>, <em>theState</em>, <em>theCondition</em>, <em>theLogic</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.addBranch" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a branch to the graph.
theFileS is a list of files that form the branch.
theLine is an integer value of the line number of the #include
statement of the last named file in theFileS.
theIncFile is the file that is included.
theState is a boolean that describes the conditional compilation state.
theCondition is the conditional compilation test e.g. &#8216;1&gt;0&#8217;
theLogic is a string representing how the branch was obtained.</p>
<dl class="docutils">
<dt>May raise ExceptionFileIncludeGraph if:</dt>
<dd><ol class="first last arabic simple" start="0">
<li>The branch is zero length.</li>
<li>The branch does not match the existing graph (this function just
immediately checks the first item on the branch but the others
are done recursively).</li>
<li>theLine is a duplicate of an existing line.</li>
<li>The branch has missing nodes.</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.condComp">
<tt class="descname">condComp</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.condComp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the condition, as a string, under which this file was
included e.g. <tt class="docutils literal"><span class="pre">&quot;(a</span> <span class="pre">&gt;</span> <span class="pre">b)</span> <span class="pre">&amp;&amp;</span> <span class="pre">(1</span> <span class="pre">&gt;</span> <span class="pre">0)&quot;</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.condCompState">
<tt class="descname">condCompState</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.condCompState" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the recorded conditional compilation state as a boolean.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.fileName">
<tt class="descname">fileName</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.fileName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current file name.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.findLogic">
<tt class="descname">findLogic</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.findLogic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the findLogic string passed in in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.genChildNodes">
<tt class="descname">genChildNodes</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.genChildNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields each child node as a FileIncludeGraph object.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.numTokens">
<tt class="descname">numTokens</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.numTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of tokens seen by the PpLexer.
Returns None if not initialised.
Note: This is the number of tokens for this file only, it does not
include the tokens that this file might include.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.numTokensIncChildren">
<tt class="descname">numTokensIncChildren</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.numTokensIncChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of tokens seen by the PpLexer including tokens
from files included by this one.
Returns None if not initialised.
May raise ExceptionFileIncludeGraphTokenCounter is the token counters
have been loaded inconsistently (i.e. the children have not been
loaded).</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.numTokensSig">
<tt class="descname">numTokensSig</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.numTokensSig" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of significant tokens seen by the PpLexer. A significant
token is a non-whitespace, non-conditionally compiled token.
Returns None if not initialised.
Note: This is the number of tokens for this file only, it does not
include the tokens that this file might include.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.numTokensSigIncChildren">
<tt class="descname">numTokensSigIncChildren</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.numTokensSigIncChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of significant tokens seen by the PpLexer including tokens
from files included by this one. A significant
token is a non-whitespace, non-conditionally compiled token.
Returns None if not initialised.
May raise ExceptionFileIncludeGraphTokenCounter is the token counters
have been loaded inconsistently (i.e. the children have not been
loaded).</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.retBranches">
<tt class="descname">retBranches</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.retBranches" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of lists of the branches with &#8216;#&#8217; then the line number.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestBranch">
<tt class="descname">retLatestBranch</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestBranch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the branch to the last inserted leaf as a list of
branch strings.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestBranchDepth">
<tt class="descname">retLatestBranchDepth</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestBranchDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks the graph and returns an integer that is
the depth of the latest branch.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestBranchPairs">
<tt class="descname">retLatestBranchPairs</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestBranchPairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the branch to the last inserted leaf as a list of
pairs (filename, integer_line).</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestLeaf">
<tt class="descname">retLatestLeaf</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestLeaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last inserted leaf, a FileIncludeGraph object.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestNode">
<tt class="descname">retLatestNode</tt><big>(</big><em>theBranch</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.retLatestNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last inserted node, a FileIncludeGraph object
on the supplied branch.
This is generally used during dynamic construction by a caller
that understands the state of the file include branch.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.setTokenCounter">
<tt class="descname">setTokenCounter</tt><big>(</big><em>theTokCounter</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.setTokenCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the token counter for this node which is a PpTokenCount object.
The PpLexer sets this as the token count for this file only. This
files #includes are a separate token counter.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraph.tokenCounter">
<tt class="descname">tokenCounter</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraph.tokenCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the token counter for this node, a PpTokenCount object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraphRoot">
<em class="property">class </em><tt class="descclassname">cpip.core.FileIncludeGraph.</tt><tt class="descname">FileIncludeGraphRoot</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraphRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Root class of the file include graph. This is used when there is a
virtual or dummy root. It contains a list of FileIncludeGraph objects.
In this way it can represent the list of graphs that would result from a
list of pre-includes followed by the ITU itself.
In practice this is used by the PpLexer for this purpose where the
dummy root is represented by None.</p>
<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraphRoot.acceptVisitor">
<tt class="descname">acceptVisitor</tt><big>(</big><em>visitor</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraphRoot.acceptVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Hierarchical visitor pattern. This accepts a visitor object and calls
visitor.visitGraph(self, depth, line) on that object where depth is the
current depth in the graph as an integer and line the line that is a
non-monotonic sibling node ordinal.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraphRoot.addGraph">
<tt class="descname">addGraph</tt><big>(</big><em>theGraph</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraphRoot.addGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a FileIncludeGraph object.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraphRoot.dumpGraph">
<tt class="descname">dumpGraph</tt><big>(</big><em>theS=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x1004160b8&gt;</em><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraphRoot.dumpGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the node for debug/trace.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraphRoot.graph">
<tt class="descname">graph</tt><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraphRoot.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>The latest FileIncludeGraph object I have.
Will raise a ExceptionFileIncludeGraphRoot if nothing there.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.FileIncludeGraph.FileIncludeGraphRoot.numTrees">
<tt class="descname">numTrees</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.FileIncludeGraph.FileIncludeGraphRoot.numTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of FileIncludeGraph objects.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.IncludeHandler"></span><p>Provides handlers for #including files.</p>
<dl class="class">
<dt id="cpip.core.IncludeHandler.CppIncludeStd">
<em class="property">class </em><tt class="descclassname">cpip.core.IncludeHandler.</tt><tt class="descname">CppIncludeStd</tt><big>(</big><em>theUsrDirs</em>, <em>theSysDirs</em><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that applies search rules for #include statements.</p>
<p>Search tactics based on RVCT and Berkeley UNIX search rules:</p>
<div class="highlight-python"><pre>I is the usr includes.
J is the sys includes.
Size of I Size of J   #include &lt;...&gt;      #include "..."
0         0           None                CP

0         &gt;0          SYSTEMINCLUDEdirs   CP, SYSTEMINCLUDEdirs

&gt;0        0           USERINCLUDEdirs     CP, USERINCLUDEdirs

&gt;0        &gt;0          SYSTEMINCLUDEdirs,  CP, USERINCLUDEdirs,
                      USERINCLUDEdirs      SYSTEMINCLUDEdirs</pre>
</div>
<p>ISO/IEC 9899:1999 (E) 6.10.2-3 means that a failure of q-char must be
retried as if it was a h-char.
i.e. A failure of a q-char-sequence thus:
#include &#8221;...&#8221;
Is to be retried as if it was written as a h-char-sequence thus:
#include &lt;...&gt;
See: _includeQcharseq()</p>
<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.canInclude">
<tt class="descname">canInclude</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.canInclude" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the last include succeeded.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.clearFindLogic">
<tt class="descname">clearFindLogic</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.clearFindLogic" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the list of find results for a single #include statement.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.clearHistory">
<tt class="descname">clearHistory</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.clearHistory" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the CP stack. This needed if you use this class as a
persistent one and it encounters an exception. You need to call this
function before you can reuse it.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.cpStack">
<tt class="descname">cpStack</tt><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.cpStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current stack of current places.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.cpStackPop">
<tt class="descname">cpStackPop</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.cpStackPop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pops and returns the CP string off the current place stack.
This is public so that the PpLexer can use it when processing
pre-include files that might themselves include other files.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.cpStackPush">
<tt class="descname">cpStackPush</tt><big>(</big><em>theFpo</em><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.cpStackPush" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends the CP from the FilePathOrigin to the current place stack.
This is public so that the PpLexer can use it when processing
pre-include files that might themselves include other files.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.cpStackSize">
<tt class="descname">cpStackSize</tt><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.cpStackSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of the current stack of current places.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.currentPlace">
<tt class="descname">currentPlace</tt><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.currentPlace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last current place or None if #include failed.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.endInclude">
<tt class="descname">endInclude</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.endInclude" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify end of #include&#8217;d file. This pops the CP stack.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.finalise">
<tt class="descname">finalise</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.finalise" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalise at the end of the translation unit.
Might raise a ExceptionCppInclude.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.findLogic">
<tt class="descname">findLogic</tt><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.findLogic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of strings that describe _how_ the file was found
For example:</p>
<p><tt class="docutils literal"><span class="pre">['&lt;foo.h&gt;',</span> <span class="pre">'CP=None',</span> <span class="pre">'sys=None',</span> <span class="pre">'usr=include/foo.h']</span></tt></p>
<p>Each string after [0] is of the form: <tt class="docutils literal"><span class="pre">key=value</span></tt> Where:</p>
<ol class="arabic simple">
<li>key is a key in <tt class="docutils literal"><span class="pre">self.INCLUDE_ORIGIN_CODES</span></tt></li>
<li>= is the <tt class="docutils literal"><span class="pre">'='</span></tt> character.</li>
<li>value is the result, or &#8216;None&#8217; if not found.</li>
<li>Item [0] is the invocation</li>
<li>Item [-1] is the final resolution.</li>
</ol>
<p>The intermediate ones are various tries in order.
So:</p>
<p><tt class="docutils literal"><span class="pre">['&lt;foo.h&gt;',</span> <span class="pre">'CP=None',</span> <span class="pre">'sys=None',</span> <span class="pre">'usr=include/foo.h']</span></tt></p>
<p>Wwould mean:</p>
<ul class="simple">
<li>[0]: <tt class="docutils literal"><span class="pre">'&lt;foo.h&gt;'</span></tt> the include directive was: <tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&lt;foo.h&gt;</span></tt></li>
<li>[1]: <tt class="docutils literal"><span class="pre">'CP=None'</span></tt> the Current place was searched and nothing found.</li>
<li>[2]: <tt class="docutils literal"><span class="pre">'sys=None'</span></tt> the system include(s) were searched and nothing found.</li>
<li>[3]: <tt class="docutils literal"><span class="pre">'usr=include/foo.h'</span></tt> the user include(s) were searched and include/foo.h was found.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.includeHeaderName">
<tt class="descname">includeHeaderName</tt><big>(</big><em>theStr</em><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.includeHeaderName" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the file location of a #include header-name where the
header-name is a pp-token either a &lt;h-char-sequence&gt; or a
&#8220;q-char-sequence&#8221; (including delimiters).
If not None return value this also records the CP for the file.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.initialTu">
<tt class="descname">initialTu</tt><big>(</big><em>theTuIdentifier</em><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.initialTu" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an Translation Unit Identifier this should return a
class FilePathOrigin or None for the initial translation unit.
As a precaution this should include code to check that the stack
of current places is empty. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cpStack</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">ExceptionCppInclude</span><span class="p">(</span><span class="s">&#39;setTu() with CP stack: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cpStack</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStd.validateCpStack">
<tt class="descname">validateCpStack</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStd.validateCpStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the coherence of the CP stack. A None can not be followed by
a non-None.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.IncludeHandler.CppIncludeStdOs">
<em class="property">class </em><tt class="descclassname">cpip.core.IncludeHandler.</tt><tt class="descname">CppIncludeStdOs</tt><big>(</big><em>theUsrDirs</em>, <em>theSysDirs</em><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStdOs" title="Permalink to this definition">¶</a></dt>
<dd><p>This implements _searchFile() based on an OS file system call.</p>
<dl class="method">
<dt id="cpip.core.IncludeHandler.CppIncludeStdOs.initialTu">
<tt class="descname">initialTu</tt><big>(</big><em>theTuPath</em><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStdOs.initialTu" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an path as a string this returns the
class FilePathOrigin or None for the initial translation unit</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.IncludeHandler.CppIncludeStringIO">
<em class="property">class </em><tt class="descclassname">cpip.core.IncludeHandler.</tt><tt class="descname">CppIncludeStringIO</tt><big>(</big><em>theUsrDirs</em>, <em>theSysDirs</em>, <em>theInitialTuContent</em>, <em>theFilePathToContent</em><big>)</big><a class="headerlink" href="#cpip.core.IncludeHandler.CppIncludeStringIO" title="Permalink to this definition">¶</a></dt>
<dd><p>This implements _searchFile() based on a lookup of stings that
returns StringIO file-like object.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.IncludeHandler.ExceptionCppInclude">
<em class="property">exception </em><tt class="descclassname">cpip.core.IncludeHandler.</tt><tt class="descname">ExceptionCppInclude</tt><a class="headerlink" href="#cpip.core.IncludeHandler.ExceptionCppInclude" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for the CppInclude.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.IncludeHandler.FilePathOrigin">
<em class="property">class </em><tt class="descclassname">cpip.core.IncludeHandler.</tt><tt class="descname">FilePathOrigin</tt><a class="headerlink" href="#cpip.core.IncludeHandler.FilePathOrigin" title="Permalink to this definition">¶</a></dt>
<dd><p>FilePathOrigin(fileObj, filePath, currentPlace, origin)</p>
<dl class="attribute">
<dt id="cpip.core.IncludeHandler.FilePathOrigin.currentPlace">
<tt class="descname">currentPlace</tt><a class="headerlink" href="#cpip.core.IncludeHandler.FilePathOrigin.currentPlace" title="Permalink to this definition">¶</a></dt>
<dd><p>itemgetter(item, ...) &#8211;&gt; itemgetter object</p>
<p>Return a callable object that fetches the given item(s) from its operand.
After, f=itemgetter(2), the call f(r) returns r[2].
After, g=itemgetter(2,5,3), the call g(r) returns (r[2], r[5], r[3])</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.IncludeHandler.FilePathOrigin.fileObj">
<tt class="descname">fileObj</tt><a class="headerlink" href="#cpip.core.IncludeHandler.FilePathOrigin.fileObj" title="Permalink to this definition">¶</a></dt>
<dd><p>itemgetter(item, ...) &#8211;&gt; itemgetter object</p>
<p>Return a callable object that fetches the given item(s) from its operand.
After, f=itemgetter(2), the call f(r) returns r[2].
After, g=itemgetter(2,5,3), the call g(r) returns (r[2], r[5], r[3])</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.IncludeHandler.FilePathOrigin.filePath">
<tt class="descname">filePath</tt><a class="headerlink" href="#cpip.core.IncludeHandler.FilePathOrigin.filePath" title="Permalink to this definition">¶</a></dt>
<dd><p>itemgetter(item, ...) &#8211;&gt; itemgetter object</p>
<p>Return a callable object that fetches the given item(s) from its operand.
After, f=itemgetter(2), the call f(r) returns r[2].
After, g=itemgetter(2,5,3), the call g(r) returns (r[2], r[5], r[3])</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.IncludeHandler.FilePathOrigin.origin">
<tt class="descname">origin</tt><a class="headerlink" href="#cpip.core.IncludeHandler.FilePathOrigin.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>itemgetter(item, ...) &#8211;&gt; itemgetter object</p>
<p>Return a callable object that fetches the given item(s) from its operand.
After, f=itemgetter(2), the call f(r) returns r[2].
After, g=itemgetter(2,5,3), the call g(r) returns (r[2], r[5], r[3])</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.MacroEnv"></span><p>This an environment of macro declarations</p>
<p>It implements ISO/IEC 9899:1999(E) section 6 (aka &#8216;C&#8217;)
and ISO/IEC 14882:1998(E) section 16 (aka &#8216;C++&#8217;)</p>
<p>TODO: Record macro related events in the order that they happen.
[</p>
<blockquote>
<div><dl class="docutils">
<dt>(</dt>
<dd>macro_ident,         - string
event,               - string e.g. &#8216;define&#8217;, &#8216;replace&#8217;, &#8216;undef&#8217;
None or PpDefine,    - the latter if undef (or define???)
file,                - string
line,                - int
col,                 - int</dd>
</dl>
<p>),</p>
</div></blockquote>
<p>]</p>
<p>Can remap this on output to:
{macro_ident : [index, ...], ...}</p>
<p>TODO: Record #ifdef, #ifndef, #if defined and #elif defined when no macro is
defined in a separate data structure so that we can say that these macros, if
present, could alter the outcome i.e. it is a NOT dependency.</p>
<dl class="exception">
<dt id="cpip.core.MacroEnv.ExceptionMacroEnv">
<em class="property">exception </em><tt class="descclassname">cpip.core.MacroEnv.</tt><tt class="descname">ExceptionMacroEnv</tt><a class="headerlink" href="#cpip.core.MacroEnv.ExceptionMacroEnv" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling MacroEnv object.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.MacroEnv.ExceptionMacroEnvInvalidRedefinition">
<em class="property">exception </em><tt class="descclassname">cpip.core.MacroEnv.</tt><tt class="descname">ExceptionMacroEnvInvalidRedefinition</tt><a class="headerlink" href="#cpip.core.MacroEnv.ExceptionMacroEnvInvalidRedefinition" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for a invalid redefinition of a macro.
NOTE: Under C rules (C Rationale 6.10.3) callers should merely issue a
suitable diagnostic.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.MacroEnv.ExceptionMacroEnvNoMacroDefined">
<em class="property">exception </em><tt class="descclassname">cpip.core.MacroEnv.</tt><tt class="descname">ExceptionMacroEnvNoMacroDefined</tt><a class="headerlink" href="#cpip.core.MacroEnv.ExceptionMacroEnvNoMacroDefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when trying to access a PpDefine that is not currently defined.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.MacroEnv.ExceptionMacroIndexError">
<em class="property">exception </em><tt class="descclassname">cpip.core.MacroEnv.</tt><tt class="descname">ExceptionMacroIndexError</tt><a class="headerlink" href="#cpip.core.MacroEnv.ExceptionMacroIndexError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when an access to a PpDefine that generates a IndexError.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.MacroEnv.ExceptionMacroReplacementInit">
<em class="property">exception </em><tt class="descclassname">cpip.core.MacroEnv.</tt><tt class="descname">ExceptionMacroReplacementInit</tt><a class="headerlink" href="#cpip.core.MacroEnv.ExceptionMacroReplacementInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception in the constructor.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.MacroEnv.ExceptionMacroReplacementPredefinedRedefintion">
<em class="property">exception </em><tt class="descclassname">cpip.core.MacroEnv.</tt><tt class="descname">ExceptionMacroReplacementPredefinedRedefintion</tt><a class="headerlink" href="#cpip.core.MacroEnv.ExceptionMacroReplacementPredefinedRedefintion" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for a redefinition of a macro id that is predefined.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.MacroEnv.MacroEnv">
<em class="property">class </em><tt class="descclassname">cpip.core.MacroEnv.</tt><tt class="descname">MacroEnv</tt><big>(</big><em>enableTrace=False</em>, <em>stdPredefMacros=None</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a set of #define directives that represent a macro processing
environment. This provides support for #define and #undef directives.
It also provides support for macro replacement see:
ISO/IEC 9899:1999 (E) 6.10.3 Macro replacement.</p>
<p><em>enableTrace</em> allows calls to _debugTokenStream() that may or may not
produce log output (depending on logging level).
If True this makes this code run slower, typically 3x slower</p>
<p><em>stdPredefMacros</em> if present should be a dictionary of:
<tt class="docutils literal"><span class="pre">{identifier</span> <span class="pre">:</span> <span class="pre">replacement_string_\n_terminated,</span> <span class="pre">...}</span></tt>
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
    <span class="s">&#39;__DATE__&#39;</span> <span class="p">:</span> <span class="s">&#39;First of June</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span>
    <span class="s">&#39;__TIME__&#39;</span> <span class="p">:</span> <span class="s">&#39;Just before lunchtime.</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each identifier must be in <tt class="docutils literal"><span class="pre">STD_PREDEFINED_NAMES</span></tt></p>
<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the macro environment.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.define">
<tt class="descname">define</tt><big>(</big><em>theGen</em>, <em>theFile</em>, <em>theLine</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.define" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a macro. theGen should be in the state immediately after the
<tt class="docutils literal"><span class="pre">#define</span></tt> i.e. this will consume leading whitespace and the trailing
newline.</p>
<p>Will raise a ExceptionMacroEnvInvalidRedefinition is the redefinition
is not valid. May raise a ExceptionCpipDefineInit (or sub class) on failure.</p>
<p>On success it returns the identifier of the macro as a string..
The insertion is stable i.e. a valid re-definition does not replace
the existing definition so that the existing state of the macro
definition (file, line, reference count etc. are preserved.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.defined">
<tt class="descname">defined</tt><big>(</big><em>theTtt</em>, <em>flagInvert</em>, <em>theFileLineCol=None</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.defined" title="Permalink to this definition">¶</a></dt>
<dd><p>If the PpToken theTtt is an identifier that is currently defined
then this returns 1 as a PpToken, 0 as a PpToken otherwise.
If the macro exists in the environment its reference count is
incremented.
See: ISO/IEC 9899:1999 (E) 6.10.1.
theFileLineCol is a FileLocation.FileLineCol object.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.genMacros">
<tt class="descname">genMacros</tt><big>(</big><em>theIdentifier=None</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.genMacros" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates PpDefine objects encountered during my existence.
Macros that have been undefined will be generated first in order of
un-definition followed by the currently defined macros in identifier
order.
Macros that have been #undef&#8217;d will have the attribute 
isCurrentlyDefined as False.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.genMacrosInScope">
<tt class="descname">genMacrosInScope</tt><big>(</big><em>theIdent=None</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.genMacrosInScope" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates PpDefine objects encountered during my existence and still
in scope i.e. not yet un-defined.
If theIdent is not None then only that named macros will be yielded.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.genMacrosOutOfScope">
<tt class="descname">genMacrosOutOfScope</tt><big>(</big><em>theIdent=None</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.genMacrosOutOfScope" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates PpDefine objects encountered during my existence but then
undefined in the order of un-definition.
If theIdent is not None then only that named macros will be yielded.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.getUndefMacro">
<tt class="descname">getUndefMacro</tt><big>(</big><em>theIdx</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.getUndefMacro" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the PpDefine object from the undef list for the given index.
Will raise an ExceptionMacroIndexError if the index is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.hasMacro">
<tt class="descname">hasMacro</tt><big>(</big><em>theIdentifier</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.hasMacro" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the environment has the macro.
NOTE: This does _not_ increment the reference count so should not be
used when processing #ifdef ..., #if defined ... or #if !defined ...
for those use isDefined() and defined() instead.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.isDefined">
<tt class="descname">isDefined</tt><big>(</big><em>theTtt</em>, <em>theFileLineCol=None</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.isDefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True theTtt is an identifier that is currently defined,
False otherwise. If True this increments the macro reference.
See: ISO/IEC 9899:1999 (E) 6.10.1.
theFileLineCol is a FileLocation.FileLineCol object.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.macro">
<tt class="descname">macro</tt><big>(</big><em>theIdentifier</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.macro" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the macro identified by the identifier.
Will raise a ExceptionMacroEnvNoMacroDefined is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.macroHistory">
<tt class="descname">macroHistory</tt><big>(</big><em>incEnv=True</em>, <em>onlyRef=True</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.macroHistory" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the macro history as a multi-line string</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.macroHistoryMap">
<tt class="descname">macroHistoryMap</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.macroHistoryMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a map of {ident : ([ints, ...], True/False), ...}
Where the macro identifier is mapped to a pair where:
pair[0] is a list of indexes into getUndefMacro().
pair[1] is boolean, True if the identifier is currently defined
i.e. it is the value ofself.hasMacro(ident).
The macro can be obtained by self.macro().</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.macroNotDefinedDependencies">
<tt class="descname">macroNotDefinedDependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.macroNotDefinedDependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a map of {identifier : [class FileLineColumn, ...], ...}
where there has been an #ifdef and nothing is defined.
Thus these macros, if present, could alter the outcome
i.e. it is dependency on them NOT being defined.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.macroNotDefinedDependencyNames">
<tt class="descname">macroNotDefinedDependencyNames</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.macroNotDefinedDependencyNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an unsorted list of identifies
where there has been an #ifdef and nothing is defined.
Thus these macros, if present, could alter the outcome
i.e. it is dependency on them NOT being defined.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.macroNotDefinedDependencyReferences">
<tt class="descname">macroNotDefinedDependencyReferences</tt><big>(</big><em>theIdentifier</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.macroNotDefinedDependencyReferences" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an ordered list of class FileLineColumn for an identifier
where there has been an #ifdef and nothing is defined.
Thus these macros, if present, could alter the outcome
i.e. it is dependency on them NOT being defined.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.macros">
<tt class="descname">macros</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.macros" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of strings of current macros.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.mightReplace">
<tt class="descname">mightReplace</tt><big>(</big><em>theTtt</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.mightReplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if theTok might be able to be expanded.
&#8216;Might&#8217; is not &#8216;can&#8217; or &#8216;will&#8217; because of this:</p>
<div class="highlight-python"><pre>#define FUNC(a,b) a-b
FUNC FUNC(45,3)</pre>
</div>
<p>Becomes:</p>
<div class="highlight-python"><pre>FUNC 45 -3</pre>
</div>
<p>Thus <tt class="docutils literal"><span class="pre">mightReplace('FUNC',</span> <span class="pre">...)</span></tt> is True in both cases but actual
replacement only occurs once for the second <tt class="docutils literal"><span class="pre">FUNC</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.referencedMacroIdentifiers">
<tt class="descname">referencedMacroIdentifiers</tt><big>(</big><em>sortedByRefcount=False</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.referencedMacroIdentifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an unsorted list of macro identifiers that have a reference
count &gt; 0. If sortedByRefcount is True the list will be in increasing
order of reference count then by name. Use reverse() on the result to get decreasing
order.
If sortedByRefcount is False the return value is unsorted.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.replace">
<tt class="descname">replace</tt><big>(</big><em>theTtt</em>, <em>theGen</em>, <em>theFileLineCol=None</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a PpToken this returns the replacement as a list of
[class PpToken, ...] that is the result of the substitution of
macro definitions.
theGen is a generator that might be used in the case of function-like
macros to consume their argument lists.
theFileLineCol is a FileLocation.FileLineCol object.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.set__FILE__">
<tt class="descname">set__FILE__</tt><big>(</big><em>theStr</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.set__FILE__" title="Permalink to this definition">¶</a></dt>
<dd><p>This sets the <tt class="docutils literal"><span class="pre">__FILE__</span></tt> macro directly.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.set__LINE__">
<tt class="descname">set__LINE__</tt><big>(</big><em>theStr</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.set__LINE__" title="Permalink to this definition">¶</a></dt>
<dd><p>This sets the <tt class="docutils literal"><span class="pre">__LINE__</span></tt> macro directly.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.MacroEnv.MacroEnv.undef">
<tt class="descname">undef</tt><big>(</big><em>theGen</em>, <em>theFile</em>, <em>theLine</em><big>)</big><a class="headerlink" href="#cpip.core.MacroEnv.MacroEnv.undef" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a definition from the map and adds the PpDefine to
self._undefS. It returns None.
If no definition exists this has no side-effects on the internal
representation.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.PpDefine"></span><p>This handles definition, undefinition, redefintion, replacement
and rescaning of macro declartions</p>
<p>It implements: ISO/IEC 9899:1999(E) section 6 (aka &#8216;C99&#8217;)
and/or: ISO/IEC 14882:1998(E) section 16 (aka &#8216;C++98&#8217;)</p>
<div class="section" id="todo-2008-11-21">
<h2>TODO: 2008-11-21<a class="headerlink" href="#todo-2008-11-21" title="Permalink to this headline">¶</a></h2>
<p>2008-11-21_a: Come to a decision on placeholder tokens. Does #define p()
whatever</p>
<blockquote>
<div>mean that p has argument list [] or [[]]?</div></blockquote>
<p>2008-11-21_b: Replace references to &#8216;object type&#8217; or &#8216;object style&#8217; with
&#8216;object-like&#8217;. Similarly for functions macros.</p>
<p>2008-11-21_c: Do we follow C++ or C?</p>
<p>2008-11-21_d: We should worry about &#8216;Within the sequence of preprocessing tokens
making up an invocation of a function-like macro, new-line is considered a
normal white-space character.&#8217; in the C ISO/IEC 9899:1999(E) 6.10-3 and C++
ISO/IEC 14882:1998(E) 16.3-9 in function-like replacement that I am not
capturing?</p>
<p>For example:
#define f(a) a+a
f(</p>
<blockquote>
<div>1</div></blockquote>
<p>)
Becomes:
1 +1
[2008-11-24: Done. See testReplaceFunction_09()]</p>
<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefine">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefine</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling PpDefine object.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineBadArguments">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineBadArguments</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineBadArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when scanning an argument list for a function style macro
fails.
NOTE: This is only raised during replacement not during
initialisation.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineBadWs">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineBadWs</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineBadWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when calling bad whitespace is in a define statement.
See: ISO/IEC 9899:1999(E) Section 6.10-f and ISO/IEC 14882:1998(E) 16-2</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineDupeId">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineDupeId</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineDupeId" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for a function-like macro has duplicates
in the identifier-list.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineInit">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineInit</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when creating PpDefine object fails.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineInitBadLine">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineInitBadLine</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineInitBadLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for a bad line number given as argument.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineInvalidCmp">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineInvalidCmp</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineInvalidCmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception for a redefinition where the identifers are different.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineMissingWs">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineMissingWs</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineMissingWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when calling missing ws between identifier and replacement tokens.</p>
<p>See: ISO/IEC 9899:1999(E) Section 6.10.3-3 and ISO/IEC 14882:1998(E) Section ???</p>
<p>Note: cpp says for &#8220;#define PLUS+&#8221;:
src.h:1:13: warning: ISO C requires whitespace after the macro name</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpDefine.ExceptionCpipDefineReplace">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">ExceptionCpipDefineReplace</tt><a class="headerlink" href="#cpip.core.PpDefine.ExceptionCpipDefineReplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when replacing a macro definition fails.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.PpDefine.PpDefine">
<em class="property">class </em><tt class="descclassname">cpip.core.PpDefine.</tt><tt class="descname">PpDefine</tt><big>(</big><em>theTokGen</em>, <em>theFileId</em>, <em>theLine</em><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a single #define directive and performs ISO/IEC 9899:1999 (E) 6.10.3 Macro replacement.</p>
<p>theTokGen is a PpToken generator that is expected to
generate pp-tokens that appear after the start of the #define directive
from the first non-whitespace token onwards i.e. the __init__ will,
itself, consume leading whitespace.</p>
<p>theFileId is a string that represents the file ID.</p>
<p>theLine is a positive integer that represents the line in theFile that
the #define statement occurred.</p>
<p>Definition example, object-like macros:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">identifier</span><span class="p">,</span> <span class="p">[</span><span class="n">replacement</span><span class="o">-</span><span class="nb">list</span> <span class="p">(</span><span class="n">opt</span><span class="p">)],</span> <span class="n">new</span><span class="o">-</span><span class="n">line</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Or function-like macros:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span>
    <span class="n">identifier</span><span class="p">,</span>
    <span class="n">lparen</span><span class="p">,</span>
    <span class="p">[</span><span class="n">identifier</span><span class="o">-</span><span class="nb">list</span><span class="p">(</span><span class="n">opt</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="s">&#39;)&#39;</span><span class="p">,</span>
    <span class="n">replacement</span><span class="o">-</span><span class="nb">list</span><span class="p">,</span>
    <span class="n">new</span><span class="o">-</span><span class="n">line</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>NOTE: No whitespace is allowed between the identifier and the lparen
of function-like macros.</p>
<p>The <tt class="docutils literal"><span class="pre">identifier-list</span></tt> of parameters is stored as a list of names.
The replacement-list is stored as a list of
preprocessor tokens.
Leading and trailing whitespace in the replacement
list is removed to facilitate redefinition comparison.</p>
<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.assertReplListIntegrity">
<tt class="descname">assertReplListIntegrity</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.assertReplListIntegrity" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests that any identifier tokens in the replacement list are
actually replaceable. This will raise an assertion failure if
not. It is really an integrity tests to see if an external entity
has grabbed a reference to the replacement list and set a token
to be not replaceable.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.consumeFunctionPreamble">
<tt class="descname">consumeFunctionPreamble</tt><big>(</big><em>theGen</em><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.consumeFunctionPreamble" title="Permalink to this definition">¶</a></dt>
<dd><p>This consumes tokens to the preamble of a Function style macro
invocation. This really means consuming whitespace and the opening
<tt class="docutils literal"><span class="pre">LPAREN</span></tt>.</p>
<dl class="docutils">
<dt>This will return either:</dt>
<dd>None - Tokens including the leading LPAREN have been consumed.
List of (token, token_type) if the LPAREN is not found.</dd>
</dl>
<p>For example given this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#define t(a) a+2</span>
<span class="n">t</span>   <span class="p">(</span><span class="mi">21</span><span class="p">)</span> <span class="o">-</span> <span class="n">t</span>  <span class="p">;</span>
</pre></div>
</div>
<p>For the first <tt class="docutils literal"><span class="pre">t</span></tt> this would consume <tt class="docutils literal"><span class="pre">'</span>&nbsp;&nbsp; <span class="pre">('</span></tt> and return None leaving the
next token to be (&#8216;21&#8217;, &#8216;pp-number&#8217;).</p>
<p>For the second <tt class="docutils literal"><span class="pre">t</span></tt> this would consume <tt class="docutils literal"><span class="pre">'</span>&nbsp; <span class="pre">;'</span></tt> and return:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span>
    <span class="p">(</span><span class="s">&#39;  &#39;</span><span class="p">,</span> <span class="s">&#39;whitespace&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">,</span>   <span class="s">&#39;preprocessing-op-or-punc&#39;</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>This allows the MacroReplacementEnv to generate the correct result: ::</dt>
<dd>21 +2 - t ;</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.expandArguments">
<tt class="descname">expandArguments</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.expandArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>The flag that says whether arguments should be expanded.
For object like macros this will be False. For function like macros
this will be False if there is a stringize (&#8216;#&#8217;) or a token pasting
operator (&#8216;##&#8217;). True otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.fileId">
<tt class="descname">fileId</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.fileId" title="Permalink to this definition">¶</a></dt>
<dd><p>The file ID given as an argument in the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.identifier">
<tt class="descname">identifier</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>The macro identifier i.e. the name as a string.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.incRefCount">
<tt class="descname">incRefCount</tt><big>(</big><em>theFileLineCol=None</em><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.incRefCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the reference count. Typically callers do this when
replacement is certain of in the event of definition testing e.g.
#ifdef SPAM or defined(SPAM) etc. Or if the macro is expanded e.g.
#define SPAM_N_EGGS spam and eggs
The menu is SPAM_N_EGGS.
theFileLineCol is a FileLocation.FileLineCol object.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.isCurrentlyDefined">
<tt class="descname">isCurrentlyDefined</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.isCurrentlyDefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the current instance is a valid definition
i.e. it has not been #undef&#8217;d.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.isObjectTypeMacro">
<tt class="descname">isObjectTypeMacro</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.isObjectTypeMacro" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this is an object type macro and
False if it is a function type macro.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.isReferenced">
<tt class="descname">isReferenced</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.isReferenced" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the reference count has been incremented since
construction.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.isValidRefefinition">
<tt class="descname">isValidRefefinition</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.isValidRefefinition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if this is a valid redefinition of <em>other</em>, False otherwise.
Will raise an <tt class="docutils literal"><span class="pre">ExceptionCpipDefineInvalidCmp</span></tt> if the identifiers are
different.
Will raise an <tt class="docutils literal"><span class="pre">ExceptionCpipDefine</span></tt> if either is not currently defined.</p>
<p>From: <strong>ISO/IEC 9899:1999 (E) 6.10.3:</strong></p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>Two replacement lists are identical if and only if the preprocessing</dt>
<dd><p class="first last">tokens in both have the same number, ordering, spelling, and white-space
separation, where all white-space separations are considered identical.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>An identifier currently defined as a macro without use of lparen</dt>
<dd><p class="first last">(an object-like macro) may be redefined by another #define preprocessing
directive provided that the second definition is an object-like macro
definition and the two replacement lists are identical, otherwise the
program is ill-formed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>An identifier currently defined as a macro using lparen (a</dt>
<dd><p class="first last">function-like macro) may be redefined by another #define preprocessing
directive provided that the second definition is a function-like macro
definition that has the same number and spelling of parameters, and the
two replacement lists are identical, otherwise the program is
ill-formed.</p>
</dd>
</dl>
</li>
</ol>
<p>See also: <strong>ISO/IEC 14882:1998(E) 16.3 Macro replacement [cpp.replace]</strong></p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.line">
<tt class="descname">line</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.line" title="Permalink to this definition">¶</a></dt>
<dd><p>The line number given as an argument in the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.parameters">
<tt class="descname">parameters</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of parameter names as strings for a function like macros
or None if this is an object type Macro.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.refCount">
<tt class="descname">refCount</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.refCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current reference count as an integer less its initial
value on construction.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.refFileLineColS">
<tt class="descname">refFileLineColS</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.refFileLineColS" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of FileLineCol objects where this macro was referenced.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.replaceArgumentList">
<tt class="descname">replaceArgumentList</tt><big>(</big><em>theArgList</em><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.replaceArgumentList" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an list of arguments this does argument substitution and
returns the replacement token list. The argument list is of the form
given by retArgumentListTokens(). The caller must have replaced any
macro invocations in theArgList before calling this method.
NOTE: For function style macros only.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.replaceObjectStyleMacro">
<tt class="descname">replaceObjectStyleMacro</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.replaceObjectStyleMacro" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of [(token, token_type), ...] from the replacement
of an object style macro.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.replacementTokens">
<tt class="descname">replacementTokens</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.replacementTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of zero or more replacement token
i.e. [class PpToken, ...].</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.replacements">
<tt class="descname">replacements</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.replacements" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of zero or more replacement tokens as strings.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.retArgumentListTokens">
<tt class="descname">retArgumentListTokens</tt><big>(</big><em>theGen</em><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.retArgumentListTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>For a function macro this reads the tokens following a <tt class="docutils literal"><span class="pre">LPAREN</span></tt> and
returns a list of arguments where each argument is a list of
PpToken objects.</p>
<p>Thus this function returns a list of lists of PpToken objects,
for example given this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#define f(x,y) ...</span>
<span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This function, then passed &#8220;a,b)&#8221; returns:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span>
    <span class="p">[</span>
        <span class="n">PpToken</span><span class="o">.</span><span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;identifier&#39;</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="p">[</span>
        <span class="n">PpToken</span><span class="o">.</span><span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;identifier&#39;</span><span class="p">),</span>
    <span class="p">],</span>
<span class="p">]</span>
</pre></div>
</div>
<p>And an invocation of:
<tt class="docutils literal"><span class="pre">f(1(,)2,3)</span></tt> i.e. this gets passed via the generator <tt class="docutils literal"><span class="pre">&quot;1(,)2,3)&quot;</span></tt>
and returns two argunments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span>
    <span class="p">[</span>
        <span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;pp-number&#39;</span><span class="p">),</span>
        <span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;preprocessing-op-or-punc&#39;</span><span class="p">),</span>
        <span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="s">&#39;preprocessing-op-or-punc&#39;</span><span class="p">),</span>
        <span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;preprocessing-op-or-punc&#39;</span><span class="p">),</span>
        <span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;pp-number&#39;</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="p">[</span>
        <span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;3&#39;</span><span class="p">,</span> <span class="s">&#39;pp-number&#39;</span><span class="p">),</span>
    <span class="p">],</span>
<span class="p">]</span>
</pre></div>
</div>
<p>So this function supports two cases:</p>
<ol class="arabic simple">
<li>Parsing function style macro declarations.</li>
<li>Interpreting function style macro invocations where the argument list
is subject to replacement before invoking the macro.</li>
</ol>
<p>In the case that an argument is missing a <tt class="docutils literal"><span class="pre">PpDefine.PLACEMARKER</span></tt>
token is inserted. For example:</p>
<div class="highlight-python"><pre>#define FUNCTION_STYLE(a,b,c) ...
FUNCTION_STYLE(,2,3)</pre>
</div>
<p>Gives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span>
    <span class="n">PpDefine</span><span class="o">.</span><span class="n">PLACEMARKER</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="n">PpToken</span><span class="o">.</span><span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span>       <span class="s">&#39;pp-number&#39;</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="p">[</span>
        <span class="n">PpToken</span><span class="o">.</span><span class="n">PpToken</span><span class="p">(</span><span class="s">&#39;3&#39;</span><span class="p">,</span>       <span class="s">&#39;pp-number&#39;</span><span class="p">),</span>
    <span class="p">],</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Placemarker tokens are not used if the macro is defined with no
arguments.
This might raise a ExceptionCpipDefineBadArguments if the list
does not match the prototype or a StopIteration if the token list is
too short.
This ignores leading and trailing whitespace for each argument.
TODO: Raise an ExceptionCpipDefineBadArguments if there is a #define
statement. e.g.:</p>
<div class="highlight-python"><pre>#define f(x) x x
f (1
#undef f
#define f 2
f)</pre>
</div>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.strIdentPlusParam">
<tt class="descname">strIdentPlusParam</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.strIdentPlusParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identifier name and parameters if a function-like macro
as a string.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.strReplacements">
<tt class="descname">strReplacements</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.strReplacements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the replacements tokens with minimised whitespace as a string.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.tokenCounter">
<tt class="descname">tokenCounter</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.tokenCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>The PpTokenCount object that counts tokens that have been consumed
from the input.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.tokensConsumed">
<tt class="descname">tokensConsumed</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.tokensConsumed" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of tokens consumed by the class.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpDefine.PpDefine.undef">
<tt class="descname">undef</tt><big>(</big><em>theFileId</em>, <em>theLineNum</em><big>)</big><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.undef" title="Permalink to this definition">¶</a></dt>
<dd><p>Records this instance of a macro #undef&#8217;d at a particular file
and line number. May raise an ExceptionCpipDefine if already undefined
of the line number is bad.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.undefFileId">
<tt class="descname">undefFileId</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.undefFileId" title="Permalink to this definition">¶</a></dt>
<dd><p>The file ID where this macro was undef&#8217;d or None.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpDefine.PpDefine.undefLine">
<tt class="descname">undefLine</tt><a class="headerlink" href="#cpip.core.PpDefine.PpDefine.undefLine" title="Permalink to this definition">¶</a></dt>
<dd><p>The line number where this macro was undef&#8217;d or None.</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-cpip.core.PpLexer"></span><p>Generates tokens from a C or C++ translation unit.</p>
<p>DONE: Add flag to include/exclude whitespace tokens in the generator.
NO: Also add a comment type of token?</p>
<p>DONE: Redesign initialiseTu() because it currently fails if ppTokens is
called twice in succession.
DONE: Test with (wrongly) indented #if #else etc. this seems to give an evaluation error.
See TestPpLexerConditional.test_14...
DONE: Variadic macros.
TODO: Fix accidental token pasting.
TODO: Preprocessor statements in arguments of function like macros. Sect. 3.9
of cpp.pdf and existing MacroEnv tests.
There for the call stack depth, D = A + 3 + 3L
Where L is the number of levels of nested includes and A is the call stack
depth of the function that calls ppTokens()
DONE: Complete but minimal TU to check coverage.
DONE: Have a token counting class rather than two integers at present
DONE: Mutex flag that prevents &gt;1 generator in play at any time.
DONE: Diagnostic has isDebug attribute. [Needs test case]
DONE: #if defned SPAM causes crash: ExceptionEvaluateExpression: Evaluation of &#8221; 0 0 0 0.0 &#8221; gives error: invalid syntax (&lt;string&gt;, line 1)</p>
<p>DONE: Missing pragma handler causes diagnostic unspecified which is INFO. Should this be warning?</p>
<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexer">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexer</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling PpLexer object.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerAlreadyGenerating">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerAlreadyGenerating</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerAlreadyGenerating" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when two generators are created then the internal state will become inconsistent.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerCallStack">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerCallStack</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerCallStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when finding issues with the call stack or nested includes.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerCallStackTooSmall">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerCallStackTooSmall</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerCallStackTooSmall" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when sys.getrecursionlimit() is too small.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerCondLevelOutOfRange">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerCondLevelOutOfRange</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerCondLevelOutOfRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling a conditional token generation level.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerDefine">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerDefine</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerDefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when loading predefined macro definitions.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerNestedInclueLimit">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerNestedInclueLimit</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerNestedInclueLimit" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when nested #include limit exceeded.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerNoFile">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerNoFile</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerNoFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when can not find file.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerPreInclude">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerPreInclude</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerPreInclude" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when loading pre-include files.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerPreIncludeIncNoCp">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerPreIncludeIncNoCp</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerPreIncludeIncNoCp" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when loading a pre-include file that has no current place
(e.g. a StringIO object) and the pre-include then has an #include
statement.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpLexer.ExceptionPpLexerPredefine">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">ExceptionPpLexerPredefine</tt><a class="headerlink" href="#cpip.core.PpLexer.ExceptionPpLexerPredefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when loading predefined macro definitions.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.PpLexer.PpLexer">
<em class="property">class </em><tt class="descclassname">cpip.core.PpLexer.</tt><tt class="descname">PpLexer</tt><big>(</big><em>tuFileId</em>, <em>includeHandler</em>, <em>preIncFiles=None</em>, <em>diagnostic=None</em>, <em>pragmaHandler=None</em><big>)</big><a class="headerlink" href="#cpip.core.PpLexer.PpLexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a translation unit tokeniser that applies ISO/IEC 9899:1999(E)
Section 6 and ISO/IEC 14882:1998(E) section 16.</p>
<dl class="docutils">
<dt><em>tuFileId</em></dt>
<dd>A file ID that will be given to the include
handler to find the translation unit.
Typically this will be the file path (as a string)
to the file that is the Initial Translation Unit
(ITU) i.e. the file being preprocessed.</dd>
<dt><em>includeHandler</em></dt>
<dd>A handler to file #includ&#8217;ed files typically a
IncludeHandler.IncludeHandlerStd().
This might have user and system include path
information and a means of resolving file
references.</dd>
<dt><em>preIncFiles</em></dt>
<dd>An ordered list of file like objects that are
pre-include files. These are processed in order
before the ITU is processed. Macro redefinition
rules apply.</dd>
<dt><em>diagnostic</em></dt>
<dd>A diagnostic object, defaults to a
CppDiagnostic.PreprocessDiagnosticStd().</dd>
<dt><em>pragmaHandler</em></dt>
<dd>A handler for #pragma statements. This shall have a
function pragma() defined that takes a non-zero
length list of PpTokens the last of which will be
a newline token.</dd>
</dl>
<p>TODO: Set flags here rather than supplying them to a generator?
This would make the API simply the ctor and ppTokens/next().
Flags would be:
incWs - Include whitespace tokens.
condLevel - (0, 1, 2) thus:</p>
<ol class="arabic" start="0">
<li><dl class="first docutils">
<dt>No conditionally compiled tokens. The fileIncludeGraphRoot will</dt>
<dd><p class="first last">not have any information about conditionally included files.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Conditionally compiled tokens are generated but not from </dt>
<dd><p class="first last">conditionally included files. The fileIncludeGraphRoot will have
a reference to a conditionally included file but not that
included file&#8217;s includes.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Conditionally compiled tokens including tokens from conditionally</dt>
<dd><p class="first last">included files. The fileIncludeGraphRoot will have all the
information about conditionally included files recursively.</p>
</dd>
</dl>
</li>
</ol>
<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.colNum">
<tt class="descname">colNum</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.colNum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current column number as an integer during processing.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.condCompGraph">
<tt class="descname">condCompGraph</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.condCompGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>The conditional compilation graph as a CppCond.CppCondGraph object.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.condState">
<tt class="descname">condState</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.condState" title="Permalink to this definition">¶</a></dt>
<dd><p>The conditional state as (boolean,  string).</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.currentFile">
<tt class="descname">currentFile</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.currentFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the file ID on the top of the file stack.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.definedMacros">
<tt class="descname">definedMacros</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.definedMacros" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the currently defined macros.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.fileIncludeGraphRoot">
<tt class="descname">fileIncludeGraphRoot</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.fileIncludeGraphRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the FileIncludeGraphRoot object.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.fileLineCol">
<tt class="descname">fileLineCol</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.fileLineCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a FileLineCol object or None</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.fileName">
<tt class="descname">fileName</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.fileName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current file name during processing.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.fileStack">
<tt class="descname">fileStack</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.fileStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the file stack.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpLexer.PpLexer.finalise">
<tt class="descname">finalise</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.finalise" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalisation, may raise any Exception.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.includeDepth">
<tt class="descname">includeDepth</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.includeDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the integer depth of the include stack.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.lineNum">
<tt class="descname">lineNum</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.lineNum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current line number as an integer during processing or None.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.macroEnvironment">
<tt class="descname">macroEnvironment</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.macroEnvironment" title="Permalink to this definition">¶</a></dt>
<dd><p>The current Macro environment as a MacroEnv object.
Caution: Write to this at your own risk. Your write might be ignored or
cause undefined behaviour.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpLexer.PpLexer.ppTokens">
<tt class="descname">ppTokens</tt><big>(</big><em>incWs=True</em>, <em>minWs=False</em>, <em>condLevel=0</em><big>)</big><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.ppTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>A generator for providing PpToken.PpTokens to section 16 of ISO/IEC 14882:1998(E).</p>
<p><em>incWs</em> - if True than whitespace tokens are included (i.e. tok.isWs() == True).</p>
<p><em>minWs</em> - if True then whitespace runs will be minimised to a single
space or, if  newline is in the whitespce run, a single newline</p>
<p><em>condLevel</em> - if True then conditionally compiled tokens will be yielded
and they will have have tok.isCond == True. The fileIncludeGraphRoot
will be marked up with the appropriate conditionality. Levels are:        
0: No conditionally compiled tokens. The fileIncludeGraphRoot will</p>
<blockquote>
<div>not have any information about conditionally included files.</div></blockquote>
<dl class="docutils">
<dt>1: Conditionally compiled tokens are generated but not from </dt>
<dd>conditionally included files. The fileIncludeGraphRoot will have
a reference to a conditionally included file but not that
included file&#8217;s includes.</dd>
<dt>2: Conditionally compiled tokens including tokens from conditionally</dt>
<dd>included files. The fileIncludeGraphRoot will have all the
information about conditionally included files recursively.</dd>
</dl>
<p>(see _cppInclude where we check if self._condStack.isTrue():).</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpLexer.PpLexer.tuFileId">
<tt class="descname">tuFileId</tt><a class="headerlink" href="#cpip.core.PpLexer.PpLexer.tuFileId" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the user supplied ID of the translation unit.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.PpToken"></span><p>Represents a preprocessing Token in C/C++ source code.</p>
<dl class="exception">
<dt id="cpip.core.PpToken.ExceptionCpipToken">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpToken.</tt><tt class="descname">ExceptionCpipToken</tt><a class="headerlink" href="#cpip.core.PpToken.ExceptionCpipToken" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by PpToken.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpToken.ExceptionCpipTokenIllegalMerge">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpToken.</tt><tt class="descname">ExceptionCpipTokenIllegalMerge</tt><a class="headerlink" href="#cpip.core.PpToken.ExceptionCpipTokenIllegalMerge" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by PpToken when merge() is called illegally.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpToken.ExceptionCpipTokenIllegalOperation">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpToken.</tt><tt class="descname">ExceptionCpipTokenIllegalOperation</tt><a class="headerlink" href="#cpip.core.PpToken.ExceptionCpipTokenIllegalOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by PpToken when an illegal operation is performed.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpToken.ExceptionCpipTokenReopenForExpansion">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpToken.</tt><tt class="descname">ExceptionCpipTokenReopenForExpansion</tt><a class="headerlink" href="#cpip.core.PpToken.ExceptionCpipTokenReopenForExpansion" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by PpToken when a non-expandable token is
made available for expansion.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpToken.ExceptionCpipTokenUnknownType">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpToken.</tt><tt class="descname">ExceptionCpipTokenUnknownType</tt><a class="headerlink" href="#cpip.core.PpToken.ExceptionCpipTokenUnknownType" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by PpToken when the token type is out of range.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.PpToken.PpToken">
<em class="property">class </em><tt class="descclassname">cpip.core.PpToken.</tt><tt class="descname">PpToken</tt><big>(</big><em>t</em>, <em>tt</em>, <em>lineNum=0</em>, <em>colNum=0</em><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds a preprocessor token, its type and whether the token can
be replaced.</p>
<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.canReplace">
<tt class="descname">canReplace</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.canReplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag to control whether this token is eligible for replacement</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.colNum">
<tt class="descname">colNum</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.colNum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the column number of the start of the token as an integer.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.evalConstExpr">
<tt class="descname">evalConstExpr</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.evalConstExpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an string value suitable for eval&#8217;ing in a constant expression.
For numbers this removes such tiresome trivia as &#8216;u&#8217;, &#8216;L&#8217; etc. For others
it replaces &#8216;&amp;&amp;&#8217; with &#8216;and&#8217; and so on.
See ISO/IEC ISO/IEC 14882:1998(E) 16.1 Conditional inclusion sub-section 4
i.e. section 16.1-4
And: ISO/IEC 9899:1999 (E) 6.10.1 Conditional inclusion sub-section 3
i.e. section 6.10.1-3</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.getPrevWs">
<tt class="descname">getPrevWs</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.getPrevWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the flag that records prior whitespace.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.getReplace">
<tt class="descname">getReplace</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.getReplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the flag that controls whether this can be replaced.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.isCond">
<tt class="descname">isCond</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.isCond" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag that if True indicates that the token appeared within a
section that was conditionally compiled. This is False on construction
and can only be set True by setIsCond()</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.isIdentifier">
<tt class="descname">isIdentifier</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.isIdentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the token type is &#8216;identifier&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.isUnCond">
<tt class="descname">isUnCond</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.isUnCond" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag that if True indicates that the token appeared within a
section that was un-conditionally compiled. This is the negation of
isCond.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.isWs">
<tt class="descname">isWs</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.isWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the token type is &#8216;whitespace&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.lineNum">
<tt class="descname">lineNum</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.lineNum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the line number of the start of the token as an integer.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.merge">
<tt class="descname">merge</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>This will merge by appending the other token if possible.
Failure will raise a ExceptionCpipTokenIllegalMerge if
the token types are different.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.prevWs">
<tt class="descname">prevWs</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.prevWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag to indicate whether this token is preceded by whitespace</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.replaceNewLine">
<tt class="descname">replaceNewLine</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.replaceNewLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace any newline with a single whitespace character in-place.
See: C ISO/IEC 9899:1999(E) 6.10-3 and C++ ISO/IEC 14882:1998(E) 16.3-9
This will raise a ExceptionCpipTokenIllegalOperation if I am not
a whitespace token.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.setIsCond">
<tt class="descname">setIsCond</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.setIsCond" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self._isCond to be True.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.setPrevWs">
<tt class="descname">setPrevWs</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.setPrevWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the flag that records prior whitespace.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.setReplace">
<tt class="descname">setReplace</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.setReplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Setter, will raise if I am not an identifier or val is True and
if I am otherwise not expandable.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.shrinkWs">
<tt class="descname">shrinkWs</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.shrinkWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all whitespace with a single &#8216; &#8216;
This will raise a ExceptionCpipTokenIllegalOperation if I am not
a whitespace token.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpToken.PpToken.subst">
<tt class="descname">subst</tt><big>(</big><em>t</em>, <em>tt</em><big>)</big><a class="headerlink" href="#cpip.core.PpToken.PpToken.subst" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes token value and type.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.t">
<tt class="descname">t</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.t" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the token as a string.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.tokEnumToktype">
<tt class="descname">tokEnumToktype</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.tokEnumToktype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the token and the enumerated token type as a tuple.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.tokToktype">
<tt class="descname">tokToktype</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.tokToktype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the token and the token type (as a string) as a tuple.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpToken.PpToken.tt">
<tt class="descname">tt</tt><a class="headerlink" href="#cpip.core.PpToken.PpToken.tt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the token type as a string.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cpip.core.PpToken.tokensStr">
<tt class="descclassname">cpip.core.PpToken.</tt><tt class="descname">tokensStr</tt><big>(</big><em>theTokens</em>, <em>shortForm=True</em><big>)</big><a class="headerlink" href="#cpip.core.PpToken.tokensStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of tokens this returns them as a string.</p>
</dd></dl>

<span class="target" id="module-cpip.core.PpTokenCount"></span><p>Keeps a count of Preprocessing tokens.</p>
<dl class="exception">
<dt id="cpip.core.PpTokenCount.ExceptionPpTokenCount">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpTokenCount.</tt><tt class="descname">ExceptionPpTokenCount</tt><a class="headerlink" href="#cpip.core.PpTokenCount.ExceptionPpTokenCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling PpTokenCount object.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpTokenCount.ExceptionPpTokenCountStack">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpTokenCount.</tt><tt class="descname">ExceptionPpTokenCountStack</tt><a class="headerlink" href="#cpip.core.PpTokenCount.ExceptionPpTokenCountStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling PpTokenCountStack object.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.PpTokenCount.PpTokenCountStack">
<em class="property">class </em><tt class="descclassname">cpip.core.PpTokenCount.</tt><tt class="descname">PpTokenCountStack</tt><a class="headerlink" href="#cpip.core.PpTokenCount.PpTokenCountStack" title="Permalink to this definition">¶</a></dt>
<dd><p>This simply holds a stack of PpTokenCount objects that can be created
and popped of the stack.</p>
<dl class="method">
<dt id="cpip.core.PpTokenCount.PpTokenCountStack.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokenCount.PpTokenCountStack.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalisation, will raise a ExceptionPpTokenCountStack if there is
anything on the stack.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokenCount.PpTokenCountStack.counter">
<tt class="descname">counter</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokenCount.PpTokenCountStack.counter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the current PpTokenCount object.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokenCount.PpTokenCountStack.pop">
<tt class="descname">pop</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokenCount.PpTokenCountStack.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pops the current PpTokenCount object off the stack and returns it.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokenCount.PpTokenCountStack.push">
<tt class="descname">push</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokenCount.PpTokenCountStack.push" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new counter object to the stack.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.PpTokeniser"></span><p>Performs translation phases 0, 1, 2, 3 on C/C++ source code.</p>
<p>Translation phases from ISO/IEC 9899:1999 (E):</p>
<p>5.1.1.2 Translation phases
5.1.1.2-1 The precedence among the syntax rules of translation is specified by
the following phases.</p>
<p>Phase 1. Physical source file multibyte characters are mapped, in an
implementation defined manner, to the source character set (introducing
new-line characters for end-of-line indicators) if necessary. Trigraph
sequences are replaced by corresponding single-character internal
representations.</p>
<p>Phase 2. Each instance of a backslash character () immediately followed by
a new-line character is deleted, splicing physical source lines to form
logical source lines. Only the last backslash on any physical source line
shall be eligible for being part of such a splice. A source file that is
not empty shall end in a new-line character, which shall not be immediately
preceded by a backslash character before any such splicing takes place.</p>
<p>Phase 3. The source file is decomposed into preprocessing tokens6) and
sequences of white-space characters (including comments). A source file
shall not end in a partial preprocessing token or in a partial comment.
Each comment is replaced by one space character. New-line characters are
retained. Whether each nonempty sequence of white-space characters other
than new-line is retained or replaced by one space character is
implementation-defined.</p>
<p>TODO: Do phases 0,1,2 as generators i.e. not in memory?
TODO: Check coverage with a complete but minimal example of every token
TODO: remove self._cppTokType and have it as a return value?
TODO: Remove commented out code.
TODO: Performance of phase 1 processing.
TODO: rename next() as genPpTokens()?</p>
<p>TODO: Perf rewrite slice functions to take an integer argument of where in the
array to start inspecting for a slice. This avoids calls to ...[x:] e.g.
myCharS = myCharS[sliceIdx:] in genLexPptokenAndSeqWs.</p>
<dl class="exception">
<dt id="cpip.core.PpTokeniser.ExceptionCpipTokeniser">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpTokeniser.</tt><tt class="descname">ExceptionCpipTokeniser</tt><a class="headerlink" href="#cpip.core.PpTokeniser.ExceptionCpipTokeniser" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for the preprocessor.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PpTokeniser.ExceptionCpipTokeniserUcnConstraint">
<em class="property">exception </em><tt class="descclassname">cpip.core.PpTokeniser.</tt><tt class="descname">ExceptionCpipTokeniserUcnConstraint</tt><a class="headerlink" href="#cpip.core.PpTokeniser.ExceptionCpipTokeniserUcnConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialisation for when universal character name exceeds constraints.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.PpTokeniser.PpTokeniser">
<em class="property">class </em><tt class="descclassname">cpip.core.PpTokeniser.</tt><tt class="descname">PpTokeniser</tt><big>(</big><em>theFileObj=None</em>, <em>theFileId=None</em>, <em>theDiagnostic=None</em><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser" title="Permalink to this definition">¶</a></dt>
<dd><p>Imitates a Preprocessor that conforms to ISO/IEC 14882:1998(E).
TODO: Escape sequences Table 5?</p>
<p>Implementation note on all _slice...() and __slice...() functions.
A _slice...() function takes a buffer-like object and an integer offset as
arguments. The buffer-like object will be accessed by index so just needs
to implement __getitem__(). On overrun or other out of bounds index an
IndexError must be caught by the _slice...() function.
i.e. len() should not be called on the buffer-like object, or rather, if
len() (i.e. __len__() ) is called a TypeError will be raised and propagated
out of this class to the caller.
For example StrTree conforms to these requirements.</p>
<p>The function is expected to return an integer that represents the number
of objects that can be consumed from the buffer-like object. If the
return value is non-zero the PpTokeniser is side-affected in that
self._cppTokType is set to a non-None value. Before doing that a test is
made and if self._cppTokType is already non-None then an assertion error
is raised.
The buffer-like object should not be side-affected by the _slice...()
function regardless of the return value.</p>
<p>So a _slice...() function pattern is:
def _slice...(self, theBuf, theOfs):</p>
<blockquote>
<div><p>i = theOfs
try:</p>
<blockquote>
<div><p># Only access theBuf with [i] so that __getitem__() is called
...theBuf[i]...
# Success as the absence of an IndexError!
# So return the length of objects that pass
# First test and set for type of slice found
if i &gt; theOfs:</p>
<blockquote>
<div>assert(self._cppTokType is None), &#8216;_cppTokType was %s now %s&#8217; % (self._cppTokType, ...)
self._cppTokType = ...</div></blockquote>
<p># NOTE: Return size of slice not the index of the end of the slice
return i - theOfs</p>
</div></blockquote>
<dl class="docutils">
<dt>except IndexError:</dt>
<dd>pass</dd>
</dl>
<p># Here either return 0 on IndexError or i-theOfs
return ...</p>
</div></blockquote>
<p>NOTE: Functions starting with __slice... do not trap the IndexError, the
caller must do that.</p>
<dl class="attribute">
<dt id="cpip.core.PpTokeniser.PpTokeniser.cppTokType">
<tt class="descname">cppTokType</tt><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.cppTokType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of the last preprocessing-token found by _sliceLexPptoken().</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpTokeniser.PpTokeniser.fileLineCol">
<tt class="descname">fileLineCol</tt><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.fileLineCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an instance of FileLineCol from the current physical line column.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpTokeniser.PpTokeniser.fileLocator">
<tt class="descname">fileLocator</tt><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.fileLocator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the FileLocation object.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpTokeniser.PpTokeniser.fileName">
<tt class="descname">fileName</tt><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.fileName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ID of the file.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.genLexPptokenAndSeqWs">
<tt class="descname">genLexPptokenAndSeqWs</tt><big>(</big><em>theCharS</em><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.genLexPptokenAndSeqWs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a sequence of PpToken objects. either:</p>
<blockquote>
<div><ul class="simple">
<li>a sequence of whitespace (comments are replaces with a single whitespace).</li>
<li>a pre-processing token.</li>
</ul>
</div></blockquote>
<p>This performs translation phasse 3.</p>
<p>NOTE: Whitespace sequences are not merged so <tt class="docutils literal"><span class="pre">'</span>&nbsp; <span class="pre">/\*\*/</span> <span class="pre">'</span></tt> will generate
three tokens each of <tt class="docutils literal"><span class="pre">PpToken.PpToken('</span> <span class="pre">',</span> <span class="pre">'whitespace')</span></tt>.
So this yields the tokens from translation phase 3 if supplied with
the results of translation phase 2.</p>
<p>NOTE: This does not generate &#8216;header-name&#8217; tokens as these are context
dependent i.e. they are only valid in the context of a #include
directive. ISO/IEC 9899:1999 (E) 6.4.7 Header names Para 3 says that:
&#8220;A header name preprocessing token is recognised only within a #include
preprocessing directive.&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.initLexPhase12">
<tt class="descname">initLexPhase12</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.initLexPhase12" title="Permalink to this definition">¶</a></dt>
<dd><p>Process phases one and two and returns the result as a string.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.lexPhases_0">
<tt class="descname">lexPhases_0</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.lexPhases_0" title="Permalink to this definition">¶</a></dt>
<dd><p>An non-standard phase that just reads the file and returns its
contents as a list of lines (including EOL characters).
May raise an ExceptionCpipTokeniser if self has been created with None
or the file is unreadable</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.lexPhases_1">
<tt class="descname">lexPhases_1</tt><big>(</big><em>theLineS</em><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.lexPhases_1" title="Permalink to this definition">¶</a></dt>
<dd><p>ISO/IEC 14882:1998(E) 2.1 Phases of translation [lex.phases] - Phase one
Takes a list of lines (including EOL characters), replaces trigraphs
and returns the new list of lines.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.lexPhases_2">
<tt class="descname">lexPhases_2</tt><big>(</big><em>theLineS</em><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.lexPhases_2" title="Permalink to this definition">¶</a></dt>
<dd><p>ISO/IEC 14882:1998(E) 2.1 Phases of translation [lex.phases] - Phase two
This joins physical to logical lines. NOTE: This side-effects the
supplied lines and returns None.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.next" title="Permalink to this definition">¶</a></dt>
<dd><p>The token generator. On being called this performs translations phases
1, 2 and 3 (unless already done) and then generates pairs of:
(preprocessing token, token type)
Token type is an enumerated integer from LEX_PPTOKEN_TYPES.
Proprocessing tokens include sequences of whitespace characters and
these are not necessarily concatenated i.e. this generator can produce
more than one whitespace token in sequence.
TODO: Rename this to ppTokens() or something</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PpTokeniser.PpTokeniser.pLineCol">
<tt class="descname">pLineCol</tt><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.pLineCol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current physical (line, column) as integers.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.reduceToksToHeaderName">
<tt class="descname">reduceToksToHeaderName</tt><big>(</big><em>theToks</em><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.reduceToksToHeaderName" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes a list of PpTokens and retuns a list of PpTokens
that might have a header-name token type in them.
May raise an ExceptionCpipTokeniser if tokens are not all consumed.
This is used at lexer level for re-interpreting PpTokens in the
context of a #include directive.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.resetTokType">
<tt class="descname">resetTokType</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.resetTokType" title="Permalink to this definition">¶</a></dt>
<dd><p>Erases the memory of the previously seen token type.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpTokeniser.PpTokeniser.substAltToken">
<tt class="descname">substAltToken</tt><big>(</big><em>tok</em><big>)</big><a class="headerlink" href="#cpip.core.PpTokeniser.PpTokeniser.substAltToken" title="Permalink to this definition">¶</a></dt>
<dd><p>If a PpToken is a Digraph this alters its value to its alternative.
If not the supplied token is returned unchanged.
There are no side effects on self.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.PpWhitespace"></span><p>Understands whitespacey things about source code character streams.</p>
<dl class="class">
<dt id="cpip.core.PpWhitespace.PpWhitespace">
<em class="property">class </em><tt class="descclassname">cpip.core.PpWhitespace.</tt><tt class="descname">PpWhitespace</tt><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that does whitespacey type things in accordance with
ISO/IEC 9899:1999(E) Section 6 and ISO/IEC 14882:1998(E).</p>
<dl class="method">
<dt id="cpip.core.PpWhitespace.PpWhitespace.hasLeadingWhitespace">
<tt class="descname">hasLeadingWhitespace</tt><big>(</big><em>theCharS</em><big>)</big><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace.hasLeadingWhitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if any leading whitespace, False if zero length or
starts with non-whitespace.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpWhitespace.PpWhitespace.isAllMacroWhitespace">
<tt class="descname">isAllMacroWhitespace</tt><big>(</big><em>theCharS</em><big>)</big><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace.isAllMacroWhitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;Return True if theCharS is zero length or only has allowable
whitespace for preprocesing macros.
ISO/IEC 14882:1998(E) 16-2 only &#8216; &#8216; and &#8216;       &#8216; as whitespace.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpWhitespace.PpWhitespace.isAllWhitespace">
<tt class="descname">isAllWhitespace</tt><big>(</big><em>theCharS</em><big>)</big><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace.isAllWhitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the supplied string is all whitespace.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpWhitespace.PpWhitespace.isBreakingWhitespace">
<tt class="descname">isBreakingWhitespace</tt><big>(</big><em>theCharS</em><big>)</big><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace.isBreakingWhitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if whitespace leads theChars and that whitespace
contains a newline.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpWhitespace.PpWhitespace.preceedsNewline">
<tt class="descname">preceedsNewline</tt><big>(</big><em>theCharS</em><big>)</big><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace.preceedsNewline" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if theChars ends with a newline. i.e. this immediately
precedes a new line.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpWhitespace.PpWhitespace.sliceNonWhitespace">
<tt class="descname">sliceNonWhitespace</tt><big>(</big><em>theBuf</em>, <em>theOfs=0</em><big>)</big><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace.sliceNonWhitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the length of non-whitespace characters that are in
theBuf from position theOfs.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.core.PpWhitespace.PpWhitespace.sliceWhitespace">
<tt class="descname">sliceWhitespace</tt><big>(</big><em>theBuf</em>, <em>theOfs=0</em><big>)</big><a class="headerlink" href="#cpip.core.PpWhitespace.PpWhitespace.sliceWhitespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the length of whitespace characters that are in theBuf from
position theOfs.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.core.PragmaHandler"></span><dl class="exception">
<dt id="cpip.core.PragmaHandler.ExceptionPragmaHandler">
<em class="property">exception </em><tt class="descclassname">cpip.core.PragmaHandler.</tt><tt class="descname">ExceptionPragmaHandler</tt><a class="headerlink" href="#cpip.core.PragmaHandler.ExceptionPragmaHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for the PragmaHandler.
If raised this will cause the PpLexer to register an undefined</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.core.PragmaHandler.ExceptionPragmaHandlerStopParsing">
<em class="property">exception </em><tt class="descclassname">cpip.core.PragmaHandler.</tt><tt class="descname">ExceptionPragmaHandlerStopParsing</tt><a class="headerlink" href="#cpip.core.PragmaHandler.ExceptionPragmaHandlerStopParsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for the PragmaHandler to stop parsing token stream.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.core.PragmaHandler.PragmaHandlerABC">
<em class="property">class </em><tt class="descclassname">cpip.core.PragmaHandler.</tt><tt class="descname">PragmaHandlerABC</tt><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerABC" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for a pragma handler.</p>
<dl class="method">
<dt id="cpip.core.PragmaHandler.PragmaHandlerABC.pragma">
<tt class="descname">pragma</tt><big>(</big><em>theTokS</em><big>)</big><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerABC.pragma" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of PpTokens, processes then and should return a newline
terminated string that will be preprocessed in the current environment.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PragmaHandler.PragmaHandlerABC.replaceTokens">
<tt class="descname">replaceTokens</tt><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerABC.replaceTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>An boolean attribute that says whether the supplied tokens should
be macro replaced before being passed to self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.PragmaHandler.PragmaHandlerNull">
<em class="property">class </em><tt class="descclassname">cpip.core.PragmaHandler.</tt><tt class="descname">PragmaHandlerNull</tt><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerNull" title="Permalink to this definition">¶</a></dt>
<dd><p>A pragma handler that does nothing.</p>
<dl class="method">
<dt id="cpip.core.PragmaHandler.PragmaHandlerNull.pragma">
<tt class="descname">pragma</tt><big>(</big><em>theTokS</em><big>)</big><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerNull.pragma" title="Permalink to this definition">¶</a></dt>
<dd><p>Consume and return.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PragmaHandler.PragmaHandlerNull.replaceTokens">
<tt class="descname">replaceTokens</tt><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerNull.replaceTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Tokens do not require macro replacement.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.core.PragmaHandler.PragmaHandlerSTDC">
<em class="property">class </em><tt class="descclassname">cpip.core.PragmaHandler.</tt><tt class="descname">PragmaHandlerSTDC</tt><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerSTDC" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for a pragma handler that implements ISO/IEC 9899:1999 (E)
6.10.5 Error directive para. 2.</p>
<dl class="method">
<dt id="cpip.core.PragmaHandler.PragmaHandlerSTDC.pragma">
<tt class="descname">pragma</tt><big>(</big><em>theTokS</em><big>)</big><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerSTDC.pragma" title="Permalink to this definition">¶</a></dt>
<dd><p>Inject a macro declaration into the environment.
See ISO/IEC 9899:1999 (E) 6.10.5 Error directive para. 2.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.core.PragmaHandler.PragmaHandlerSTDC.replaceTokens">
<tt class="descname">replaceTokens</tt><a class="headerlink" href="#cpip.core.PragmaHandler.PragmaHandlerSTDC.replaceTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>STDC lines do not require macro replacement.</p>
</dd></dl>

</dd></dl>

<p>cpip.plot:</p>
<span class="target" id="module-cpip.plot.Coord"></span><dl class="class">
<dt id="cpip.plot.Coord.Dim">
<em class="property">class </em><tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">Dim</tt><a class="headerlink" href="#cpip.plot.Coord.Dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a dimension as an engineering value i.e. a number and units.</p>
<dl class="method">
<dt id="cpip.plot.Coord.Dim.convert">
<tt class="descname">convert</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.Dim.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Dim() with units changed and value converted.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.Coord.Dim.scale">
<tt class="descname">scale</tt><big>(</big><em>factor</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.Dim.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Dim() scaled by a factor, units are unchanged.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="cpip.plot.Coord.ExceptionCoord">
<em class="property">exception </em><tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">ExceptionCoord</tt><a class="headerlink" href="#cpip.plot.Coord.ExceptionCoord" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for representing Coordinates.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.plot.Coord.ExceptionCoordUnitConvert">
<em class="property">exception </em><tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">ExceptionCoordUnitConvert</tt><a class="headerlink" href="#cpip.plot.Coord.ExceptionCoordUnitConvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised when converting units.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.Coord.Pad">
<em class="property">class </em><tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">Pad</tt><a class="headerlink" href="#cpip.plot.Coord.Pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Padding around another object that forms the Bounding Box.
All 4 attributes are Dim() objects</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.Coord.Pt">
<em class="property">class </em><tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">Pt</tt><a class="headerlink" href="#cpip.plot.Coord.Pt" title="Permalink to this definition">¶</a></dt>
<dd><p>A point, an absolute x/y position on the plot area.
Members are Coord.Dim().</p>
<dl class="method">
<dt id="cpip.plot.Coord.Pt.convert">
<tt class="descname">convert</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.Pt.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Pt() with units changed and value converted.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.Coord.Pt.scale">
<tt class="descname">scale</tt><big>(</big><em>factor</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.Pt.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Pt() scaled by a factor, units are unchanged.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.baseUnitsDim">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">baseUnitsDim</tt><big>(</big><em>theLen</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.baseUnitsDim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Coord.Dim() of length and units BASE_UNITS.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.convert">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">convert</tt><big>(</big><em>val</em>, <em>unitFrom</em>, <em>unitTo</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a value from one set of units to another.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.convertPt">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">convertPt</tt><big>(</big><em>theP</em>, <em>theUnits</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.convertPt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new point with the dimensions of theP converted to theUnits.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.newPt">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">newPt</tt><big>(</big><em>theP</em>, <em>incX=None</em>, <em>incY=None</em><big>)</big><a class="headerlink" href="#cpip.plot.Coord.newPt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Pt object by incrementing existing point incX, incY
that are both Dim() objects or None.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.units">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">units</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.Coord.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unsorted list of acceptable units.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.zeroBaseUnitsBox">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">zeroBaseUnitsBox</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.Coord.zeroBaseUnitsBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Coord.Box() of zero dimensions and units BASE_UNITS.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.zeroBaseUnitsDim">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">zeroBaseUnitsDim</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.Coord.zeroBaseUnitsDim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Coord.Dim() of zero length and units BASE_UNITS.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.zeroBaseUnitsPad">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">zeroBaseUnitsPad</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.Coord.zeroBaseUnitsPad" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Coord.Pad() of zero dimensions and units BASE_UNITS.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.Coord.zeroBaseUnitsPt">
<tt class="descclassname">cpip.plot.Coord.</tt><tt class="descname">zeroBaseUnitsPt</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.Coord.zeroBaseUnitsPt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Coord.Dim() of zero length and units BASE_UNITS.</p>
</dd></dl>

<span class="target" id="module-cpip.plot.PlotNode"></span><div class="section" id="bounding-boxes">
<h2>Bounding Boxes<a class="headerlink" href="#bounding-boxes" title="Permalink to this headline">¶</a></h2>
<p>Legend for the drawing below:
<a href="#id1"><span class="problematic" id="id2">**</span></a>** - Self sigma BB.
~~~~ - Self pad box
#### - Self width and depth.
.... - All children
++++ - Child[n] sigma BB.</p>
<p>i.e. For a child its ++++ is equivalent to my <a href="#id3"><span class="problematic" id="id4">**</span></a><a href="#id5"><span class="problematic" id="id6">**</span></a>.</p>
<p>D      - Self datum point.
S      - Self plot datum point.
x[n]   - Child datum point.
Pl     - Parent landing point to self.
Pt     - Parent take-off point from self.
P[n]   - Self take off point and landing point to child n.
pl[n]  - Child n landing point from self.
pt[n]  - Child n take-off point to self.
tdc    - Top dead centre.</p>
<p>Box .... has depth of max(Boxes(++++).width) and
width max(Box(~~~~), sum(Boxes(++++).depth)).</p>
<p>Each instance of class knows about the following:
Boxes:
<a href="#id7"><span class="problematic" id="id8">**</span></a>** - Self sigma BB as computed Dim() objects: self.bbSigmaDepth and</p>
<blockquote>
<div>self.bbSigmaWidth. Or as computed Box() object self.bbSigma</div></blockquote>
<p>~~~~ - As computed Dim() objects: self.bbSelfWidth, self.bbSelfDepth
#### - Self width and depth as Dim() objects: self.width and self.depth
.... - All children as a Box() object: self.bbChildren
And padding between ~~~~ and .... as Dim() object self.bbSpaceChildren</p>
<p>i.e. not ++++ - Child[n] sigma BB. That the caller knows about its children.</p>
<p>Points:
Given D each instance of this class knows:
S, Pl, Pt, P[0] to P[N-1], x[0], tdc (only).</p>
<p>In the following diagrams where lines are adjacent that means that there is no
spacing between them.</p>
<dl class="docutils">
<dt>-<a href="#id9"><span class="problematic" id="id10">|</span></a>&#8212;&#8211;&gt; x increases</dt>
<dd><div class="first last line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</dd>
</dl>
<p>/
y increases</p>
<p>D <strong>***********************************************************************</strong>
*                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     *
*                ~                                    ~                     *
*                ~    S ### Pl ###tdc### Pt ######    ~                     *
*                ~    #                          #    ~                     *
*                ~    #                          #    ~                     *
*                ~    #                          #    ~                     *
*                ~    #                          #    ~                     *
*                ~    ## P[0] ## P[c] ## P[C-1] ##    ~                     *
*                ~                                    ~                     *
*                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     *
*                                        |                                  *
*                                        <a href="#id11"><span class="problematic" id="id12">|</span></a>= self._bbSpaceChildren           *
*                                        |                                  *
<em>...........................................................................</em>
<em>.x[0] + pl[0] + pt[0] +x[c] + pl[c] + pt[c] ++++++++++++x[C-1]+pl/pt[C-1]+.</em>
<em>.+                    ++                               ++                +.</em>
<em>.+                    ++                               ++                +.</em>
<em>.+++++++++++++++++++++++                               ++                +.</em>
<em>.                      +                               ++                +.</em>
<em>.                      +                               +++++++++++++++++++.</em>
<em>.                      +                               +                  .</em>
<em>.                      +++++++++++++++++++++++++++++++++                  .</em>
<em>...........................................................................</em>
<strong>*************************************************************************</strong></p>
<p>Note: .... can be narrower than ~~~~</p>
</div>
<div class="section" id="verticies">
<h2>Verticies<a class="headerlink" href="#verticies" title="Permalink to this headline">¶</a></h2>
<p>The following show root at the left. Linking parent to child:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>PC_land    PC_stop</dt>
<dd><div class="first line-block">
<div class="line"><a href="#id13"><span class="problematic" id="id14">|</span></a></div>
</div>
<p class="last">x&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;x</p>
</dd>
</dl>
<p>/</p>
</div></blockquote>
<p>/</p>
</div></blockquote>
<p>x&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;x/
|            |</p>
</div></blockquote>
<p>PC_roll        PC_to</p>
<p>PC_roll and PC_to are determined by the parent.
PC_land and PC_stop are determined by the child.</p>
<p>And child to parent:</p>
<dl class="docutils">
<dt>CP_stop     CP_land</dt>
<dd><div class="first line-block">
<div class="line"><a href="#id15"><span class="problematic" id="id16">|</span></a></div>
</div>
<dl class="last docutils">
<dt>x&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;x                                                      x&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;x</dt>
<dd><blockquote class="first">
<div><div class="line-block">
<div class="line"><a href="#id17"><span class="problematic" id="id18">|</span></a></div>
</div>
</div></blockquote>
<p class="last">CP_to        CP_roll</p>
</dd>
</dl>
</dd>
</dl>
<p>CP_roll and CP_to are determined by the child.
CP_land and CP_stop are determined by the parent.</p>
<dl class="exception">
<dt id="cpip.plot.PlotNode.ExceptionPlotNode">
<em class="property">exception </em><tt class="descclassname">cpip.plot.PlotNode.</tt><tt class="descname">ExceptionPlotNode</tt><a class="headerlink" href="#cpip.plot.PlotNode.ExceptionPlotNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling PlotNodeBbox object.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.PlotNode.PlotNodeBbox">
<em class="property">class </em><tt class="descclassname">cpip.plot.PlotNode.</tt><tt class="descname">PlotNodeBbox</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that can hold the width and depth of an object and
the bounding box of self and the children.
This can then compute various dimensions of self and children.</p>
<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbChildren">
<tt class="descname">bbChildren</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounding box of children as a Coord.Box() or None.
i.e. the box ....</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbChildrenDepth">
<tt class="descname">bbChildrenDepth</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbChildrenDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounding box depth of children as a Coord.Dim() or None.
i.e. the depth of box ....</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbChildrenWidth">
<tt class="descname">bbChildrenWidth</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbChildrenWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounding box width of children as a Coord.Dim() or None.
i.e. the width of box ....</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbSelfDepth">
<tt class="descname">bbSelfDepth</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbSelfDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of self plus padding as a Coord.Dim().
i.e. the depth of box ~~~~</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbSelfPadding">
<tt class="descname">bbSelfPadding</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbSelfPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>The immediate padding around self as a Coord.Pad().</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbSelfWidth">
<tt class="descname">bbSelfWidth</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbSelfWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of self plus padding as a Coord.Dim() or None.
i.e. the width of box ~~~~</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbSigma">
<tt class="descname">bbSigma</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounding box of self and my children as a Coord.Box().</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbSigmaDepth">
<tt class="descname">bbSigmaDepth</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbSigmaDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of self+children as a Coord.Dim() or None in the case that
I don&#8217;t exist and I have no children.
i.e. the depth of box <a href="#id19"><span class="problematic" id="id20">**</span></a><a href="#id21"><span class="problematic" id="id22">**</span></a></p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbSigmaWidth">
<tt class="descname">bbSigmaWidth</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbSigmaWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of self+children as a Coord.Dim() or None in the case that
I don&#8217;t exist and I have no children.
i.e. the width of box <a href="#id23"><span class="problematic" id="id24">**</span></a><a href="#id25"><span class="problematic" id="id26">**</span></a></p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.bbSpaceChildren">
<tt class="descname">bbSpaceChildren</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.bbSpaceChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>The additional distance to give to the children as a
Coord.Dim().</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.box">
<tt class="descname">box</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.box" title="Permalink to this definition">¶</a></dt>
<dd><p>The Coord.Box() of ####.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.childBboxDatum">
<tt class="descname">childBboxDatum</tt><big>(</big><em>theDatum</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.childBboxDatum" title="Permalink to this definition">¶</a></dt>
<dd><p>The point x[0] as a Coord.Pt() given theDatum as Coord.Pt() or None
if no children.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.depth">
<tt class="descname">depth</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The immediate depth of the node, if None then no BB depth or
bbSpaceChildrend is allocated. i.e. the depth of box ####</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.extendChildBbox">
<tt class="descname">extendChildBbox</tt><big>(</big><em>theChildBbox</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.extendChildBbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the child bounding box by the amount theChildBbox which
should be a Coord.Box(). This extends the .... line.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.hasSetArea">
<tt class="descname">hasSetArea</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.hasSetArea" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if width and depth are set, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.plotPointCentre">
<tt class="descname">plotPointCentre</tt><big>(</big><em>theLd</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.plotPointCentre" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the logical point at the centre of the box shown as #### above.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.plotPointSelf">
<tt class="descname">plotPointSelf</tt><big>(</big><em>theDatum</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.plotPointSelf" title="Permalink to this definition">¶</a></dt>
<dd><p>The point S as a Coord.Pt() given theDatum as Coord.Pt().</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.PlotNode.PlotNodeBbox.width">
<tt class="descname">width</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBbox.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The immediate width of the node, if None then no BB width is
allocated. i.e. the width of box ####</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy">
<em class="property">class </em><tt class="descclassname">cpip.plot.PlotNode.</tt><tt class="descname">PlotNodeBboxBoxy</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-class parent child edges that contact the corners of the
box shown as #### above.</p>
<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.cpLand">
<tt class="descname">cpLand</tt><big>(</big><em>theLd</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.cpLand" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-from-child landing point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.cpRoll">
<tt class="descname">cpRoll</tt><big>(</big><em>theLd</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.cpRoll" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-child-to-parent start point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.cpStop">
<tt class="descname">cpStop</tt><big>(</big><em>theLd</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.cpStop" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-from-child stop point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.cpTo">
<tt class="descname">cpTo</tt><big>(</big><em>theLd</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.cpTo" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-child-to-parent take off point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.pcLand">
<tt class="descname">pcLand</tt><big>(</big><em>theLd</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.pcLand" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent-to-me-as-child landing point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.pcRoll">
<tt class="descname">pcRoll</tt><big>(</big><em>theDatum</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.pcRoll" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-to-child logical start point given the logical datum
as a Coord.Pt and the child ordinal. This gives equispaced points along
the lower edge.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.pcStop">
<tt class="descname">pcStop</tt><big>(</big><em>theLd</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.pcStop" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent-to-me-as-child stop point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxBoxy.pcTo">
<tt class="descname">pcTo</tt><big>(</big><em>theDatum</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxBoxy.pcTo" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-to-child logical take off point given the logical
datum as a Coord.Pt ind the child ordinal. This gives equispaced points
along the lower edge.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy">
<em class="property">class </em><tt class="descclassname">cpip.plot.PlotNode.</tt><tt class="descname">PlotNodeBboxRoundy</tt><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-class for parent child edges that contact the centre of the
box shown as #### above.</p>
<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.cpLand">
<tt class="descname">cpLand</tt><big>(</big><em>theDatumL</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.cpLand" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-from-child landing point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.cpRoll">
<tt class="descname">cpRoll</tt><big>(</big><em>theDatumL</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.cpRoll" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-child-to-parent start point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.cpStop">
<tt class="descname">cpStop</tt><big>(</big><em>theDatumL</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.cpStop" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-from-child stop point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.cpTo">
<tt class="descname">cpTo</tt><big>(</big><em>theDatumL</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.cpTo" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-child-to-parent take off point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.pcLand">
<tt class="descname">pcLand</tt><big>(</big><em>theDatumL</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.pcLand" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent-to-me-as-child landing point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.pcRoll">
<tt class="descname">pcRoll</tt><big>(</big><em>theDatumL</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.pcRoll" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-to-child logical start point given the logical datum
as a Coord.Pt ind the child ordinal. This gives equispaced points along
the lower edge.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.pcStop">
<tt class="descname">pcStop</tt><big>(</big><em>theDatumL</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.pcStop" title="Permalink to this definition">¶</a></dt>
<dd><p>The parent-to-me-as-child stop point given the logical datum as a Coord.Pt.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.PlotNode.PlotNodeBboxRoundy.pcTo">
<tt class="descname">pcTo</tt><big>(</big><em>theDatumL</em>, <em>childIndex</em><big>)</big><a class="headerlink" href="#cpip.plot.PlotNode.PlotNodeBboxRoundy.pcTo" title="Permalink to this definition">¶</a></dt>
<dd><p>The me-as-parent-to-child logical take off point given the logical
datum as a Coord.Pt ind the child ordinal. This gives equispaced points
along the lower edge.</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-cpip.plot.SVGWriter"></span><p>An SVG writer.</p>
<dl class="exception">
<dt id="cpip.plot.SVGWriter.ExceptionSVGWriter">
<em class="property">exception </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">ExceptionSVGWriter</tt><a class="headerlink" href="#cpip.plot.SVGWriter.ExceptionSVGWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for SVGWriter.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGCircle">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGCircle</tt><big>(</big><em>theXmlStream</em>, <em>thePoint</em>, <em>theRadius</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGCircle" title="Permalink to this definition">¶</a></dt>
<dd><p>A circle in SVG. See: <a class="reference external" href="http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#CircleElement">http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#CircleElement</a></p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGElipse">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGElipse</tt><big>(</big><em>theXmlStream</em>, <em>ptFrom</em>, <em>theRadX</em>, <em>theRadY</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGElipse" title="Permalink to this definition">¶</a></dt>
<dd><p>An elipse in SVG. See: <a class="reference external" href="http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#EllipseElement">http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#EllipseElement</a></p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGGroup">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGGroup</tt><big>(</big><em>theXmlStream</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>A group element in SVG.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGLine">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGLine</tt><big>(</big><em>theXmlStream</em>, <em>ptFrom</em>, <em>ptTo</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGLine" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectangle in SVG. See: <a class="reference external" href="http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#LineElement">http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#LineElement</a></p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGPointList">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGPointList</tt><big>(</big><em>theXmlStream</em>, <em>name</em>, <em>pointS</em>, <em>attrs</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGPointList" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class that takes a list of points, derived by polyline and polygon.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGPolygon">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGPolygon</tt><big>(</big><em>theXmlStream</em>, <em>pointS</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGPolygon" title="Permalink to this definition">¶</a></dt>
<dd><p>A polygon in SVG. See: <a class="reference external" href="http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#PolygonElement">http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#PolygonElement</a></p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGPolyline">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGPolyline</tt><big>(</big><em>theXmlStream</em>, <em>pointS</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGPolyline" title="Permalink to this definition">¶</a></dt>
<dd><p>A polyline in SVG. See: <a class="reference external" href="http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#PolylineElement">http://www.w3.org/TR/2003/REC-SVG11-20030114/shapes.html#PolylineElement</a></p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGRect">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGRect</tt><big>(</big><em>theXmlStream</em>, <em>thePoint</em>, <em>theBox</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGRect" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectangle in SVG.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.SVGWriter.SVGText">
<em class="property">class </em><tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">SVGText</tt><big>(</big><em>theXmlStream</em>, <em>thePoint</em>, <em>theFont</em>, <em>theSize</em>, <em>attrs=None</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.SVGText" title="Permalink to this definition">¶</a></dt>
<dd><p>Text in SVG. See: <a class="reference external" href="http://www.w3.org/TR/2003/REC-SVG11-20030114/text.html#TextElement">http://www.w3.org/TR/2003/REC-SVG11-20030114/text.html#TextElement</a></p>
</dd></dl>

<dl class="function">
<dt id="cpip.plot.SVGWriter.dimToTxt">
<tt class="descclassname">cpip.plot.SVGWriter.</tt><tt class="descname">dimToTxt</tt><big>(</big><em>theDim</em><big>)</big><a class="headerlink" href="#cpip.plot.SVGWriter.dimToTxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Coord.Dim() object to text for SVG units.</p>
</dd></dl>

<span class="target" id="module-cpip.plot.TreePlotTransform"></span><p>Provides a means of re-interpreting the coordinate system when plotting
trees so that the the tree root can be top/left/bottom/right and the child
order plotted anti-clockwise or clockwise.</p>
<p>This can convert &#8216;logical&#8217; positions into &#8216;physical&#8217; positions. Where a
&#8216;logical&#8217; position is one with the root of the tree at the top and the
child nodes in left-to-right (i.e. anti-clockwise) order.
A &#8216;physical&#8217; position is a plot-able position where the root of the tree is
top/left/bottom or right and the child nodes are in anti-clockwise or
clockwise order.</p>
<div class="section" id="transfoming-sizes-and-positions">
<h2>Transfoming sizes and positions<a class="headerlink" href="#transfoming-sizes-and-positions" title="Permalink to this headline">¶</a></h2>
<p>Given:
If the first suffix is &#8216;l&#8217; this is the &#8220;logical&#8221; coordinate system.                                
If the first suffix is &#8216;p&#8217; this is the &#8220;physical&#8221; coordinate system.</p>
<p>C    The canvas dimension, Cpw is &#8220;Canvas physical width&#8221;                            
W    Width dimension, physical and logical.                            
D    Depth dimension, physical and logical.                            
B    Box datum position (&#8220;top-left&#8221;), physical and logical, x and y.                            
P    Arbitrary point, physical and logical, x and y.</p>
<p>So this &#8220;logical view&#8221; of the tree graph (&#8216;top&#8217; and &#8216;-&#8216;):
i.e. Root(s) is a top and children are written in an anti-clockwise.</p>
<blockquote>
<div>&#8212;&gt; x
|
/
y</div></blockquote>
<p>&lt;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212; Clw &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&gt;
|                                  To Parent
|                                     |
|             Blx, Bly &#8211;&gt;*************************
|                         *                  |    *
Cld                       *                 Dl    *
|                         <em>&lt;&#8212;&#8212;&#8211; Wl &#8212;&#8211;|&#8212;&gt;</em>
|                         *                  |    *
|       Plx, Ply -&gt;.      *                  |    *
|                         <strong>*********************</strong>
|                             |        |       |
|                        To C[0]  To C[c]   To C[C-1]</p>
<p>Origin Cpw    Cpd    Wp    Dp    Bpx            Bpy            Ppx        Ppy
&#8212;&#8212; &#8212;    &#8212;    &#8211;    &#8211;    &#8212;            &#8212;            &#8212;        &#8212;
top    Clw    Cld    Wl    Dl    Blx            Bly            Plx        Ply
left   Cld    Clw    Dl    Wl    Bly            (Clw-Plx-Wl)   Ply        Clw-Plx
bottom Clw    Cld    Wl    Dl    (Clw-Plx-Wl)   (Cld-Ply-Dl)   Clw-Plx    Cld-Ply
right  Cld    Clw    Dl    Wl    (Cld-Ply-Dl)   Blx            Cld-Ply    Plx</p>
<p>Note the diagonal top-right to bottom-left transference between each pair of
columns. That is because with each successive line we are doing a 90 degree
rotation (anti-clockwise) plus a +ve y translation by Clw (top-&gt;left or 
bottom-&gt;right) or Cld (left-&gt;bottom or right-&gt;top).</p>
</div>
<div class="section" id="incrementing-child-positions">
<h2>Incrementing child positions<a class="headerlink" href="#incrementing-child-positions" title="Permalink to this headline">¶</a></h2>
<p>Moving from one child to another is done in the following combinations:</p>
<p>Origin    &#8216;-&#8216;    &#8216;+&#8217;
&#8212;&#8212;    &#8212;    &#8212;
top       right  left
left      up     down
bottom    left   right
right     down   up</p>
<dl class="exception">
<dt id="cpip.plot.TreePlotTransform.ExceptionTreePlotTransform">
<em class="property">exception </em><tt class="descclassname">cpip.plot.TreePlotTransform.</tt><tt class="descname">ExceptionTreePlotTransform</tt><a class="headerlink" href="#cpip.plot.TreePlotTransform.ExceptionTreePlotTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for TreePlotTransform.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.plot.TreePlotTransform.ExceptionTreePlotTransformRangeCtor">
<em class="property">exception </em><tt class="descclassname">cpip.plot.TreePlotTransform.</tt><tt class="descname">ExceptionTreePlotTransformRangeCtor</tt><a class="headerlink" href="#cpip.plot.TreePlotTransform.ExceptionTreePlotTransformRangeCtor" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for out of range input on construction.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform">
<em class="property">class </em><tt class="descclassname">cpip.plot.TreePlotTransform.</tt><tt class="descname">TreePlotTransform</tt><big>(</big><em>theLogicalCanvas</em>, <em>rootPos='top'</em>, <em>sweepDir='-'</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a means of re-interpreting the coordinate system when plotting trees.</p>
<p>rootPosition = frozenset([&#8216;top&#8217;, &#8216;bottom&#8217;, &#8216;left&#8217;, &#8216;right&#8217;])
default: &#8216;top&#8217;</p>
<p>sweepDirection = frozenset([&#8216;+&#8217;, &#8216;-&#8216;])
default: &#8216;-&#8216;</p>
<p>Has functionality for interpreting width/depth to actual postions
given rootPostion.</p>
<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.bdcL">
<tt class="descname">bdcL</tt><big>(</big><em>theBlxy</em>, <em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.bdcL" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical datum (logical top left) and a logical box this
returns logical bottom dead centre of a box.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.bdcP">
<tt class="descname">bdcP</tt><big>(</big><em>theBlxy</em>, <em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.bdcP" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical datum (logical top left) and a logical box this
returns physical bottom dead centre of a box.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.boxDatumP">
<tt class="descname">boxDatumP</tt><big>(</big><em>theBlxy</em>, <em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.boxDatumP" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical point and logical box this returns a physical
point that is the box datum (&#8220;upper left&#8221;).</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.boxP">
<tt class="descname">boxP</tt><big>(</big><em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.boxP" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical box this returns a Coord.Box that describes the physical box.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.canvasP">
<tt class="descname">canvasP</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.canvasP" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Coord.Box that describes the physical canvass.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.genRootPos">
<tt class="descname">genRootPos</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.genRootPos" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield all possible root positions.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.genSweepDir">
<tt class="descname">genSweepDir</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.genSweepDir" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield all possible root positions.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.incPhysicalChildPos">
<tt class="descname">incPhysicalChildPos</tt><big>(</big><em>thePt</em>, <em>theDim</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.incPhysicalChildPos" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a child physical datum point and a distance to next child this
returns the next childs physical datum point.
TODO: Remove this as redundant?</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.nextdcL">
<tt class="descname">nextdcL</tt><big>(</big><em>theBlxy</em>, <em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.nextdcL" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical datum (logical top left) and a logical box this
returns logical &#8216;next&#8217; dead centre of a box.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.positiveSweepDir">
<tt class="descname">positiveSweepDir</tt><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.positiveSweepDir" title="Permalink to this definition">¶</a></dt>
<dd><p>True if positive sweep, false otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.postIncChildLogicalPos">
<tt class="descname">postIncChildLogicalPos</tt><big>(</big><em>thePt</em>, <em>theBox</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.postIncChildLogicalPos" title="Permalink to this definition">¶</a></dt>
<dd><p>Post-incrempents the child logical datum point (&#8216;top-left&#8217;) given
the child logical datum point and the child.bbSigma.
Returns a Coord.Pt().
This takes into account the sweep direction.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.preIncChildLogicalPos">
<tt class="descname">preIncChildLogicalPos</tt><big>(</big><em>thePt</em>, <em>theBox</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.preIncChildLogicalPos" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-incrempents the child logical datum point (&#8216;top-left&#8217;) given
the child logical datum point and the child.bbSigma.
Returns a Coord.Pt().
This takes into account the sweep direction.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.prevdcL">
<tt class="descname">prevdcL</tt><big>(</big><em>theBlxy</em>, <em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.prevdcL" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical datum (logical top left) and a logical box this
returns logical &#8216;previous&#8217; dead centre of a box.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.pt">
<tt class="descname">pt</tt><big>(</big><em>thePt</em>, <em>units=None</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.pt" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an arbitrary logical point as a Coord.Pt(), this returns the
physical point as a Coord.Pt().
If units is supplied then the return value will be in those units.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.startChildrenLogicalPos">
<tt class="descname">startChildrenLogicalPos</tt><big>(</big><em>thePt</em>, <em>theBox</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.startChildrenLogicalPos" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the starting child logical datum point (&#8216;top-left&#8217;) given
the children logical datum point and the children.bbSigma.
Returns a Coord.Pt().
This takes into account the sweep direction.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.tdcL">
<tt class="descname">tdcL</tt><big>(</big><em>theBlxy</em>, <em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.tdcL" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical datum (logical top left) and a logical box this
returns logical top dead centre of a box.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.plot.TreePlotTransform.TreePlotTransform.tdcP">
<tt class="descname">tdcP</tt><big>(</big><em>theBlxy</em>, <em>theBl</em><big>)</big><a class="headerlink" href="#cpip.plot.TreePlotTransform.TreePlotTransform.tdcP" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logical datum (logical top left) and a logical box this
returns physical top dead centre of a box.</p>
</dd></dl>

</dd></dl>

</div>
<p>cpip.util:</p>
<span class="target" id="module-cpip.util.BufGen"></span><p>A generator class with a buffer. This allows multiple inspections of the
stream issued by a generator. For example this is used by MaxMunchGen.</p>
<dl class="class">
<dt id="cpip.util.BufGen.BufGen">
<em class="property">class </em><tt class="descclassname">cpip.util.BufGen.</tt><tt class="descname">BufGen</tt><big>(</big><em>theGen</em><big>)</big><a class="headerlink" href="#cpip.util.BufGen.BufGen" title="Permalink to this definition">¶</a></dt>
<dd><p>A generator class with a buffer.</p>
<dl class="method">
<dt id="cpip.util.BufGen.BufGen.gen">
<tt class="descname">gen</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.BufGen.BufGen.gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield objects from the generator via the buffer.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.util.BufGen.BufGen.lenBuf">
<tt class="descname">lenBuf</tt><a class="headerlink" href="#cpip.util.BufGen.BufGen.lenBuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the length of the existing buffer. NOTE: This may not be the
final length as the generator might not be exhausted just yet.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.BufGen.BufGen.replace">
<tt class="descname">replace</tt><big>(</big><em>theIdx</em>, <em>theLen</em>, <em>theValueS</em><big>)</big><a class="headerlink" href="#cpip.util.BufGen.BufGen.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces within the buffer starting at theIdx removing theLen objects
and replacing them with theValueS.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.BufGen.BufGen.slice">
<tt class="descname">slice</tt><big>(</big><em>sliceLen</em><big>)</big><a class="headerlink" href="#cpip.util.BufGen.BufGen.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a buffer slice of length sliceLen.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="cpip.util.BufGen.ExceptionBufGen">
<em class="property">exception </em><tt class="descclassname">cpip.util.BufGen.</tt><tt class="descname">ExceptionBufGen</tt><a class="headerlink" href="#cpip.util.BufGen.ExceptionBufGen" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception specialisation for BufGen.</p>
</dd></dl>

<span class="target" id="module-cpip.util.DictTree"></span><p>A dictionary that takes a list of hashables as a key and behaves like a tree.</p>
<dl class="class">
<dt id="cpip.util.DictTree.DictTree">
<em class="property">class </em><tt class="descclassname">cpip.util.DictTree.</tt><tt class="descname">DictTree</tt><big>(</big><em>valIterable=None</em><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTree" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary that takes a list of hashables as a key and behaves like a tree</p>
<dl class="method">
<dt id="cpip.util.DictTree.DictTree.add">
<tt class="descname">add</tt><big>(</big><em>k</em>, <em>v</em><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTree.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a key/value. k is a list of hashables.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.DictTree.DictTree.depth">
<tt class="descname">depth</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTree.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum tree depth as an integer.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.DictTree.DictTree.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTree.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of keys where each key is a list of hashables.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.DictTree.DictTree.remove">
<tt class="descname">remove</tt><big>(</big><em>k</em>, <em>v=None</em><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTree.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a key/value. k is a list of hashables.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.DictTree.DictTree.value">
<tt class="descname">value</tt><big>(</big><em>k</em><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTree.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Value corresponding to a key or None. k is a list of hashables.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.DictTree.DictTree.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTree.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all values.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cpip.util.DictTree.DictTreeHtmlTable">
<em class="property">class </em><tt class="descclassname">cpip.util.DictTree.</tt><tt class="descname">DictTreeHtmlTable</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTreeHtmlTable" title="Permalink to this definition">¶</a></dt>
<dd><p>A sub-class of DictTree that helps writing HTML row/col span tables
Suppose we have a tree like this:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><a href="#id27"><span class="problematic" id="id28">|</span></a>- AAA
|</div></blockquote>
<p><a href="#id41"><span class="problematic" id="id42">|- AA &#8211;|</span></a>- AAB
|       |
|       <a href="#id29"><span class="problematic" id="id30">|</span></a>- AAC</p>
</div></blockquote>
<p><a href="#id43"><span class="problematic" id="id44">|- A &#8212;|</span></a></p>
</div></blockquote>
<dl class="docutils">
<dt>Root &#8212;|       <a href="#id31"><span class="problematic" id="id32">|</span></a>- AB</dt>
<dd><div class="first line-block">
<div class="line"><a href="#id33"><span class="problematic" id="id34">|</span></a></div>
<div class="line"><a href="#id35"><span class="problematic" id="id36">|</span></a>- AC &#8212;- ACA</div>
<div class="line"><br /></div>
</div>
<p class="last"><a href="#id37"><span class="problematic" id="id38">|</span></a>- B
|
<a href="#id39"><span class="problematic" id="id40">|</span></a>- C &#8212;- CA &#8212;- CAA</p>
</dd>
</dl>
<p>And we want to represent the tree like this when laid out as
an HTML table:
<a href="#id45"><span class="problematic" id="id46">|&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;|</span></a>
| A     | AA    | AAA   |
|       |       <a href="#id47"><span class="problematic" id="id48">|&#8212;&#8212;-|</span></a>
|       |       | AAB   |
|       |       <a href="#id49"><span class="problematic" id="id50">|&#8212;&#8212;-|</span></a>
|       |       | AAC   |
|       <a href="#id51"><span class="problematic" id="id52">|&#8212;&#8212;&#8212;&#8212;&#8212;|</span></a>
|       | AB            |
|       <a href="#id53"><span class="problematic" id="id54">|&#8212;&#8212;&#8212;&#8212;&#8212;|</span></a>
|       | AC    | ACA   |
<a href="#id55"><span class="problematic" id="id56">|&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;|</span></a>
| B                     |
<a href="#id57"><span class="problematic" id="id58">|&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;|</span></a>
| C     | CA    | CAA   |
<a href="#id59"><span class="problematic" id="id60">|&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;|</span></a></p>
<p>In this example the tree is loaded branch by branch thus:
myTree = DictTreeHtmlTable()
myTree.add((&#8216;A&#8217;, &#8216;AA&#8217;, &#8216;AAA&#8217;), None)
myTree.add((&#8216;A&#8217;, &#8216;AA&#8217;, &#8216;AAB&#8217;), None)
myTree.add((&#8216;A&#8217;, &#8216;AA&#8217;, &#8216;AAC&#8217;), None)
myTree.add((&#8216;A&#8217;, &#8216;AB&#8217;,), None)
myTree.add((&#8216;A&#8217;, &#8216;AC&#8217;, &#8216;ACA&#8217;), None)
myTree.add((&#8216;B&#8217;,), None)
myTree.add((&#8216;C&#8217;, &#8216;CA&#8217;, &#8216;CAA&#8217;), None)</p>
<p>The HTML code generator can be used like this:
# Write: &lt;table border=&#8221;2&#8221; width=&#8221;100%&#8221;&gt;
for anEvent in myTree.genColRowEvents():</p>
<blockquote>
<div><dl class="docutils">
<dt>if anEvent == myTree.ROW_OPEN:</dt>
<dd># Write out the &#8216;&lt;tr&gt;&#8217; element</dd>
<dt>elif anEvent == myTree.ROW_CLOSE:</dt>
<dd># Write out the &#8216;&lt;/tr&gt;&#8217; element</dd>
<dt>else:</dt>
<dd>k, v, r, c = anEvent
# Write &#8216;&lt;td rowspan=&#8221;%d&#8221; colspan=&#8221;%d&#8221;&gt;%s&lt;/td&gt;&#8217; % (r, c, v)</dd>
</dl>
</div></blockquote>
<p># Write: &lt;/table&gt;</p>
<p>And the HTML will look like this:
&lt;table border=&#8221;2&#8221; width=&#8221;100%&#8221;&gt;</p>
<blockquote>
<div><dl class="docutils">
<dt>&lt;tr valign=&#8221;top&#8221;&gt;</dt>
<dd>&lt;td rowspan=&#8221;5&#8221;&gt;A&lt;/td&gt;
&lt;td rowspan=&#8221;3&#8221;&gt;AA&lt;/td&gt;
&lt;td&gt;AAA&lt;/td&gt;</dd>
</dl>
<p>&lt;/tr&gt;
&lt;tr valign=&#8221;top&#8221;&gt;</p>
<blockquote>
<div>&lt;td&gt;AAB&lt;/td&gt;</div></blockquote>
<p>&lt;/tr&gt;
&lt;tr valign=&#8221;top&#8221;&gt;</p>
<blockquote>
<div>&lt;td&gt;AAC&lt;/td&gt;</div></blockquote>
<p>&lt;/tr&gt;
&lt;tr valign=&#8221;top&#8221;&gt;</p>
<blockquote>
<div>&lt;td colspan=&#8221;2&#8221;&gt;AB&lt;/td&gt;</div></blockquote>
<p>&lt;/tr&gt;
&lt;tr valign=&#8221;top&#8221;&gt;</p>
<blockquote>
<div>&lt;td&gt;AC&lt;/td&gt;
&lt;td&gt;ACA&lt;/td&gt;</div></blockquote>
<p>&lt;/tr&gt;
&lt;tr valign=&#8221;top&#8221;&gt;</p>
<blockquote>
<div>&lt;td colspan=&#8221;3&#8221;&gt;B&lt;/td&gt;</div></blockquote>
<p>&lt;/tr&gt;
&lt;tr valign=&#8221;top&#8221;&gt;</p>
<blockquote>
<div>&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;CA&lt;/td&gt;
&lt;td&gt;CAA&lt;/td&gt;</div></blockquote>
<p>&lt;/tr&gt;</p>
</div></blockquote>
<p>&lt;/table&gt;</p>
<dl class="method">
<dt id="cpip.util.DictTree.DictTreeHtmlTable.genColRowEvents">
<tt class="descname">genColRowEvents</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTreeHtmlTable.genColRowEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a set of events that are quadruples.
(key_branch, value, rowspan_int, colspan_int)
The branch is a list of keys the from the branch of the tree.
The rowspan and colspan are both integers.
At the start of the a &lt;tr&gt; there will be a ROW_OPEN
and at row end (&lt;/tr&gt; a ROW_CLOSE will be yielded</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.DictTree.DictTreeHtmlTable.setColRowSpan">
<tt class="descname">setColRowSpan</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.DictTree.DictTreeHtmlTable.setColRowSpan" title="Permalink to this definition">¶</a></dt>
<dd><p>Top level call that sets colspan and rowspan attributes.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="cpip.util.DictTree.ExceptionDictTree">
<em class="property">exception </em><tt class="descclassname">cpip.util.DictTree.</tt><tt class="descname">ExceptionDictTree</tt><a class="headerlink" href="#cpip.util.DictTree.ExceptionDictTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception when handling a DictTree object.</p>
</dd></dl>

<span class="target" id="module-cpip.util.ListGen"></span><p>Treats a list as a generator with an optional additional generator. This is
used for macro replacement for example.</p>
<dl class="class">
<dt id="cpip.util.ListGen.ListAsGenerator">
<em class="property">class </em><tt class="descclassname">cpip.util.ListGen.</tt><tt class="descname">ListAsGenerator</tt><big>(</big><em>theList</em>, <em>theGen=None</em><big>)</big><a class="headerlink" href="#cpip.util.ListGen.ListAsGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that takes a list and provides a generator on that list.</p>
<p>Iterating through the result and stopping when the list is exhausted using
the flag listIsEmpty:
Be clear when this flag is set, for example if we have a list [0,1,2,3]
followed by [&#8216;A&#8217;, &#8216;B&#8217;, &#8216;C&#8217;] thus:
myObj = ListAsGenerator(range(3), ListAsGenerator(list(&#8216;ABC&#8217;)).next())
And we try to iterate over it with list comprehension:
myGen = myObj.next()
myResult = [x for x in myGen if not myObj.listIsEmpty]
myResult will be [0, 1,] because when 3 is yielded the flag is False as
it refers to the _next_ item.
Similarly the list comprehension:
myResult = [x for x in myGen if myObj.listIsEmpty]
Will be [3, &#8216;A&#8217;, &#8216;B&#8217;, &#8216;C&#8217;]
If you want to recover the then this the technique:
myResult = []
if not myObj.listIsEmpty:</p>
<blockquote>
<div><dl class="docutils">
<dt>for aVal in myGen:</dt>
<dd><p class="first">myResult.append(aVal)
if myObj.listIsEmpty:</p>
<blockquote class="last">
<div>break</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>Or exclude the list then this the technique:
if not myObj.listIsEmpty:</p>
<blockquote>
<div><dl class="docutils">
<dt>for aVal in myGen:</dt>
<dd><dl class="first last docutils">
<dt>if myObj.listIsEmpty:</dt>
<dd>break</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>myResult = [x for x in myGen]
The rationale for this behavior is for generating macro replacement tokens
in that the list contains tokens for re-examination and the last token may
turn out to be a function like macro that needs the generator to (possibly)
complete the expansion. Once that last token has been re-examined we do
not want to consume any more tokens than necessary.</p>
<dl class="attribute">
<dt id="cpip.util.ListGen.ListAsGenerator.listIsEmpty">
<tt class="descname">listIsEmpty</tt><a class="headerlink" href="#cpip.util.ListGen.ListAsGenerator.listIsEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the next yield would come from the generator, not the list.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.ListGen.ListAsGenerator.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.ListGen.ListAsGenerator.next" title="Permalink to this definition">¶</a></dt>
<dd><p>yield the next value. The attribute listIsEmpty will be set True
immediately before yielding the last value.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.util.MatrixRep"></span><p>Makes replacements in a list of lines.</p>
<dl class="exception">
<dt id="cpip.util.MatrixRep.ExceptionMatrixRep">
<em class="property">exception </em><tt class="descclassname">cpip.util.MatrixRep.</tt><tt class="descname">ExceptionMatrixRep</tt><a class="headerlink" href="#cpip.util.MatrixRep.ExceptionMatrixRep" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple specialisation of an exception class for MatrixRep.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.util.MatrixRep.MatrixRep">
<em class="property">class </em><tt class="descclassname">cpip.util.MatrixRep.</tt><tt class="descname">MatrixRep</tt><a class="headerlink" href="#cpip.util.MatrixRep.MatrixRep" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes replacements in a list of lines.</p>
<dl class="method">
<dt id="cpip.util.MatrixRep.MatrixRep.addLineColRep">
<tt class="descname">addLineColRep</tt><big>(</big><em>l</em>, <em>c</em>, <em>was</em>, <em>now</em><big>)</big><a class="headerlink" href="#cpip.util.MatrixRep.MatrixRep.addLineColRep" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds to the IR. No test is made to see if there is an existing
or pre-existing conflicting entry or if a sequence of entries makes
sense.
It is expected that callers call this in line/column order of the
original matrix. If not the results of a subsequent call to
sideEffect() are undefined.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.MatrixRep.MatrixRep.sideEffect">
<tt class="descname">sideEffect</tt><big>(</big><em>theMat</em><big>)</big><a class="headerlink" href="#cpip.util.MatrixRep.MatrixRep.sideEffect" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the replacement, if line/col is out of range and
ExceptionMatrixRep will be raised and the state of theMat argument
is undefined.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.util.MaxMunchGen"></span><p>Generic Maximal Munch generator.</p>
<dl class="exception">
<dt id="cpip.util.MaxMunchGen.ExceptionMaxMunchGen">
<em class="property">exception </em><tt class="descclassname">cpip.util.MaxMunchGen.</tt><tt class="descname">ExceptionMaxMunchGen</tt><a class="headerlink" href="#cpip.util.MaxMunchGen.ExceptionMaxMunchGen" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception specialisation for MaxMunchGen.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.util.MaxMunchGen.MaxMunchGen">
<em class="property">class </em><tt class="descclassname">cpip.util.MaxMunchGen.</tt><tt class="descname">MaxMunchGen</tt><big>(</big><em>theGen</em>, <em>theFnS</em>, <em>isExclusive=False</em>, <em>yieldReplacement=False</em><big>)</big><a class="headerlink" href="#cpip.util.MaxMunchGen.MaxMunchGen" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a generator that applies Maximal munch rules.</p>
<dl class="method">
<dt id="cpip.util.MaxMunchGen.MaxMunchGen.gen">
<tt class="descname">gen</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.MaxMunchGen.MaxMunchGen.gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields a maximal munch.
If yieldReplacement is False these will be pairs of (iterable, kind)
where kind is from the function, any replacement will be done on the fly.
If yieldReplacement is True these will be triples of
(iterable, kind, repl) where kind and repl are from the function with
repl being None if no replacement. No replacement will have been done.</p>
<p>TODO: Reconsider this design. Really yieldReplacement decides if the
underlying generator buffer contains the replacement rather than whether
self yields the replacement.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cpip.util.MaxMunchGen.anyToken">
<tt class="descclassname">cpip.util.MaxMunchGen.</tt><tt class="descname">anyToken</tt><big>(</big><em>theGen</em><big>)</big><a class="headerlink" href="#cpip.util.MaxMunchGen.anyToken" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that always reads one token.
This can be used as the last registered function to ensure that the token
stream is read to completion. The kind returned is None.</p>
</dd></dl>

<span class="target" id="module-cpip.util.StrTree"></span><p>Treats a string as a tree.</p>
<dl class="class">
<dt id="cpip.util.StrTree.StrTree">
<em class="property">class </em><tt class="descclassname">cpip.util.StrTree.</tt><tt class="descname">StrTree</tt><big>(</big><em>theIterable=None</em><big>)</big><a class="headerlink" href="#cpip.util.StrTree.StrTree" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO</p>
<dl class="method">
<dt id="cpip.util.StrTree.StrTree.add">
<tt class="descname">add</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#cpip.util.StrTree.StrTree.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a string.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.StrTree.StrTree.has">
<tt class="descname">has</tt><big>(</big><em>s</em>, <em>i=0</em><big>)</big><a class="headerlink" href="#cpip.util.StrTree.StrTree.has" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the end of s that match a complete word
in the tree. i.e. [i:return_value] is in the dictionary.
Note IndexError and KeyError are trapped here.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cpip.util.XmlWrite"></span><p>Writes XML and XHTML.</p>
<dl class="class">
<dt id="cpip.util.XmlWrite.Element">
<em class="property">class </em><tt class="descclassname">cpip.util.XmlWrite.</tt><tt class="descname">Element</tt><big>(</big><em>theXmlStream</em>, <em>theElemName</em>, <em>theAttrs=None</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an element in a markup stream.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.util.XmlWrite.ExceptionXml">
<em class="property">exception </em><tt class="descclassname">cpip.util.XmlWrite.</tt><tt class="descname">ExceptionXml</tt><a class="headerlink" href="#cpip.util.XmlWrite.ExceptionXml" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception specialisation for the XML writer.</p>
</dd></dl>

<dl class="exception">
<dt id="cpip.util.XmlWrite.ExceptionXmlEndElement">
<em class="property">exception </em><tt class="descclassname">cpip.util.XmlWrite.</tt><tt class="descname">ExceptionXmlEndElement</tt><a class="headerlink" href="#cpip.util.XmlWrite.ExceptionXmlEndElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception specialisation for end of element.</p>
</dd></dl>

<dl class="class">
<dt id="cpip.util.XmlWrite.XmlStream">
<em class="property">class </em><tt class="descclassname">cpip.util.XmlWrite.</tt><tt class="descname">XmlStream</tt><big>(</big><em>theFout</em>, <em>theEnc='utf-8'</em>, <em>theDtdLocal=None</em>, <em>theId=0</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.XmlStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and maintains an XML output stream.</p>
<dl class="method">
<dt id="cpip.util.XmlWrite.XmlStream.characters">
<tt class="descname">characters</tt><big>(</big><em>theString</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.XmlStream.characters" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes the string and writes it to the output.</p>
</dd></dl>

<dl class="attribute">
<dt id="cpip.util.XmlWrite.XmlStream.id">
<tt class="descname">id</tt><a class="headerlink" href="#cpip.util.XmlWrite.XmlStream.id" title="Permalink to this definition">¶</a></dt>
<dd><p>A unique ID in this stream. The ID is incremented for each access.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.XmlWrite.XmlStream.literal">
<tt class="descname">literal</tt><big>(</big><em>theString</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.XmlStream.literal" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes theString to the output without encoding.</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.XmlWrite.XmlStream.writeECMAScript">
<tt class="descname">writeECMAScript</tt><big>(</big><em>theScript</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.XmlStream.writeECMAScript" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the ECMA script.
&lt;script type=&#8221;text/ecmascript&#8221;&gt;
//&lt;![CDATA[
...
// ]]&gt;
&lt;/script&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cpip.util.XmlWrite.XmlStream.xmlSpacePreserve">
<tt class="descname">xmlSpacePreserve</tt><big>(</big><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.XmlStream.xmlSpacePreserve" title="Permalink to this definition">¶</a></dt>
<dd><p>Suspends indentation for this element and its descendants.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cpip.util.XmlWrite.decodeString">
<tt class="descclassname">cpip.util.XmlWrite.</tt><tt class="descname">decodeString</tt><big>(</big><em>theS</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.decodeString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string that is the argument decoded. May raise a TypeError.</p>
</dd></dl>

<dl class="function">
<dt id="cpip.util.XmlWrite.encodeString">
<tt class="descclassname">cpip.util.XmlWrite.</tt><tt class="descname">encodeString</tt><big>(</big><em>theS</em>, <em>theCharPrefix='_'</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.encodeString" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns a string that is the argument encoded.</dt>
<dd><blockquote class="first">
<div>Table 1: The Base 64 Alphabet</div></blockquote>
<dl class="last docutils">
<dt>Value Encoding  Value Encoding  Value Encoding  Value Encoding</dt>
<dd><blockquote class="first">
<div>0 A            17 R            34 i            51 z
1 B            18 S            35 j            52 0
2 C            19 T            36 k            53 1
3 D            20 U            37 l            54 2
4 E            21 V            38 m            55 3
5 F            22 W            39 n            56 4
6 G            23 X            40 o            57 5
7 H            24 Y            41 p            58 6
8 I            25 Z            42 q            59 7
9 J            26 a            43 r            60 8</div></blockquote>
<p class="last">10 K            27 b            44 s            61 9
11 L            28 c            45 t            62 +
12 M            29 d            46 u            63 /
13 N            30 e            47 v
14 O            31 f            48 w         (pad) =
15 P            32 g            49 x
16 Q            33 h            50 y</p>
</dd>
</dl>
</dd>
</dl>
<p>See section 3 of : <a class="reference external" href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a></p>
</dd></dl>

<dl class="function">
<dt id="cpip.util.XmlWrite.nameFromString">
<tt class="descclassname">cpip.util.XmlWrite.</tt><tt class="descname">nameFromString</tt><big>(</big><em>theStr</em><big>)</big><a class="headerlink" href="#cpip.util.XmlWrite.nameFromString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a name from a string.
See <a class="reference external" href="http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-cdata">http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-cdata</a>
&#8220;ID and NAME tokens must begin with a letter ([A-Za-z]) and may be
followed by any number of letters, digits ([0-9]), hyphens (&#8220;-&#8221;),
underscores (&#8220;_&#8221;), colons (&#8221;:&#8221;), and periods (&#8221;.&#8221;).
This also works for in namespaces as &#8216;:&#8217; is not used in the encoding.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CPIP Reference</a><ul>
<li><a class="reference internal" href="#todo-2008-11-21">TODO: 2008-11-21</a></li>
<li><a class="reference internal" href="#bounding-boxes">Bounding Boxes</a></li>
<li><a class="reference internal" href="#verticies">Verticies</a></li>
<li><a class="reference internal" href="#transfoming-sizes-and-positions">Transfoming sizes and positions</a></li>
<li><a class="reference internal" href="#incrementing-child-positions">Incrementing child positions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial/FileIncGraph.html"
                        title="previous chapter">FileIncludeGraph Tutorial</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/reference.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial/FileIncGraph.html" title="FileIncludeGraph Tutorial"
             >previous</a> |</li>
        <li><a href="index.html">CPIP v0.8.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Paul Ross.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>